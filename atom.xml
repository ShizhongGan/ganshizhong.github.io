<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>钟声</title>
  <icon>https://www.gravatar.com/avatar/fa65dd480df94b0c4abae5c60b4365d4</icon>
  <subtitle>甘士忠个人博客</subtitle>
  <link href="http://shizhonggan.github.io/atom.xml" rel="self"/>
  
  <link href="http://shizhonggan.github.io/"/>
  <updated>2022-07-15T07:06:13.621Z</updated>
  <id>http://shizhonggan.github.io/</id>
  
  <author>
    <name>甘士忠</name>
    <email>gan_shizhong@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker 部署 Django</title>
    <link href="http://shizhonggan.github.io/2022/08/06/Django/django_deploy/"/>
    <id>http://shizhonggan.github.io/2022/08/06/Django/django_deploy/</id>
    <published>2022-08-06T03:03:04.000Z</published>
    <updated>2022-07-15T07:06:13.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker-部署-django-web"><a href="#docker-部署-django-web" class="headerlink" title="docker 部署 django web"></a>docker 部署 django web</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">demosite</span><br><span class="line">├── db.sqlite3</span><br><span class="line">├── demosite</span><br><span class="line">│   ├── htmlstudy.py</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── search.py</span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   ├── testdb.py</span><br><span class="line">│   ├── urls.py</span><br><span class="line">│   ├── views.py</span><br><span class="line">│   └── wsgi.py</span><br><span class="line">├── manage.py</span><br><span class="line">├── media</span><br><span class="line">├── readme</span><br><span class="line">├── test.py</span><br><span class="line">├── uwsgi.ini</span><br><span class="line">└── uwsgi_params</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="mysql-安装-与设置"><a href="#mysql-安装-与设置" class="headerlink" title="mysql 安装 与设置"></a>mysql 安装 与设置</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ apt install mysql-server  # 安装数据库</span><br><span class="line">$ apt-get install libmysqlclient-dev # 必须安装</span><br><span class="line">$ pip3 install mysqlclient # 不安装上面module，此处安装会失败</span><br><span class="line">$ sql </span><br><span class="line"><span class="comment">### 常用命令</span></span><br><span class="line">mysql&gt; create database database_name # 创建数据库</span><br><span class="line">mysql&gt; show databases; # 查看数据库列表</span><br><span class="line">mysql&gt; use database_name; # 使用某一个数据库,进入该数据库下</span><br><span class="line">mysql&gt; create table table_name (id int,age int) # 在该数据库下创建表格,括号内是列名和对应的类型,一列即可</span><br><span class="line">mysql&gt; drop database database_name # 删除某个数据库</span><br><span class="line">mysql&gt; show tables; # 查看所有表</span><br><span class="line"><span class="comment">#####</span></span><br><span class="line">mysql&gt; create database demosite; # 创建名为demosite的数据库</span><br><span class="line">mysql&gt; use demosite; # 进入该数据库下</span><br><span class="line">mysql&gt; create table demosite # 创建名为demosite的表，可与数据库名重复</span><br><span class="line">mysql&gt; create user &#x27;demosite&#x27;@&#x27;localhost&#x27; identified by &#x27;setting-user-password&#x27;;</span><br><span class="line"><span class="comment">## grant使用说明</span></span><br><span class="line">Grant  &lt;权限&gt;  on  表名[(列名)]  to  用户 With  grant  option</span><br><span class="line">或 GRANT &lt;权限&gt; ON &lt;数据对象&gt; FROM &lt;数据库用户&gt;  </span><br><span class="line"></span><br><span class="line">mysql&gt; grant usage on *.* to &#x27;demosite&#x27;@&#x27;localhost&#x27;; # demoste无权访问所有文件</span><br><span class="line">mysql&gt; grant all privileges on demosite.* to &#x27;demosite&#x27;@&#x27;localhost&#x27;;# 赋予demosite用户访问demosite数据库下所有表的权限,注意demosite区分</span><br><span class="line"><span class="comment">###### demosite django程序的setting.py文件修改</span></span><br><span class="line"><span class="attr">DATABASES</span> = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">        &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,</span><br><span class="line">        &#x27;NAME&#x27;: &#x27;demosite&#x27;, # 数据库名</span><br><span class="line">        &#x27;USER&#x27;: &#x27;demosite&#x27;, # 用户名</span><br><span class="line">        &#x27;PASSWORD&#x27;: &#x27;1234&#x27;, # 用户密码</span><br><span class="line">        &#x27;HOST&#x27;: &#x27;localhost&#x27;,</span><br><span class="line">        &#x27;PORT&#x27;:3306, # mysql默认端口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><p>操作系统ubuntu18，该系统有大量的软件库，因此安装docker极为方便，通常命令行输入docker，若未安装该软件，会提示如何快捷安装。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker.io</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker search ubuntu</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NAME                                                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">ubuntu                                                    Ubuntu is a Debian-based Linux operating sys…   9843                [OK]</span><br><span class="line">dorowu&#x2F;ubuntu-desktop-lxde-vnc                            Docker image to provide HTML5 VNC interface …   334                                     [OK]</span><br><span class="line">rastasheep&#x2F;ubuntu-sshd                                    Dockerized SSH service, built on top of offi…   228                                     [OK]</span><br><span class="line">consol&#x2F;ubuntu-xfce-vnc                                    Ubuntu container with &quot;headless&quot; VNC session…   186                                     [OK]</span><br><span class="line">ubuntu-upstart                                            Upstart is an event-based replacement for th…   99                  [OK]</span><br><span class="line">ansible&#x2F;ubuntu14.04-ansible                               Ubuntu 14.04 LTS with ansible                   97                                      [OK]</span><br><span class="line">neurodebian                                               NeuroDebian provides neuroscience research s…   58                  [OK]</span><br><span class="line">1and1internet&#x2F;ubuntu-16-nginx-php-phpmyadmin-mysql-5      ubuntu-16-nginx-php-phpmyadmin-mysql-5          50                                      [OK]</span><br><span class="line">ubuntu-debootstrap                                        debootstrap --variant&#x3D;minbase --components&#x3D;m…   40                  [OK]</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu</span><br><span class="line">$ docker images</span><br></pre></td></tr></table></figure><h2 id="uwsgi-安装-设置"><a href="#uwsgi-安装-设置" class="headerlink" title="uwsgi 安装 设置"></a>uwsgi 安装 设置</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip3 install uwsgi</span><br><span class="line"><span class="comment"># demosite下创建test.py，测试uwsgi </span></span><br><span class="line">def application(env, start_response):</span><br><span class="line">    start_response(&#x27;200 OK&#x27;, [(&#x27;Content-Type&#x27;,&#x27;text/html&#x27;)])</span><br><span class="line">    return [b&quot;Hello World&quot;] # python3</span><br><span class="line">    <span class="comment">#return [&quot;Hello World&quot;] # python2</span></span><br><span class="line">uwsgi --http :8000 --wsgi-file test.py # 若服务器IP:8000访问成功，即没有问题，一般情况都是正常的</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 前三行命令参考菜鸟教程，后边为正常操作</span></span><br><span class="line">$ python manage.py migrate   # 创建表结构, 此处我也不是很明白</span><br><span class="line">$ python manage.py makemigrations TestModel  # 让 Django 知道我们在我们的模型有一些变更</span><br><span class="line">$ python manage.py migrate TestModel   # 创建表结构</span><br><span class="line">python3 manage.py makemigrations # 执行该命令,djangoweb就知道发生了哪些变化，日常操作</span><br><span class="line">python3 manage.py runserver 0.0.0.0:8000 # 服务器首先需要打开端口8000，浏览器打开  服务器IP:8000 即可访问</span><br><span class="line">uwsgi --http :8000 --module demosite.wsgi # 或者采用这种方式</span><br><span class="line"><span class="comment">### 关闭服务器远程桌面，django web 后台保护模式运行，不停止</span></span><br><span class="line">nohup uwsgi --http :8000 --module demosite.wsgi &amp; </span><br><span class="line">ps -aux | grep uwsgi |awk &#x27;&#123;print $2&#125;&#x27; |xargs kill -9 #终止后台托管</span><br><span class="line"></span><br><span class="line">uwsgi --http-socket :6816 --plugin python --wsgi-file demosite/wsgi.py</span><br></pre></td></tr></table></figure><h2 id="静态文件部署"><a href="#静态文件部署" class="headerlink" title="静态文件部署"></a>静态文件部署</h2><h2 id="docker-部署"><a href="#docker-部署" class="headerlink" title="docker 部署"></a>docker 部署</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu/python:<span class="number">3.6</span>.<span class="number">8</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> gsz <span class="string">&quot;gan_shizhong@163.com&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> mypath /demosite</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$mypath</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./demosite/* <span class="variable">$mypath</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt update \</span></span><br><span class="line"><span class="bash">        &amp;&amp; apt install -y  python3-pip \</span></span><br><span class="line"><span class="bash">            mysql-server\</span></span><br><span class="line"><span class="bash">        &amp;&amp; pip3 install uwsgi \</span></span><br><span class="line"><span class="bash">            django</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8001</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> python3 manage.py makemigrations</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [ <span class="string">&quot;uwsgi&quot;</span> ]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;--http :8001 --module demosite.wsgi&quot;</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu/python:<span class="number">3.6</span>.<span class="number">8</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> gsz <span class="string">&quot;gan_shizhong@163.com&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> mypath /demosite</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$mypath</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./sendcloud_django2/* <span class="variable">$mypath</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt update \</span></span><br><span class="line"><span class="bash">        &amp;&amp; apt install -y  python3-pip</span></span><br><span class="line">        &amp;&amp; pip3 install uwsgi \</span><br><span class="line">            django==<span class="number">2.2</span>.<span class="number">8</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8002</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> python3 manage.py makemigrations</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> python3 manage.py migrate</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [ <span class="string">&quot;uwsgi&quot;</span> ]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;--http :8002 --module demosite.wsgi&quot;</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="nginx-uwsgi-部署"><a href="#nginx-uwsgi-部署" class="headerlink" title="nginx uwsgi 部署"></a>nginx uwsgi 部署</h2><h3 id="1-参考文献"><a href="#1-参考文献" class="headerlink" title="1. 参考文献"></a>1. 参考文献</h3><p><a href="https://code.ziqiangxuetang.com/django/django-nginx-deploy.html">Django 部署(Nginx)</a></p><p>添加镜像源 </p><ol><li><p>编辑源配置文件 /etc/apt/sources.list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">echo &#39;#aliyun</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-security main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-updates main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-proposed main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-backports main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-security main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-updates main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-proposed main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-backports main restricted universe multiverse</span><br><span class="line">echo &#39;# tsinghua</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial main restricted</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial-updates main restricted</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial-updates universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial-updates multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial-security main restricted</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial-security universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial-security multiverse&#39; &gt; &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>执行 apt-get update</p></li><li><p>pip添加镜像源</p></li></ol><ul><li>临时使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple some-package</span><br></pre></td></tr></table></figure></li><li>设置默认(存在问题pip3 不行)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pip3 -U</span><br><span class="line">pip3 config set global.index-url https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br></pre></td></tr></table></figure></li></ul><p>PYTHONIOENCODING=utf-8 python your_script.py</p><h3 id="2-具体流程"><a href="#2-具体流程" class="headerlink" title="2. 具体流程"></a>2. 具体流程</h3><ul><li>启动docker<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 8321:8001 -v /home/ec2-user/sinnetflow/:/home/ --name sinnetflow centos:centos7 bash</span><br></pre></td></tr></table></figure></li><li>安装<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## nginx 安装</span></span><br><span class="line">yum install epel-release</span><br><span class="line">yum install nginx</span><br><span class="line"><span class="comment">## mariadb 安装 </span></span><br><span class="line">vi /etc/yum.repos.d/MariaDB.repo</span><br><span class="line">[mariadb]</span><br><span class="line">name = MariaDB</span><br><span class="line">baseurl = https://mirrors.tuna.tsinghua.edu.cn/mariadb/yum/10.5/centos7-amd64/</span><br><span class="line">gpgkey =  https://mirrors.tuna.tsinghua.edu.cn/mariadb/yum/RPM-GPG-KEY-MariaDB</span><br><span class="line">gpgcheck = 1</span><br><span class="line"></span><br><span class="line"><span class="comment">## 清楚并创建缓存</span></span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line"></span><br><span class="line">yum install MariaDB-server MariaDB-client -y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl start mariadb</span><br><span class="line">systemctl <span class="built_in">enable</span> mariadb</span><br><span class="line">systemctl status mariadb</span><br><span class="line"></span><br><span class="line">yum install python3-pip</span><br><span class="line"></span><br><span class="line">yum install gcc mysql-devel python3-devel</span><br><span class="line">pip install mysqlclient</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">traceroute </span><br><span class="line">ICMP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pip3 install uwsgi --upgrade</span><br><span class="line">pip3 install django==2.2</span><br><span class="line">pip3 install requests</span><br></pre></td></tr></table></figure></li><li>nginx <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 配置文件 </span></span><br><span class="line">cp /etc/nginx/sites-available/default /etc/nginx/sites-available/default.bak</span><br><span class="line">vim /etc/nginx/sites-available/default</span><br><span class="line"><span class="comment">## 内容如下：</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen 8000;</span><br><span class="line">        location / &#123;</span><br><span class="line">                uwsgi_pass django;</span><br><span class="line">                include /etc/nginx/uwsgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">        location /media &#123;</span><br><span class="line">                alias /home/media;</span><br><span class="line">        &#125;</span><br><span class="line">        location /static &#123;</span><br><span class="line">                alias /static;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">upstream django&#123;</span><br><span class="line">        server unix:///etc/workflow/workflow.sock;</span><br><span class="line">        <span class="comment"># server 127.0.0.1:8001;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">## 项目根目录下新建uwsgi.ini , 内容如下：</span></span><br><span class="line"><span class="comment"># mysite_uwsgi.ini file</span></span><br><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Django-related settings</span></span><br><span class="line"><span class="comment"># the base directory (full path)</span></span><br><span class="line"><span class="attr">chdir</span>           = /home</span><br><span class="line"><span class="comment"># Django&#x27;s wsgi file</span></span><br><span class="line"><span class="attr">module</span>          = sinnet.wsgi</span><br><span class="line"><span class="comment"># the virtualenv (full path)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># process-related settings</span></span><br><span class="line"><span class="comment"># master</span></span><br><span class="line"><span class="attr">master</span>          = <span class="literal">true</span></span><br><span class="line"><span class="comment"># maximum number of worker processes</span></span><br><span class="line"><span class="attr">processes</span>       = <span class="number">4</span></span><br><span class="line"><span class="comment"># the socket (use the full path to be safe</span></span><br><span class="line"><span class="attr">socket</span>          = /etc/mailweb/mysite.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># ... with appropriate permissions - may be needed</span></span><br><span class="line"><span class="comment"># chmod-socket    = 664</span></span><br><span class="line"><span class="comment"># clear environment on exit</span></span><br><span class="line"><span class="attr">vacuum</span>          = <span class="literal">true</span></span><br><span class="line"><span class="attr">socket-timeout</span> = <span class="number">20000</span></span><br><span class="line"><span class="attr">daemonize</span> = /etc/mailweb/mailweb.log</span><br><span class="line"><span class="attr">log-maxsize</span> = <span class="number">50000000</span></span><br><span class="line"><span class="attr">disable-logging</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">max-requests</span> = <span class="number">5000</span></span><br><span class="line"><span class="attr">pidfile</span> = /etc/mailweb/mailweb.pid</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="部署操作"><a href="#部署操作" class="headerlink" title="部署操作"></a>部署操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># setting.py 设置 static_root &#x3D; &quot;path&quot;，服务器环境的绝对路径</span><br><span class="line"># Debug改成False</span><br><span class="line"># 时区修改</span><br><span class="line">python3 manage.py collectstatic # 首先将静态文件集中到一个文件夹下</span><br><span class="line"></span><br><span class="line"># 启动 nginx</span><br><span class="line">service nginx restart</span><br><span class="line"># 启动 uwsgi</span><br><span class="line">uwsgi -d --ini uwsgi.ini #后台</span><br><span class="line">uwsgi --stop mailweb.pid # 终止进程</span><br></pre></td></tr></table></figure><h2 id="使用supervisor管理进程"><a href="#使用supervisor管理进程" class="headerlink" title="使用supervisor管理进程"></a>使用supervisor管理进程</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pip3 install supervisor # 安装</span><br><span class="line">echo_supervisord_conf &gt; /etc/supervisord.conf # 生成默认配置文件</span><br><span class="line"><span class="comment">## 修改配置文件，再supervisord.conf末尾添加，同事修改其他log文件路径，避免放在temp文件下。</span></span><br><span class="line"><span class="section">[program:celerytask]</span></span><br><span class="line"><span class="attr">command</span>=celery worker -A celerytask.main -l info</span><br><span class="line"><span class="attr">directory</span>=/home/</span><br><span class="line"><span class="attr">startsecs</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">stopwaitsecs</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">stdout_logfile</span>=/var/log/sinnetMail/sinnetmail_celery.log</span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span>=<span class="number">10</span>MB   <span class="comment">; max # logfile bytes b4 rotation (default 50MB)</span></span><br><span class="line"><span class="attr">stderr_logfile</span>=/var/log/sinnetMail/sinnetmail_celery_err.log</span><br><span class="line"><span class="attr">stderr_logfile_maxbytes</span>=<span class="number">10</span>MB   <span class="comment">; max # logfile bytes b4 rotation (default 50MB)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">supervisord -c /etc/supervisord.conf</span><br><span class="line"><span class="comment"># 通用命令</span></span><br><span class="line">supervisorctl -c /etc/supervisord.conf [start|stop|restart] [program-name|all]</span><br></pre></td></tr></table></figure></li></ul><h2 id="git-gitigonre-失效解决办法"><a href="#git-gitigonre-失效解决办法" class="headerlink" title="git .gitigonre 失效解决办法"></a>git .gitigonre 失效解决办法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;update .gitignore&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker-部署-django-web&quot;&gt;&lt;a href=&quot;#docker-部署-django-web&quot; class=&quot;headerlink&quot; title=&quot;docker 部署 django web&quot;&gt;&lt;/a&gt;docker 部署 django web&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="Django" scheme="http://shizhonggan.github.io/categories/Django/"/>
    
    
    <category term="Docker" scheme="http://shizhonggan.github.io/tags/Docker/"/>
    
    <category term="Django" scheme="http://shizhonggan.github.io/tags/Django/"/>
    
    <category term="Mysql" scheme="http://shizhonggan.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>网络常见问题</title>
    <link href="http://shizhonggan.github.io/2022/07/27/NetWorking/networkbasic/"/>
    <id>http://shizhonggan.github.io/2022/07/27/NetWorking/networkbasic/</id>
    <published>2022-07-27T03:03:04.000Z</published>
    <updated>2022-07-28T05:33:49.573Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用程序"><a class="markdownIt-Anchor" href="#应用程序"></a> 应用程序</h2><ul><li>计算机组成原理<ul><li>描述计算机是什么？计算是怎么回事？硬件如何为应用提供计算？</li></ul></li><li>操作系统<ul><li>最大的实践意义是：如何合理规划应用的生命周期以及资源使用。比如如何处理高并发、如何提升系统的稳定性、如何节约硬件成本等。</li></ul></li><li>计算机网络：<ul><li>讲的是应用之间如何进行通信、如何设计应用之间的契约，形成稳定、高效、规范的协作关系（也就是协议），通过优化网络的性能，最终节省成本或者让用户满意<ul><li>为了让页面秒开、服务秒回，所作出的努力</li><li>为了优化网络传输细节，去调整TCP的滑动窗口</li><li>为了提升网络的吞吐量、减少延迟，去开启多路复用能力</li><li>为了避免Downtime,去调整网络的连接池和线程数</li><li>为了开发某个应用，尝试理解应用层协议，如：SSH、RTCP、HTTP2.0、MQTT</li><li>为了做好日常开发，去理解一些基本概念，如：DNS、CDN、NAT、IPv4/6等</li></ul></li></ul></li><li>算法和数据结构【重学数据结构与算法，公瑾，笔记：<a href="https://www.cnblogs.com/jmcui/p/15224732.html%E3%80%91">https://www.cnblogs.com/jmcui/p/15224732.html】</a><ul><li>算法是一个设计过程，数据结构是数据的组织方式</li><li>在给定资源的条件下，最低的延迟、最少的计算时间、最大的空间利用率</li></ul></li><li>图形学<ul><li>AI是将数据看作为图片，从图形中找到概率特征</li></ul></li><li>编程技巧<ul><li>需要深入学习</li></ul></li><li>编译原理<ul><li>程序语言如何被实现，源代码如何被编译</li></ul></li></ul><h2 id="常见问题"><a class="markdownIt-Anchor" href="#常见问题"></a> 常见问题</h2><p>TCP队头阻塞，没有预备方案，导致分布式集群中部分发生延迟，导致系统雪崩</p><p>DDoS</p><p>DNS</p><p>跨机房通信问题</p><h2 id="tcp-为什么要三次握手"><a class="markdownIt-Anchor" href="#tcp-为什么要三次握手"></a> TCP 为什么要三次握手</h2><h2 id="https协议的ttfb传输时间"><a class="markdownIt-Anchor" href="#https协议的ttfb传输时间"></a> HTTPS协议的TTFB传输时间</h2><h2 id="dns故障排查"><a class="markdownIt-Anchor" href="#dns故障排查"></a> DNS故障排查</h2><p>Linux下 诸如 nslookup, telnet, lsof, netstat等网络相关的指令一知半解导致不知道如何定位问题。</p><h2 id="使用tcp连接时需注意问题"><a class="markdownIt-Anchor" href="#使用tcp连接时需注意问题"></a> 使用TCP连接时需注意问题</h2><p>只考虑收发数据、不能考虑到队头阻塞、多路复用等问题，导致经常出现系统负载不高、但是吞吐量很低的情况</p><h2 id="网络调试-网络优化"><a class="markdownIt-Anchor" href="#网络调试-网络优化"></a> 网络调试、网络优化</h2><h2 id="常识问题"><a class="markdownIt-Anchor" href="#常识问题"></a> 常识问题</h2><ul><li><p>telnet调试远程服务、用whireshark抓包定位网络故障</p></li><li><p>把ulimit设置成多少？</p></li><li><p>Dubbo异步单一连接扛不住了该怎么办？</p></li><li><p>用HTTP协议的Keep-Alive维持心跳可不可行？</p></li><li><p>开发应用或程序时，用什么协议？用哪个网络框架？</p></li><li><p>没有办法优化参数，或者当承接了系统优化的工作时，由于计算机网络知识不扎实，会陷入无穷无尽的学习</p></li><li><p>TCP队头阻塞</p></li><li><p>滑动窗口</p></li><li><p>ARP和路由算法</p></li></ul><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/framework.png" alt="frame" /></p><h2 id="网络的基础机构"><a class="markdownIt-Anchor" href="#网络的基础机构"></a> 网络的基础机构</h2><p>路由器、交换机、终端、基站等以及背后隐含的网络</p><h2 id="网络的工作原理"><a class="markdownIt-Anchor" href="#网络的工作原理"></a> 网络的工作原理</h2><ul><li>算法问题<ul><li>滑动窗口、路由和寻址</li></ul></li><li>细节问题<ul><li>封包格式</li></ul></li><li>工作原理<ul><li>多路复用、缓存设计、Socket、I/O模型等</li></ul></li></ul><h2 id="网络的应用场景"><a class="markdownIt-Anchor" href="#网络的应用场景"></a> 网络的应用场景</h2><h3 id="https-协议握手的过程"><a class="markdownIt-Anchor" href="#https-协议握手的过程"></a> HTTPS 协议握手的过程</h3><h3 id="rpc-是如何工作的"><a class="markdownIt-Anchor" href="#rpc-是如何工作的"></a> RPC 是如何工作的</h3><h3 id="im系统是如何工作的"><a class="markdownIt-Anchor" href="#im系统是如何工作的"></a> IM系统是如何工作的</h3><h3 id="抓包用什么工具"><a class="markdownIt-Anchor" href="#抓包用什么工具"></a> 抓包用什么工具</h3><h3 id="要注意什么安全攻防"><a class="markdownIt-Anchor" href="#要注意什么安全攻防"></a> 要注意什么安全攻防</h3><h3 id="网络出了问题怎么排查"><a class="markdownIt-Anchor" href="#网络出了问题怎么排查"></a> 网络出了问题怎么排查</h3><hr /><ul><li>计算机网络<ul><li>互联网和传输层协议<ul><li>互联网的整体架构</li><li>TCP协议</li><li>TCP的封包格式</li><li>TCP的原理和算法</li><li>UDP协议</li></ul></li><li>网络层协议<ul><li>IP协议</li><li>IPv6协议</li><li>局域网和NAT</li><li>实战：TCP/IP抓包</li></ul></li><li>网络编程<ul><li>Socket是什么</li><li>Socket和I/O模型</li><li>流和缓冲区</li><li>BIO, NIO, AIO</li><li>RPC框架原理</li></ul></li><li>Web技术<ul><li>DNS</li><li>CDN</li><li>HTTP协议</li><li>流媒体技术</li><li>爬虫和反爬虫</li></ul></li><li>网络安全<ul><li>加密、解密和证书</li><li>信任链</li><li>常见攻防手段</li></ul></li></ul></li></ul><h2 id="互联网和传输层协议"><a class="markdownIt-Anchor" href="#互联网和传输层协议"></a> 互联网和传输层协议</h2><ul><li>互联网的体系和整体架构</li><li>硬件设备以及作用</li><li>传输层协议TCP和UDP</li></ul><h3 id="1-漫游互联网-什么是蜂窝移动网络"><a class="markdownIt-Anchor" href="#1-漫游互联网-什么是蜂窝移动网络"></a> <strong>1. 漫游互联网： 什么是蜂窝移动网络</strong></h3><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/networkgroup.png" alt="frame" /><br /><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/PacketSwitch.png" alt="frame" /></p><p>交换技术的本质：让数据切换路径</p><p>网络中的数据是以<strong>分组</strong>或<strong>封包</strong>(Packet)的形式</p><p>具备交换的网络设备： <strong>路由器（Router）<strong>和</strong>链路层交换机（Link-Layer Switch）</strong></p><p>在移动网络中，无线信号构成了通信链路，通信的核心被称为<strong>蜂窝塔（Cellular Tower）</strong>，有时候也被称为基站（BaseStation）。ISP 将网络供给处于蜂窝网络边缘的路由器，路由器连接蜂窝塔，再通过蜂窝塔（基站）提供处于六边形地区中的设备。</p><p>在蜂窝网络一定范围内的区域，离用户较近的地方还可以部署服务器，帮助用户完成计算。这相当于计算资源的下沉，称为 <strong>“边缘计算”</strong>。相比中心化的计算，边缘计算<strong>延迟低、链路短</strong>，能够将更好的体验带给距离边缘计算集群最近的节点。从而让用户享受到更优质、延迟更低、算力更强的服务。</p><p><strong>通信链路</strong>是一个抽象概念，这里说的抽象，就是面向对象中抽象类和继承类的关系，比如公司网络使用同轴电缆作为通信链路、移动网络使用无线信号的发送接收器作为通信链路、家用网络使用蓝牙信道作为通信链路等；</p><p>我们可以把<strong>网络传输</strong>分为两类，一类是<strong>端对端（Host-to-Host）<strong>的能力，由 TCP/IP 协议群提供；另一类是</strong>广播</strong>的能力，是一对多、多对多的能力，可以看作端对端（Host-to-Host）能力的延伸。</p><h3 id="2-传输层协议tcp-tcp为什么是握手3次-挥手是4次"><a class="markdownIt-Anchor" href="#2-传输层协议tcp-tcp为什么是握手3次-挥手是4次"></a> <strong>2. 传输层协议TCP: TCP为什么是握手3次、挥手是4次</strong></h3><p>TCP（Transport Control Protocol）是一个传输层协议，提供 Host-To-Host 数据的可靠传输，支持全双工，是一个连接导向的协议。</p><p>TCP/IP 协议群</p><ul><li>应用层提供的是应用到应用（Application-To-Application）的协议，比如微信和微信服务器；</li><li>传输层提供的是主机到主机（Host-To-Host）的协议，比如手机、平板、Linux 主机等；</li><li>网络层提供的是地址到地址（Address-To-Address）的协议，IP 协议就在这一层工作；</li><li>链路层提供的是设备到设备（Device-To-Device）的协议；</li><li>物理层提供最底层的传输能力，当信号在两个设备间传递的时候，物理层封装最底层的物理设备、传输介质等</li></ul><p>TCP（Transport Control Protocol）是一个传输层协议，提供 Host-To-Host 数据的可靠传输，支持全双工，是一个连接导向的协议。</p><p>TCP 上层的应用层协议使用 TCP 能力的时候，需要告知 TCP 是哪个应用 —— 这就是端口号，端口号用于区分应用。</p><p><strong>连接（Connection）是传输层</strong>的概念，是数据传输双方的契约；<strong>会话（Session）是应用层</strong>的概念，是应用的行为；</p><p><strong>TCP 是一个双工协议</strong>，数据任何时候都可以双向传输，那么什么是双工/单工：</p><ul><li><strong>单工</strong>：在任何一个时刻，数据只能单向发送。单工需要至少一条线路；</li><li><strong>半双工</strong>：在某个时刻数据可以向一个方向传输，也可以向另一个方向反方向传输，而且交替进行。半双工需要至少一条线路；</li><li><strong>全双工</strong>：任何时刻数据都可以双向发送。全双工需要大于一条线路；</li><li>客户端和服务端在TCP协议中都被称为<strong>Host(主机)</strong></li></ul><p><strong>可靠性</strong>（数据保证无损传输）：如果发送方按照顺序发送，然后数据无序地在网络间传递，就必须有一种算法在接收方将数据恢复原有的顺序；如果发送方同时把消息发送给多个接收方，这种情况叫做<strong>多播</strong>，可靠性要求每个接收方都收到相同的副本。</p><p>TCP是一个连接导向的协议设计有建立（<strong>握手</strong>）和断开连接（<strong>挥手</strong>）的过程。</p><p>TCP协议的基本操作：</p><ul><li>如果一个Host主动向另一个Host发起连接，成为<strong>SYN</strong>(Synchronization)，<strong>请求同步</strong></li><li>如果一个Host主动断开请求，称为<strong>FIN</strong>(Finish),请求完成</li><li>如果一个Host给另一个Host发送数据，成为<strong>PSH</strong>(Push),数据推送</li></ul><blockquote><p>接收方收到数据后，都需要给发送一个<strong>ACK响应</strong>，保持连接和可靠性约束，TCP协议要保证每一条发出的数据必须给返回</p></blockquote><p>三次握手： C–(SYN)–S--(SYN-ACK)–C--(ACK)–S</p><p>四次挥手： C–(FIN)–S--(ACK) 然后 (FIN) --C–ACK–S</p><blockquote><p>为TCP协议增加协议头，在协议头中取多个位(bit),其中SYN,ACK,PSH都占有1个位，这种设计成为标识(Flag)04</p></blockquote><p>TCP是一个面向连接的协议(<strong>Connection-oriented Protool</strong>),就是说TCP协议参与双方(Host)在手法数据前会先建立连接。而UDP是一面发送报文(<strong>Datagram-oriented</strong>)的协议，不需要建立连接，直接发送报文(数据)</p><p>因此，TCP3次握手4次挥手的原因：TCP是一个双工协议，为了让双方都保证，建立连接的时候，连接双方都需要向对方发起SYC(同步请求)和ACK(响应)，握手阶段双方都没有繁琐的工作，因此一方向另一方发起同步(SYN)之后，另一方可以将自己的ACK和SYN打包作为一条消息回复，因此是3次握手需要3次数据传输；挥手阶段，双方都有可能未完成的工作，收到挥手请求的一方，必须马上响应(ACK)，表示接收到了挥手请求，最后等所有工作结束，再发送请求中断连接(FIN)，因此是4次挥手</p><blockquote><p>思考：一台内存为8G左右的服务器可以同时维护多少个连接？</p></blockquote><p>100w?连接是内存中的状态对象，从理论上分析，连接本身不太占用内存。不同语言连接对象大小不等，但是通常很小。当单机建立太多链接，会爆出 Cannot assign requested address 异常，这是由于没建立一个连接，操作系统就会为客户端分配端口号，端口号很快就被占用用尽所以核心问题是，通信需要缓冲区，通讯需要 I/O 。这是因为通讯占用资源，连接本身占用资源少。</p><blockquote><p>压力测试最常用的工具是 <strong>Apache Benchmark</strong> （简称 AB）或者用<strong>JMeter</strong>(有界面)</p></blockquote><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux 可执行以下命令安装yum install httpd-tools</span><br><span class="line">&#x2F;&#x2F; or</span><br><span class="line">apt-get install apache2-utils</span><br></pre></td></tr></table></figure></code></pre><h3 id="3-tcp的封包格式tcp为什么要粘包和拆包"><a class="markdownIt-Anchor" href="#3-tcp的封包格式tcp为什么要粘包和拆包"></a> <strong>3. TCP的封包格式：TCP为什么要粘包和拆包</strong></h3><hr /><blockquote><p>问题：传输层的协议为什么不选择将文件一次发送呢？</p></blockquote><pre><code>- 为了**稳定性**，一次发送的数据越多，出错的概念就越大- 为了效率，网络中有时候存在着**并行**的路径，拆分数据包就能更好的利用这些并行的路径- 发送和接收数据的时候，都存在**缓冲区**；如果随意发送很大的数据，可能导致网卡处理不过来，而导致其他应用实时性遭到破坏；- 内存最小的分配单位是**页表**，如果数据的大小超过一个页表，可能会存在页面置换问题，造成性能的损失- 传输层封包不能太大，以缓冲区大小为单位，TCP协议会将数据拆分成不超过缓冲区大小的一个个部分，每个部分都有一个独特的名词，叫做**TCP段**(TCP Segment)</code></pre><hr /><p><strong>拆包</strong>：将数据拆分成多个TCP段传输；<br /><strong>粘包</strong>：将多个数据合并成一个TCP段传输；</p><p>TCP分组格式示意图<br /><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/TCPheader.png" alt="TCPheader" /></p><ul><li><p>Source Port/Destination Port描述的是发送端口号和目标端口号，代表发送数据的应用程序和接受数据的应用程序；</p></li><li><p>Data Offset是一个偏移量，原因TCP Header部分的长度可变，需要一个数值描述数据从哪个字节开始</p></li><li><p>Reserved 是很多协议设计会保留的一个区域，用于日后扩展能力</p></li><li><p>URG…FIN标志位描述TCP段行为</p><ul><li>CWR —— Congestion Window Reduced 用于通知发送方，降低发送速率</li><li>ECE —— ECN ECHO 通知发送方收到拥塞控制</li><li>URG —— 为 1 表示高优先级数据包</li><li>ACK —— 为 1 表示确认号码字段有效</li><li>PSH —— 为 1 是带有 “PUSH” 标志的数据，指示接收方应当尽快将这个报文段交给应用层，而不用等待缓冲区装满</li><li>RST —— 为 1 表示出现严重差错，需要重置 TCP 连接</li><li>SYN —— 为 1 表示这是连接请求或者连接接受请求，用于创建连接和使序列号同步</li><li>FIN —— 为 1 表示发送方没有数据要传输了，要求释放连接</li></ul></li><li><p>Window是TCP保证稳定性并进行流量控制的工具，窗口的大小，即接收方将要接受的字节数，该字段占 16 bit，因此窗口大小最大为 65535 bytes。</p></li><li><p>Checksum是校验和，用于校验TCP段有没有损坏、丢失，其算法本质上与 IP 中的校验和算法相同。</p></li><li><p>Urgent pointer只想最后一个紧急数据的序号(Sequence Number),在 URG 设置为 1 时生效，这个指针表示紧急数据在整个流中的位置。</p></li><li><p>TCP 可选项,TCP 头中的最后一个字段是一些附加的可选项，原始规范中提供了 3 个选项，但后来的规范中，不断增加了新的选项：</p><ul><li>MSS(Maximum Segment Size): 该 TCP 协议实现的可以接收的最大 TCP 段的大小，比较典型的例子是 IPv4 中 TCP 的最大段为 1460 bytes<ul><li>如果设置过大，会导致服务器拒绝接收，或用户挤占用服务器太多资源；如果设置太小，会浪费传输资源(降低吞吐量)</li></ul></li><li>SACK(Selective Acknowledgment): 这个选项优化了数据包大量丢失并且接受者的数据窗口存在漏洞的情况。主要是因为 TCP 接收到的分组必须要能够根据其顺序组成完整的信息，丢掉其中任何一个都需要整个重传。而 SACK 就是允许 TCP 协议接收不连续的块，最后只需要重传丢失的块就可以了。</li><li>Window Scale: 窗口缩放选项，用于把窗口的大小从 65535 bytes 扩大到 1 G。具有更大的数据窗口，有利于批量的数据传输</li><li>Timestamps: TCP 时间戳，可以用这个时间戳计算每个 ACK 的 RTT，可以用来计算 TCP 重传超时</li></ul></li><li><p>Padding存在的意义是因为Option的长度不固定，需要pading对齐</p></li><li><p>紧急指针，是在 URG 设置为 1 时生效，这个指针表示紧急数据在整个流中的位置。</p></li><li><p>序列号码表示 TCP 段的窗口索引，TCP 流中的每个字节都被编号串联起来。在进行握手的阶段，会先生成一个初始序列号码，之后在此基础上递增。</p></li></ul><blockquote><p>IP协议拆分太多的封包并没意义，1）导致同个TCP段的封包被不用不同的网络线路传输，加大延迟；拆包需要消耗硬件和计算资源</p></blockquote><hr /><blockquote><p>问题：TCP如何恢复数据的顺序的？TCP拆包和粘包的作用是什么？</p></blockquote><p>TCP拆包的作用：将任务拆分处理，降低整体任务出错的概率，以及减小底层网络处理的压力，粘包过程需要保证数据经过网络的传输，又能恢复到原始的数据。</p><p>中间，<strong>需要数学提供保证顺序的理论依据</strong>，TCP利用（发送字节数、接受字节数）的唯一性来确定封包之间的顺序关系。</p><p>TCP粘包的作用：防止数据量过小导致大量的传输而将多个TCP段合并成一个发送</p><hr /><h3 id="4-tcp的稳定性滑动窗口和流速控制是怎么回事保证顺序的算法同时保证更高的吞吐量"><a class="markdownIt-Anchor" href="#4-tcp的稳定性滑动窗口和流速控制是怎么回事保证顺序的算法同时保证更高的吞吐量"></a> <strong>4. TCP的稳定性：滑动窗口和流速控制是怎么回事（保证顺序的算法，同时保证更高的吞吐量）</strong></h3><blockquote><p>TCP作为一个传输层协议，最核心的能力是传输，传输需要保证可靠性，还需要控制流速，这两个核心能力均有滑动窗口提供。[基于滑动窗口可设计分布式RPC框架，实现消息队列或分布式文件系统]</p></blockquote><p><strong>窗口大小的单位不是TCP段的数量，而是多少个字节</strong></p><p>有了窗口，发送方利用<strong>滑动窗口算法</strong>发送消息；接收方构造缓冲区接收消息，并给发送方ACK</p><p>滑动窗口时TCP协议<strong>控制可靠性的核心</strong>，发送方将数据拆包，变成多个分组，然后将数据放入一个拥有滑动窗口的数组，依次发出，仍然遵循先入先出（FIFO）的顺序，但是窗口中的分组会一次性发送。窗口中序号最小的分组如果收到ACK，窗口就会发生滑动。如果最小序号的分组长时间没有收到ACK，就会触发整个窗口的数据重新发送。</p><blockquote><p>思考：发送方有窗口，那么接收方也需要窗口吗？</p></blockquote><h3 id="5-udp协议tcp协议和udp协议的优势和劣势"><a class="markdownIt-Anchor" href="#5-udp协议tcp协议和udp协议的优势和劣势"></a> <strong>5. UDP协议：TCP协议和UDP协议的优势和劣势</strong></h3><blockquote><p>TCP和UDP是应用最广泛的传输层协议，拥有最核心的垄断地位，TCP最核心的价值保证可靠性，UDP的核心价值是灵活性</p></blockquote><p>UDP(User Datagram Protocol)，目标是在传输层提供直接发送报文（Datagram）的能力，Datagram是数据传输的最小单位，UDP协议不会帮助拆分数据，他的目标只有一个，就是发送报文</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/UDPheader.png" alt="TCPheader" /></p><table><thead><tr><th>区别</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>目的差异</td><td>提供可靠的网络传输</td><td>在提供报文交换能力基础上尽可能地简化协议轻装上阵</td></tr><tr><td>可靠性差异</td><td>在保证可靠性下提供更好的访问</td><td>只管发送数据封包</td></tr><tr><td>连接vs无链接</td><td>面向连接的协议(Connection-oriented Protocol)</td><td>无连接协议(Connection-less Protocol)</td></tr><tr><td>流控技术(Flow Control)</td><td>流控技术 在发送缓冲区中存储数据，并在接收缓冲区中接收数据</td><td>没有提供</td></tr><tr><td>传输速度</td><td></td><td>协议简化，封包小，没有连接、可靠性检查等，速度更快</td></tr><tr><td>场景差异</td><td>不适合高速数据传输场景[不适合网络游戏、视频传输]</td><td>Ping和DNSLookup只需要一次简单的请求/返回，不需要建立连接</td></tr><tr><td>-</td><td>-</td><td>-</td></tr><tr><td>传输</td><td>无损传输</td><td>传输更快</td></tr><tr><td>协议</td><td>HTTP协议更可靠</td><td>HTTP3.0协议更多从功能上出发</td></tr></tbody></table><blockquote><p>任何一个用TCP协议构造的成熟应用层协议，都可以用UDP重构</p></blockquote><p>TCP应用场景</p><ul><li>远程控制(SSH)</li><li>File Transfer Protocol(FTP)</li><li>邮件(SMTP、IMAP)等</li><li>点对点文件传出(微信等)</li></ul><p>UDP应用场景</p><ul><li>网络游戏</li><li>音视频传输</li><li>DNS</li><li>Ping</li><li>直播</li></ul><p>模糊应用场景</p><ul><li>HTTP(目前以TCP为主)</li><li>文件传输</li></ul><blockquote><p>UDP不提供可靠性，但不代表不能解决可靠性；UDP的核心价值：灵活、轻量，构造了最小版本的传输层协议；可以实现连接(可靠性)，实现会话(Session),实现可靠性(Reliability)…</p></blockquote><blockquote><p>总结：TCP比较严谨(序号的设计、滑动窗口的设计、快速重发的设计、内在状态机制的设计)，而UDP更加简单专注，<strong>报文传输</strong>，<strong>可靠性</strong>，<strong>流量控制</strong>，<strong>连接和会话</strong></p><p>问题解析：TCP最核心的价值就是提供封装好的一套解决可靠性的优秀方案；TCP在确保吞吐量、延迟、丢包率的基础上，保证可靠性；UDP提供了最小版本的实现，支持Checksum,UDP最核心的价值：轻量、灵活、传输速度快</p></blockquote><blockquote><p>问题：Moba类游戏的网络应用应该用TCP还是UDP?</p></blockquote><p><strong>内存状态在同时刻只能有一个状态，所以多线程的操作必须有先后</strong></p><p>对于游戏，在线竞技游戏，每个事件(英雄放大招)，游戏服务器必须给一个唯一的时序编号。服务器要尽快响应多个客户单提交的事件，并以最快的速度分配自增序号，然后返回给客户端。</p><p>所以moba</p><h2 id="网络层协议局域网和ip协议"><a class="markdownIt-Anchor" href="#网络层协议局域网和ip协议"></a> 网络层协议(局域网和IP协议)</h2><h3 id="6-ipv4协议路由和寻址的区别"><a class="markdownIt-Anchor" href="#6-ipv4协议路由和寻址的区别"></a> <strong>6. IPv4协议：路由和寻址的区别</strong></h3><blockquote><p>问题回答：<strong>寻址</strong>（Addressing）就是通过地址找到设备；<strong>路由</strong>（Routing）本质是路径的选择。就好像知道地址，但是到了每个十字路口，还需要选择具体的路径。因此，路由和寻址，是相辅相成的关系。</p></blockquote><p><strong>IP 协议</strong>（Internet Protocol）是一个处于垄断地位的网络层协议。IPv4 就是 IP 协议的第 4 个版本，是目前互联网的主要网络层协议。IP协议需要底的数据链路层的支持。IP 协议并不负责数据的可靠性，可靠性是 IP 协议上方的 Host-To-Host 协议（即传输层协议）保证的。</p><p>IP 协议接收 IP 协议上方的 Host-To-Host 协议（即传输层协议）传来的数据，然后进行拆分，这个能力叫做<strong>分片</strong>（Fragmentation）；然后 IP 协议为每个分片增加一个 IP 头（Header），组成一个 IP 封包（Datagram）；之后，IP 协议调用底层的局域网（数据链路层）传送数据。最后 IP 协议通过寻址和路由能力最终把封包送达目的地。</p><p>IP协议存在的问题：</p><ul><li><strong>封包损坏</strong>：数据传输过程中损坏</li><li><strong>丢包</strong>：数据发送中丢失</li><li><strong>重发</strong>：数据被重发，比如中间设备通过2个路径传递数据</li><li><strong>乱序</strong>：到达目的地时数据和发送数据不一致</li></ul><p>IP协议的工作原理</p><ol><li>分片：是把数据切分成片，IP协议通过它下层的局域网(链路层)协议传输数据，因此需要适配底层网络的传输能力</li><li>增加协议头，如下图：<br /><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/IPheader.png" alt="IPheader" /></li></ol><ul><li>IHL描述协议头大小</li><li>Type Of Service为了在延迟、吞吐量和丢包率做出选择</li><li>time to time描述封包存活时间</li><li>Protocol 上层协议，TCP=7,UDP=17</li></ul><p>描述网络的三个指标：</p><ul><li><strong>延迟</strong>（Latency）：1bit 的数据从网络的一个终端传送到另一个终端需要的时间；</li><li><strong>吞吐量</strong>（Throughput）：单位时间内可以传输的平均数据量,单位：bps=bit/s；</li><li><strong>丢包率</strong>（Packet loss）：丢包率指的发送出去的封包没有达到目的地的比率；</li></ul><p>IPv4地址是4个8位(Octet)排列而成，总共可以编址43亿个地址。</p><table><thead><tr><th>IP:</th><th>103</th><th>16</th><th>3</th><th>1</th></tr></thead><tbody><tr><td>Octet:</td><td>01100111</td><td>00010000</td><td>00000011</td><td>00010001</td></tr></tbody></table><p>寻址步骤：</p><ul><li>找到顶层网络，例如103.16.3.1最顶层的网络号可以和255.0.0.0(子网掩码)做<strong>位与运算</strong>得到<code>103.16.3.1&amp;255.0.0.0=103.0.0.0</code></li><li>找到下一层网络，就需要IP地址和下一级的子网掩码做位与运算<code>103.16.3.1&amp;255.255.0.0=103.16.0.0</code></li><li>找到再下一级网络，就需要IP地址和下一级的子网掩码做位与运算<code>103.16.3.1&amp;255.255.255.0=103.16.3.0</code></li><li>定位设备，设备就是子网103.16.3.0中，最终找到设备号是1</li></ul><p>在寻址过程中，数据总存在于某个局域网内，如果目的地在局域网中，可以直接定位到设备，如果目的不在局域网中，就需要去往其他网络。由于网络与网络之间是网关在连接，如果目的地的IP地址不在局域网中，就需要被IP封包，选择通往下一个网络的路径，其实就是选择下一个网关。如果一个网络和多个网络接壤，就会存在多个网关。例如：路由器为ip 14.215.117.38寻址，路由所在的编号为16.0.0.0，就需要知道去往14.0.0.0网络的gateway地址，如果用route查看路由表可以看到<code>Destination:14.0.0.0 Gateway:16.12.1.100 Mask 255.0.0.0 Iface:16.12.1.1</code> 14.215.117.38先要和mask进行位与运算，然后进行查表看到14.0.0.0得知去的网卡是16.12.1.1</p><hr /><blockquote><p>思考：127.0.0.1,localhost,0.0.0.0有什么不同？<br />127.0.0.1是本地回环地址（loopback），发送到 loopback 的数据会被转发到本地应用。</p></blockquote><p>localhost 指代的是本地计算机，用于访问绑定在 loopback 上的服务。localhost 是一个主机名，不仅仅可以指向 IPv4 的本地回环地址，也可以指向 IPv6 的本地回环地址 [::1]。</p><p>0.0.0.0是一个特殊目的 IP 地址，称作不可路由 IP 地址，它的用途会被特殊规定。通常情况下，当我们把一个服务绑定到0.0.0.0，相当于把服务绑定到任意的 IP 地址。比如一台服务器上有多个网卡，不同网卡连接不同的网络，如果服务绑定到 0.0.0.0 就可以保证服务在多个 IP 地址上都可以用。</p><hr /><blockquote><p><strong>子网掩码的作用就是帮忙找到对应的子网</strong></p></blockquote><h3 id="7-ipv6协议tunnel技术是什么"><a class="markdownIt-Anchor" href="#7-ipv6协议tunnel技术是什么"></a> <strong>7. IPv6协议：Tunnel技术是什么</strong></h3><p>IPv4 用 32 位整数描述地址，最多只能支持 43 亿设备，显然是不够用的，这也被称作 IP 地址耗尽问题。</p><p>为了解决这个问题，有一种可行的方法是拆分子网。<strong>拆分子网</strong>，会带来很多问题，比如说<strong>内外网数据交互，需要网络地址转换协议（NAT 协议），增加传输成本</strong>。再比如说，<strong>多级网络会增加数据的路由和传输链路，降低网络的速度</strong>。理想的状态当然是所有设备在一个网络中，互相可以通过地址访问。</p><p>为了解决这个问题，1998 年互联网工程工作小组推出了全新款的 IP 协议——IPv6 协议。但是目前 IPv6 的普及程度还不够高.</p><p>既然不能做到完全普及，也就引出了关联的一道面试题目：什么是 Tunnel 技术？</p><p>IPv6 的工作原理和 IPv4 类似，分成<strong>切片（Segmentation）</strong>、<strong>增加封包头</strong>、<strong>路由（寻址）</strong> 这样几个阶段去工作。</p><p>IPv6 同样接收上方主机到主机（Host-to-Host）协议传递来的数据，比如一个 TCP 段（Segment），然后将 TCP 段再次切片做成一个个的 IPv6 封包（Datagram or Packet），再调用底层局域网能力（数据链路层）传输数据。</p><p>具体的过程如下图所示：</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/datatrans.png" alt="datatrans" /></p><table><thead><tr><th>区别</th><th>IPv4</th><th>IPv6</th></tr></thead><tbody><tr><td>位数</td><td>4个8位(octeat)，共32位</td><td>8个16位(hextet),共128位</td></tr><tr><td>分割</td><td>用.分割，如103.28.7.35</td><td>用:分割，如0123:4567:89ab:cdef:0123:4567:89ab:cde</td></tr></tbody></table><p>IPv6 的寻址，和 IPv4 相同，寻址的目的是找到设备，以及规划到设备途经的路径。与IPv4 相同，IPv6寻址最核心的内容就是要对网络进行划分。IPv6 地址很充裕，因此对网络的划分和 IPv4 有很显著的差异。</p><p>IPv6 的寻址分类包括：<strong>全局单播寻址</strong>、 <strong>本地单播</strong>、<strong>分组多播</strong>、<strong>任意播</strong></p><p><strong>全局单播寻址</strong>：就是将消息从一个设备传到另一个设备，目标就是定位网络中的设备（和 IPv4 地址作用差不多，在互联网中通过地址查找一个设备，简单来说，单播就是 1 对 1）只不过格式略有差异。总的来说，IPv6 地址太多，因此不再需要子网掩码，而是直接将 IPv6 的地址分区即可；在实现全局单播时，IPv6 地址通常分成 3 个部分：</p><ul><li><strong>站点前缀</strong>（Site Prefix）48bit，一般是由 ISP（Internet Service Providor，运营商）或者RIR（Regional Internet Registry， 地区性互联网注册机构），RIR 将 IP 地址分配给运营商；</li><li><strong>子网号</strong>（Subnet ID），16bit，用于站点内部区分子网；</li><li><strong>接口号</strong>（Interface ID）， 64bit，用于站点内部区分设备</li></ul><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/IPv6addressing.png" alt="IPv6addressing" /></p><blockquote><p>因此 IPv6 也是一个树状结构，站点前缀需要一定资质，子网号和接口号内部定义。IPv6 的寻址过程就是先通过站点前缀找到站点，然后追踪子网，再找到接口（也就是设备的网卡）。</p></blockquote><p><strong>本地单播</strong>（类似 IPv4 里的一个内部网络，要求地址必须以fe80开头，类似我们 IPv4 中127开头的地址）；理论上，虽然 IPv6 可以将所有的设备都连入一个网络。但在实际场景中，很多公司还是需要一个内部网络的。这种情况在 IPv6 的设计中属于局域网络。</p><p>在局域网络中，实现设备到设备的通信，就是本地单播。IPv6 的本地单播地址组成如下图所示：<br /><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/ipv6local.png" alt="IPv6addressing" /></p><blockquote><p>这种协议比较简单，本地单播地址必须以fe80开头，后面 64 位的 0，然后接上 54 位的设备编号。上图中的 Interface 可以理解成网络接口，其实就是网卡</p></blockquote><p><strong>分组多播</strong>（Group Multicast），类似今天我们说的广播，将消息发送给多个接收者；有时候，我们需要实现广播。所谓广播，就是将消息同时发送给多个接收者。<strong>IPv6 中设计了分组多播，来实现广播的能力。当 IP 地址以 8 个 1 开头，也就是ff00开头，后面会跟上一个分组的编号时，就是在进行分组多播</strong>。这个时候，我们需要一个广播设备，在这个设备中已经定义了这些分组编号，并且拥有分组下所有设备的清单，这个广播设备会帮助我们将消息发送给对应分组下的所有设备。</p><p><strong>任意播</strong>（Anycast），，本质是将消息发送给多个接收方，并选择一条最优的路径。这样说有点抽象，比如说在一个网络中有多个授时服务，这些授时服务都共享了一个任播地址。当一个客户端想要获取时间，就可以将请求发送到这个任播地址。客户端的请求扩散出去后，可能会找到授时服务中的一个或者多个，但是距离最近的往往会先被发现。这个时候，客户端就使用它第一次收到的授时信息修正自己的时间。</p><p>IPv6 和 IPv4 的兼容：目前 IPv6 还没有完全普及，大部分知名的网站都是同时支持 IPv6 和 IPv4。这个时候我们可以分成 2 种情况讨论：</p><ul><li>一个 IPv4 的网络和一个 IPv6 的网络通信；<ol><li>客户端通过 DNS64 服务器查询 AAAA 记录。DNS64 是国际互联网工程任务组（IETF）提供的一种解决 IPv4 和 IPv6 兼容问题的 DNS 服务。这个 DNS 查询服务会把 IPv4 地址和 IPv6 地址同时返回。</li><li>DNS64 服务器返回含 IPv4 地址的 AAAA 记录。</li><li>客户端将对应的 IPv4 地址请求发送给一个 NAT64 路由器</li><li>由这个 NAT64 路由器将 IPv6 地址转换为 IPv4 地址，从而访问 IPv4 网络，并收集结果。</li><li>消息返回到客户端。</li></ol></li><li>一个 IPv6 的网络和一个 IPv6 的网络通信，但是中间需要经过一个 IPv4 的网络<ul><li>这种情况在普及 IPv6 的过程中比较常见，IPv6 的网络一开始是一个个孤岛，IPv6 网络需要通信，就需要一些特别的手段。</li><li><strong>隧道的本质就是在两个 IPv6 的网络出口网关处，实现一段地址转换的程序</strong>。</li></ul></li></ul><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/ip64_1.png" alt="IPv64" /></p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/ip64_2.png" alt="IPv64" /></p><blockquote><p>总结： IPv6 解决的是地址耗尽的问题。因为解决了地址耗尽的问题，所以很多其他问题也得到了解决，比如说减少了子网，更小的封包头部体积，最终提升了性能等。</p></blockquote><hr /><blockquote><p>问题：Tunnel 技术是什么</p></blockquote><p>Tunnel 就是隧道，这和现实中的隧道是很相似的。隧道不是只有一辆车通过，而是每天都有大量的车辆来来往往。两个网络，用隧道连接，位于两个网络中的设备通信，都可以使用这个隧道。<strong>隧道是两个网络间用程序定义的一种通道</strong>。具体来说，如果两个 IPv6 网络被 IPv4 分隔开，那么两个 IPv6 网络的出口处（和 IPv4 网络的网关处）就可以用程序（或硬件）实现一个隧道，方便两个网络中设备的通信。</p><hr /><blockquote><p>IPv6 和 IPv4 究竟有哪些区别</p></blockquote><p>IPv6 和 IPv4 最核心的区别是地址空间大小不同。IPv6 用 128 位地址，解决了 IP 地址耗尽问题。因为地址空间大小不同，它们对地址的定义，对路由寻址策略都有显著的差异。</p><p>在路由寻址策略上，IPv6 消除了设备间地址冲突的问题，改变了划分子网的方式。在 IPv4 网络中，一个局域网往往会共享一个公网 IP，因此需要 NAT 协议和外网连接。</p><p>在划分子网的时候，IPv4 地址少，需要子网掩码来处理划分子网。IPv6 有充足的地址，因此不需要局域网共享外网 IP。也正因为 IPv6 地址多，可以直接将 IPv6 地址划分成站点、子网、设备，每个段都有充足的 IP 地址。</p><p>因为 IPv6 支持的 IP 地址数量大大上升，一个子网可以有 248 个 IP 地址，这个子网可能是公司网络、家庭网络等。这样 IP 地址的分配方式也发生了变化，IPv4 网络中设备分配 IP 地址的方式是中心化的，由 DHCP（动态主机协议）为局域网中的设备分配 IP 地址。而在 IPv6 网络中，因为 IP 地址很少发生冲突，可以由设备自己申请自己的 IP 地址。</p><p>另外因为 IPv6 中任何一个节点都可以是一个组播节点，这样就可以构造一个对等的网络，也就是可以支持在没有中心化的路由器，或者一个网络多个路由器的情况下工作。节点可以通过向周围节点类似打探消息的方式，发现更多的节点。这是一个配套 IPv6 的能力，叫作邻居发现（ND）。</p><hr /><h3 id="8-局域网nat是如何工作的"><a class="markdownIt-Anchor" href="#8-局域网nat是如何工作的"></a> <strong>8. 局域网：NAT是如何工作的</strong></h3><p>广域网是由很多的局域网组成的，比如公司网络、家庭网络、校园网络等。之前我们一直在讨论广域网的设计，今天我们到微观层面，看看局域网是如何工作的。</p><p>IPv4 的地址不够，因此需要设计子网。当一个公司申请得到一个公网 IP 后，会在自己的公司内部设计一个局域网。这个局域网所有设备的 IP 地址，通常会以 192.168 开头。</p><p>假设小明，上班时间玩王者荣耀。当他用 UDP 协议向王者荣耀的服务器发送信息时，消息的源 IP 地址是一个内网 IP 地址，而王者荣耀的服务，是一个外网 IP 地址。</p><p>数据到王者荣耀服务器可以通过寻址和路由找到目的地，但是数据从王者荣耀服务器回来的时候，王者荣耀服务器如何知道192.168开头的地址应该如何寻址呢？</p><p>要想回答这个问题，就涉及网络地址转换协议（NAT 协议）。</p><hr /><p><strong>内部网络和外部网络</strong><br />对一个组织、机构、家庭来说，我们通常把内部网络称为局域网，外部网络就叫作外网。下图是一个公司多个部门的网络架构。</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/companynetwork.png" alt="companynetwork" /></p><p>我们会看到外网通过路由器接入整个公司的局域网，和路由器关联的是三台交换机，代表公司的三个部门。交换机，或者称为链路层交换机，通常工作在链路层；而路由器通常也具有交换机的能力，工作在网络层和链路层。</p><p>光纤是一种透明的导光介质，多束光可以在一个介质中并行传播，不仅信号容量大，重量轻，并行度高而且传播距离远。当然，光纤不能弯曲，因此办公室里用来连接交换机和个人电脑的线路肯定不能是光纤，光线通常都用于主干网络。</p><hr /><p><strong>局域网数据交换</strong>（MAC 地址）同一个局域网中的设备如何交换消息。</p><p>首先，先明确一个概念，<code>设备间通信的本质</code>其实是<strong>设备拥有的网络接口（网卡）间的通信</strong>。为了区别每个网络接口，互联网工程任务组（IETF）要求每个<strong>设备拥有一个唯一的编号</strong>，这个就是 <strong>MAC 地址</strong>。</p><p>IP 地址不也是唯一的吗？其实不然，一旦设备更换位置，比如你把你的电脑从北京邮寄的广州，那么 <strong>IP 地址就变了，而电脑网卡的 MAC 地址不会发生变化</strong>。总的来说，IP 地址更像现实生活中的地址，而 MAC 地址更像你的身份证号。</p><p>然后，再明确另一个基本的概念。<strong>在一个局域网中，我们不可以将消息从一个接口（网卡）发送到另一个接口（网卡），而是要通过交换机</strong>。为什么是这样呢？因为两个网卡间没有线啊！所以<strong>数据交换，必须经过<code>交换机</code>，因为线路都是由网卡连接交换机的</strong>。</p><blockquote><p>总结：数据的发送方，将自己的 <strong>MAC 地址</strong>、<strong>目的地 MAC 地址</strong>，以及<strong>数据</strong>作为一个 <strong><code>分组</code></strong>（Packet），也称作 <strong>Frame</strong> 或者<strong>封包</strong>，发送给交换机。交换机再根据目的地 MAC 地址，将数据转发到目的地的网络接口（网卡）。</p></blockquote><p>最后一个问题，这个分组或者 Frame，是不是 IP 协议的分组呢？不是，这里提到的是链路层的数据交换，它支持 IP 协议工作，是网络层的底层。所以，如果 <strong>IP 协议要传输数据，就要将数据转换成为链路层的分组，然后才可以在链路层传输</strong>。</p><p><strong>链路层分组大小</strong>受限于链路层的网络设备、线路以及使用了链路层协议的设计。你有时候可能会看到 <strong>MTU 这个缩写词，它指的是 Maximun Transmission Unit，<code>最大传输单元</code>，意思是链路层网络允许的最大传输数据分组的大小。<code>因此IP 协议要根据 MTU 拆分封包</code></strong>。</p><p>介绍 TCP 协议滑动窗口的时候，还提到过一个词，叫作 <strong>MSS</strong>，这里我们复习下,MSS（Maximun Segment Size，最大段大小）是 TCP 段，或者称为 TCP 分组（TCP Packet）的最大大小。<strong>MSS 是传输层概念，MTU 是链路层概念</strong>，因此，它们的关系如下是对的吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MTU &#x3D; MSS + TCP Header + IP Header</span><br></pre></td></tr></table></figure><p>这个思路有一定道理，但是不对。先说说这个思路怎么来的，你可能会这么思考：TCP 传输数据大于 MSS，就拆包。每个封包加上 TCP Header ，之后经过 IP 协议，再加上 IP Header。于是这个加上 IP 头的分组（Packet）不能超过 MTU。固然这个思路很有道理，可惜是错的。<strong>因为 TCP 解决的是广域网的问题，MTU 是一个链路层的概念，要知道不同网络 MTU 是不同的，所以二者不可能产生关联。这也是为什么 IP 协议还可能会再拆包的原因。</strong></p><hr /><p><strong>地址解析协议（ARP）</strong></p><p>链路层通过 MAC 地址定位网络接口（网卡）。在一个网络接口向另一个网络接口发送数据的时候，至少要提供这样 3 个字段：</p><ol><li>源 MAC 地址</li><li>目标 MAC 地址</li><li>数据</li></ol><p>这里我就要思考一个问题，<strong>对于一个网络接口，它如何能知道目标接口的 MAC 地址呢？</strong> 我们在使用传输层协议的时候，清楚地知道目的地的 IP 地址，但是我们不知道 MAC 地址。这个时候，<strong>就需要一个中间服务帮助根据 IP 地址找到 MAC 地址——这就是<code>地址解析协议</code>（Address Resolution Protocol，ARP）</strong>。</p><p>整个工作过程和 DNS 非常类似，<strong>如果一个网络接口已经知道目标 IP 地址对应的 MAC 地址了，它会将数据直接发送给交换机，交换机将数据转发给目的地</strong>，这个过程如下图所示：</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/ARP1.png" alt="companynetwork" /></p><p>如果网络接口不知道目的地地址呢？这个时候，地址解析协议就开始工作了。<strong>发送接口会发送一个广播查询给到交换机，交换机将查询转发给所有接口。</strong></p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/ARP2.png" alt="companynetwork" /></p><p><strong>如果某个接口发现自己就是对方要查询的接口，则会将自己的 MAC 地址回传。接下来，会在交换机和发送接口的 ARP 表中，增加一个缓存条目</strong>。也就是说，接下来发送接口再次向 IP 地址 2.2.2.2 发送数据时，不需要再广播一次查询了。</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/ARP3.png" alt="companynetwork" /></p><p>前面提到这个过程和 DNS 非常相似，采用的是逐级缓存的设计减少 ARP 请求。发送接口先查询本地的 ARP 表，如果本地没有数据，然后广播 ARP 查询。这个时候如果交换机中有数据，那么查询交换机的 ARP 表；如果交换机中没有数据，才去广播消息给其他接口。注意，<strong>ARP 表是一种缓存，也要考虑缓存的设计</strong>。通常缓存的设计要考虑缓存的</p><ul><li><strong>失效时间(Time to Live)</strong>，为每个缓存条目增加一个失效时间</li><li><strong>更新策略</strong>，可以考虑利用 <strong>老化(Aging)算法</strong> 模拟LRU</li><li><strong>数据结构</strong>等</li></ul><p>最后请你思考路由器和交换机的异同点。不知道你有没有在网上订购过家用无线路由器，通常这种家用设备也会提供局域网，具备交换机的能力。同时，这种设备又具有路由器的能力。所以，很多同学可能会分不清路由器和交换机。</p><p>总的来说，家用的路由器，也具备交换机的功能。但是当 ARP 表很大的时候，就需要专门的、能够承载大量网络接口的交换设备。就好比，如果用数组实现 ARP 表，数据量小的时候，遍历即可；但如果数据量大的话，就需要设计更高效的查询结构和设计缓存【重学操作系统：存储器分级：L1 Cache比内存和SSD快多少倍；内存管理单元：什么情况下使用大内存分页；缓存置换算法：LRU用什么数据结构实现更合理】。</p><hr /><p><strong>连接内网</strong>，有时候，公司内部有多个子网。<strong>这个时候一个子网如果要访问另一个子网，就需要通过路由器</strong>。也就是说，图中的路由器，其实充当了两个子网通信的桥梁。在上述过程中，发送接口不能直接通过 MAC 地址发送数据到接收接口，因为子网 1 的交换机不知道子网 2 的接口。这个时候，<strong>发送接口需要通过 IP 协议，将数据发送到路由器，再由路由器转发信息到子网 2 的交换机</strong>。这里提一个问题，<strong>子网 2 的交换机如何根据 IP 地址找到接收接口呢？答案是通过查询 ARP 表</strong>。</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/intranet_connection.png" alt="innet_connection" /></p><hr /><p><strong>连接外网（网络地址转换技术，NAT）</strong>，IPv4 协议因为存在网络地址耗尽的问题，不能为一个公司提供足够的地址，因此内网 IP 可能会和外网重复。比如内网 IP 地址192.168.0.1发送信息给22.22.22.22，这个时候，其实是跨着网络的。</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/outernet_connection.png" alt="outernet_connection" /></p><p>跨网络必然会通过多次路由，最终将消息转发到目的地。但是这里存在一个问题，寻找的目标 IP 地址22.22.22.22是一个公网 IP，可以通过正常的寻址 + 路由算法定位。当22.22.22.22寻找192.168.0.1的时候，是寻找一个私网 IP，这个时候是找不到的。解决方案就是<strong>网络地址转换技术（Network Address Translation）</strong>。</p><p><strong>NAT 技术转换的是 IP 地址，私有 IP 通过 NAT 转换为公网 IP 发送到服务器</strong>。服务器的响应，通过 NAT 转换为私有 IP，返回给客户端。通过这种方式，就解决了内网和外网的通信问题。</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/NAT.png" alt="NAT" /></p><blockquote><p>总结：<strong>链路层发送数据靠的是 MAC 地址</strong>，MAC 地址就好像人的身份证一样。局域网中，数据不可能从一个终端直达另一个终端，而是必须经过交换机交换。</p><p><strong>交换机也叫作链路层交换机，它的工作就是不断接收数据，然后转发数据</strong>。通常意义上，<strong>交换机不具有路由功能，路由器往往具有交换功能。但是往往路由器交换的效率，不如交换机。</strong></p><p>已知 <strong>IP 地址，找到 MAC 地址的协议，叫作地址解析协议（ARP）</strong>。</p><p><strong>网络和网络的衔接，必须有路由器（或者等价的设备）</strong>。一个网络的设备不能直接发送链路层分组给另一个网络的设备，而是需要通过 IP 协议让路由器转发。</p></blockquote><hr /><blockquote><p>问题： 网络地址转换协议是如何工作的？</p></blockquote><ul><li>网络地址解析协议（NAT）解决的是内外网通信的问题。</li><li>NAT 通常发生在内网和外网衔接的路由器中，由路由器中的 NAT 模块提供网络地址转换能力。</li></ul><p>从设计上看，<code>NAT 最核心的能力，就是能够将内网中某个 IP 地址映射到外网 IP，然后再把数据发送给外网的服务器</code>。当服务器返回数据的时候，NAT 又能够准确地判断外网服务器的数据返回给哪个内网 IP。</p><p>NAT 是能做到上面这一点，需要做两件事:</p><ul><li><strong>NAT 需要作为一个中间层替换 IP 地址</strong>。 发送的时候，NAT 替换源 IP 地址（也就是将内网 IP 替换为出口 IP）；接收的时候，NAT 替换目标 IP 地址（也就是将出口 IP 替换回内网 IP 地址）。</li><li><strong>NAT 需要缓存内网 IP 地址和出口 IP 地址 + 端口的对应关系</strong>。也就是说，发送的时候，NAT 要为每个替换的内网 IP 地址分配不同的端口，确保出口 IP 地址+ 端口的唯一性，这样当服务器返回数据的时候，就可以根据出口 IP 地址 + 端口找到内网 IP。</li></ul><hr /><p>IPv6 协议还需要 NAT 吗？</p><ul><li>IPv6 解决了 IP 耗尽的问题，为机构、组织、公司、家庭等网络提供了充足的 IP 资源，从这个角度看是不是就不需要 NAT 协议了呢？</li><li>在没有 IPv6 之前，NAT 是 IP 资源耗尽的主流解决方案。在一个内网中的全部设备通过 NAT 协议共 享一个外网的 IPv4 地址，是目前内外网对接的主要方式。IPv6 地址资源充足，可以给全球每个设备一个独立的地址。从这个角度看 IPv6 的确不需要 NAT 协议。</li><li>但是目前的情况，是 IPv6 网络还没有完全普及。尽管很多公司已经支持自己的互联网产品可以使用 IPv6 访问，但是公司内部员工使用的内部网络还是 IPv4。如果要连接 IPv6 和 IPv4 网络，仍然需要 NAT 协议（NAT64），这个协议可以让多个 IPv6 的设备共享一个 IPv4 的公网地址。</li></ul><h3 id="9-tcp实战如何进行tcp抓包调试略"><a class="markdownIt-Anchor" href="#9-tcp实战如何进行tcp抓包调试略"></a> <strong>9. TCP实战：如何进行TCP抓包调试[略]</strong></h3><h2 id="网络编程"><a class="markdownIt-Anchor" href="#网络编程"></a> 网络编程</h2><ul><li>围绕Socket讨论网络编程</li><li>各种网络I/O模型和编程方式的优缺点</li><li>以RPC框架设计为题落地学到的知识和实现</li></ul><p>做网络编程的时候都会碰到 Socket 对象 ，或者在配置代理的时候， 碰到配置 Socket 地址。 还经常会碰到 I/O 模型、异步编程、内存映射等概念。再往更深层次学习， 还会碰到 epoll/select 等编程模型。</p><p>有没有一种一团糟的感觉——其实学习好这些知识有一条主线，就是抓住操作系统对 Socket 文件的设计。</p><h3 id="10-socket编程epoll为什么用红黑树"><a class="markdownIt-Anchor" href="#10-socket编程epoll为什么用红黑树"></a> <strong>10. Socket编程：epoll为什么用红黑树</strong></h3><p><strong>Socket 是一种编程的模型</strong>。</p><p>下图中，从编程的角度来看，客户端将数据发送给在客户端侧的Socket 对象，然后客户端侧的 Socket 对象将数据发送给服务端侧的 Socket 对象。</p><p>Socket 对象负责提供通信能力，并处理底层的 TCP 连接/UDP 连接。</p><p>对服务端而言，每一个客户端接入，就会形成一个和客户端对应的 Socket 对象，如果服务器要读取客户端发送的信息，或者向客户端发送信息，就需要通过这个客户端 Socket 对象。</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/socket.png" alt="socket" /></p><p>但是如果从另一个角度去分析，<strong>Socket 还是一种文件，准确来说是一种双向管道文件</strong>。</p><p><strong>管道文件</strong>: 管道会将一个程序的输出，导向另一个程序的输入<br /><strong>双向管道文件呢</strong>：双向管道文件连接的程序是对等的，都可以作为输入和输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">80</span>));</span><br></pre></td></tr></table></figure><p>上面代码，创建的是一个服务端 Socket 对象，但如果单纯看这个对象，它又代表什么呢？如果我们理解成代表服务端本身合不合理呢——这可能会比较抽象，在服务端存在一个服务端 Socket。但如果我们从管道文件的层面去理解它，就会比较容易了。<strong>其一，这是一个文件；其二，它里面存的是所有客户端 Socket 文件的文件描述符。</strong></p><p>当一个客户端连接到服务端的时候，操作系统就会创建一个客户端 Socket 的文件。然后操作系统将这个文件的文件描述符写入服务端程序创建的服务端 Socket 文件中。服务端 Socket 文件，是一个管道文件。如果读取这个文件的内容，就相当于从管道中取走了一个客户端文件描述符</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/socket1.png" alt="socket1" /></p><p>如上图所示，服务端 Socket 文件相当于一个客户端 Socket 的目录，线程可以通过 accept() 操作每次拿走一个客户端文件描述符。拿到客户端文件描述符，就相当于拿到了和客户端进行通信的接口。</p><p>前面我们提到 Socket 是一个双向的管道文件，当线程想要读取客户端传输来的数据时，就从客户端 Socket 文件中读取数据；当线程想要发送数据到客户端时，就向客户端 Socket 文件中写入数据。<strong>客户端 Socket 是一个双向管道，操作系统将客户端传来的数据写入这个管道，也将线程写入管道的数据发送到客户端。</strong></p><p>总结下，Socket 首先是文件，存储的是数据。</p><p>对服务端而言，分成服务端 Socket 文件和客户端 Socket 文件。</p><ul><li>服务端 Socket 文件存储的是客户端 Socket 文件描述符；</li><li>客户端 Socket 文件存储的是传输的数据。</li></ul><p>读取客户端 Socket 文件，就是读取客户端发送来的数据；写入客户端文件，就是向客户端发送数据。对一个客户端而言， Socket 文件存储的是发送给服务端（或接收的）数据。</p><p>综上，Socket 首先是文件，在文件的基础上，又封装了一段程序，这段程序提供了 API 负责最终的数据传输。</p><hr /><p><strong>服务端 Socket 的绑定</strong></p><ul><li>Nginx监听80端口</li><li>Node监听3000端口</li><li>SSH监听22端口</li><li>Tomcat监听8080端口</li></ul><p>对于一个服务端 Socket 文件，我们要设置它监听的端口。比如 Nginx 监听 80 端口、Node 监听 3000 端口、SSH 监听 22 端口、Tomcat 监听 8080 端口。端口监听不能冲突，不然客户端连接进来创建客户端 Socket 文件，文件描述符就不知道写入哪个服务端 Socket 文件了。</p><p>这样操作系统就会把连接到不同端口的客户端分类，将客户端 Socket 文件描述符存到对应不同端口的服务端 Socket 文件中。</p><p>因此，<strong>服务端监听端口的本质</strong>，是将服务端 Socket 文件和端口绑定，这个操作也称为 <strong>bind</strong>。有时候我们不仅仅绑定端口，还需要绑定 IP 地址。这是因为有时候我们只想允许指定 IP 访问我们的服务端程序。</p><hr /><p>扫描和监听</p><p>对于一个服务端程序，可以定期扫描服务端 Socket 文件的变更，来了解有哪些客户端想要连接进来。如果在服务端 Socket 文件中读取到一个客户端的文件描述符，就可以将这个文件描述符实例化成一个 Socket 对象。</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/socket2.png" alt="socket2" /></p><p>之后，服务端可以将这个 Socket 对象加入一个容器（集合），通过定期遍历所有的客户端 Socket 对象，查看背后 Socket 文件的状态，从而确定是否有新的数据从客户端传输过来。</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/socket3.png" alt="socket3" /></p><p>上述的过程，我们通过一个线程就可以响应多个客户端的连接，也被称作<strong>I/O 多路复用技术</strong>。</p><hr /><p><strong>响应式（Reactive）</strong><br />在 I/O 多路复用技术中，服务端程序（线程）需要维护一个 Socket 的集合（可以是数组、链表等），然后定期遍历这个集合。这样的做法在客户端 Socket 较少的情况下没有问题，但是如果接入的客户端 Socket 较多，比如达到上万，那么每次轮询的开销都会很大。</p><p>从程序设计的角度来看，像这样主动遍历，比如遍历一个 Socket 集合看看有没有发生写入（有数据从网卡传过来），称为命令式的程序。这样的程序设计就好像在执行一条条命令一样，程序主动地去查看每个 Socket 的状态。</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/socket_reactive.png" alt="socket_reactive" /></p><p><strong>命令式会让负责下命令的程序负载过重</strong>，例如，在高并发场景下，上述讨论中循环遍历 Socket 集合的线程，会因为负担过重导致系统吞吐量下降。</p><p>与<strong>命令式相反的是响应式（Reactive）</strong>，响应式的程序就不会有这样的问题。在响应式的程序当中，每一个参与者有着独立的思考方式，就好像拥有独立的人格，可以自己针对不同的环境触发不同的行为。</p><p>从响应式的角度去看 Socket 编程，应该是有某个观察者会观察到 Socket 文件状态的变化，从而通知处理线程响应。线程不再需要遍历 Socket 集合，而是等待观察程序的通知。</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/socket_reactive2.png" alt="socket_reactive2" /></p><p><strong>最合适的观察者其实是操作系统本身</strong>，只有操作系统非常清楚每一个 Socket 文件的状态。原因是对 Socket 文件的读写都要经过操作系统。在实现这个模型的时候，有几件事情要注意。</p><ul><li>线程需要告诉中间的观察者自己要观察什么，或者说在什么情况下才响应？比如具体到哪个 Socket 发生了什么事件？是读写还是其他的事件？这一步我们通常称为注册。</li><li>中间的观察者需要实现一个高效的数据结构（通常是基于红黑树的二叉搜索树）。这是因为中间的观察者不仅仅是服务于某个线程，而是服务于很多的线程。当一个 Socket 文件发生变化的时候，中间观察者需要立刻知道，究竟是哪个线程需要这个信息，而不是将所有的线程都遍历一遍</li></ul><hr /><blockquote><p>问题：为什么用红黑树？</p></blockquote><p>关于为什么要红黑树， 再仔细解释一下。考虑到中间观察者最核心的诉求有两个。</p><ul><li>第一个核心诉求，是让线程可以注册自己关心的消息类型。</li></ul><p>比如线程对文件描述符 =123 的 Socket 文件读写都感兴趣，会去中间观察者处注册。当 FD=123 的 Socket 发生读写时，中间观察者负责通知线程，这是一个响应式的模型。</p><ul><li>第二个核心诉求，是当 FD=123 的 Socket 发生变化（读写等）时，能够快速地判断是哪个线程需要知道这个消息</li></ul><p>所以，中间观察者需要一个快速能插入（注册过程）、查询（通知过程）一个整数的数据结构，这个整数就是 Socket 的文件描述符。综合来看，能够解决这个问题的数据结构中，跳表和二叉搜索树都是不错的选择。</p><p>因此，在 Linux 的 epoll 模型中，选择了红黑树。红黑树是二叉搜索树的一种，红与黑是红黑树的实现者才关心的内容，对于我们使用者来说不用关心颜色，Java 中的 TreeMap 底层就是红黑树</p><hr /><blockquote><p>总结：Socket 既是一种编程模型，或者说是一段程序，同时也是一个文件，一个双向管道文件。可以理解，Socket API 是在 Socket 文件基础上进行的一层封装，而 Socket 文件是操作系统提供支持网络通信的一种文件格式。</p><p>在服务端有两种 Socket 文件，每个客户端接入之后会形成一个客户端的 Socket 文件，客户端 Socket 文件的文件描述符会存入服务端 Socket 文件。通过这种方式，一个线程可以通过读取服务端 Socket 文件中的内容拿到所有的客户端 Socket。这样一个线程就可以负责响应所有客户端的 I/O，这个技术称为 I/O 多路复用。</p><p>主动式的 I/O 多路复用，对负责 I/O 的线程压力过大，因此通常会设计一个高效的中间数据结构作为 I/O 事件的观察者，线程通过订阅 I/O 事件被动响应，这就是响应式模型。在 Socket 编程中，最适合提供这种中间数据结构的就是操作系统的内核，事实上 epoll 模型也是在操作系统的内核中提供了红黑树结构。</p></blockquote><hr /><blockquote><p>问题： epoll为什么是红黑树</p></blockquote><p>在 Linux 的设计中有三种典型的 I/O 多路复用模型 select、poll、epoll。</p><ul><li>select 是一个主动模型，需要线程自己通过一个集合存放所有的 Socket，然后发生 I/O 变化的时候遍历。在 select 模型下，操作系统不知道哪个线程应该响应哪个事件，而是由线程自己去操作系统看有没有发生网络 I/O 事件，然后再遍历自己管理的所有 Socket，看看这些 Socket 有没有发生变化。</li><li>poll 提供了更优质的编程接口，但是本质和 select 模型相同。因此千级并发以下的 I/O，你可以考虑 select 和 poll，但是如果出现更大的并发量，就需要用 epoll 模型。</li><li>epoll 模型在操作系统内核中提供了一个中间数据结构，这个中间数据结构会提供事件监听注册，以及快速判断消息关联到哪个线程的能力（红黑树实现）。因此在高并发 I/O 下，可以考虑 epoll 模型，它的速度更快，开销更小。</li></ul><h3 id="11-流和缓冲区缓冲区的-flip-是怎么回事"><a class="markdownIt-Anchor" href="#11-流和缓冲区缓冲区的-flip-是怎么回事"></a> <strong>11. 流和缓冲区：缓冲区的 flip 是怎么回事？</strong></h3><p><strong>流和缓冲区都是用来描述数据的。</strong></p><p>计算机中，数据往往会被抽象成流，然后传输。比如读取一个文件，数据会被抽象成文件流；播放一个视频，视频被抽象成视频流。处理节点为了防止过载，又会使用缓冲区削峰（减少瞬间压力）。在传输层协议当中，应用往往先把数据放入缓冲区，然后再将缓冲区提供给发送数据的程序。发送数据的程序，从缓冲区读取出数据，然后进行发送。</p><hr /><p><strong>流</strong></p><p><strong>流代表数据，具体来说是随着时间产生的数据</strong>，类比自然界的河流。你不知道一个流什么时候会完结，直到你将流中的数据都读完。</p><p>读取文件的时候，文件被抽象成流。流的内部构造，决定了你每次能从文件中读取多少数据。从流中读取数据的操作，本质上是一种迭代器。流的内部构造决定了迭代器每次能读出的数据规模。比如你可以设计一个读文件的流，每次至少会读出 4k 大小，也可以设计一个读文件的程序，每次读出一个字节大小。</p><p>通常情况读取数据的流，是读取流；写入数据的流，是写入流。那么一个写入流还能被理解成随着时间产生的数据吗？其实是一样的，随着时间产生的数据，通过写入流写入某个文件，或者被其他线程、程序拿走使用。</p><blockquote><p>思考一个问题：流中一定有数据吗？</p><p>看上去的确是这样。对于文件流来说，打开一个文件，形成读取流。读取流的本质当然是内存中的一个对象。当用户读取文件内容的时候，实际上是通过流进行读取，看上去好像从流中读取了数据，而本质上读取的是文件的数据。从这个角度去观察整体的设计，数据从文件到了流，然后再到了用户线程，因此数据是经过流的。</p></blockquote><p>但是仔细思考这个问题，可不可以将数据直接从文件传输到用户线程呢？比如流对象中只设计一个整数型指针，一开始指向文件的头部，每次发生读取，都从文件中读出内容，然后再返回给用户线程。做完这次操作，指针自增。通过这样的设计，流中就不需要再有数据了。可见，流中不一定要有数据。再举一个极端的例子，如果我们设计一个随机数的产生流，每次读取流中的数据，都调用随机数函数生成一个随机数并返回，那么流中也不需要有数据的存储。</p><hr /><p><strong>为什么要缓冲区？</strong><br />在上面的例子当中，我们讨论的时候发现，<strong>设计文件流时，可以只保留一个位置指针，不用真的将整个文件都读入内存</strong>，像下图这样：</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/stream.png" alt="stram" /></p><p>把文件看作是一系列线性排列连续字节的合集，用户线程调用流对象的读取数据方法，每次从文件中读取一个字节。流中只保留一个读取位置 position，指向下一个要读取的字节。</p><p>看上去这个方案可行，但实际上性能极差。因为从文件中读取数据这个操作，是一次磁盘的 I/O 操作，非常耗时。正确的做法是每次读取 2k、4k 这样大小的数据，这是因为操作系统中的内存分页通常是这样的大小，而磁盘的读写往往是会适配页表大小。而且现在的文件系统主要都是日志文件系统，存储的并不是原始数据本身，也就是说多数情况下你看到的文件并不是一个连续紧密的字节线性排列，而是日志。</p><p>当你向磁盘读取 2k 数据，读取到的不一定是 2k 实际的数据，很有可能会比 2k 少，这是因为文件内容是以日志形式存储，会有冗余</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/buffer1.png" alt="stram" /></p><p>如上图所示，内核每次从文件系统中读取到的数据是确定的，但是里边的有效数据是不确定的。</p><p>流对象的设计，至少应该支持两种操作：一种是读取一个字节，另一种是读取多个字节。而无论读取一个字节还是读取多个字节，都应该适配内核的底层行为。也就是说，每次流对象读取一个字节，内核可能会读取 2k、4k 的数据。这样的行为，才能真的做到减少磁盘的 I/O 操作。</p><p>那内核为什么不一次先读取几兆数据或者读取更大的数据呢？这有两个原因。</p><ul><li>如果是高并发场景下，并发读取数据时内存使用是根据并发数翻倍的，如果同时读取的数据量过大，可能会导致内存不足。</li><li>读取比 2k/4k……大很多倍的数据，比如 1M/2M 这种远远大于内存分页大小的数据，并不能提升性能。</li></ul><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/buffer2.png" alt="stram" /></p><p>上图中内核中的缓冲区，用于缓冲读取文件中的数据。流中的缓冲区，用于缓冲内核中拷贝过来的数据。</p><p>为什么不把内核的缓冲区直接给到流呢？这是因为流对象工作在用户空间，内核中的缓冲区工作在内核空间。<strong>用户空间的程序不可以直接访问内核空间的数据，这是操作系统的一种保护策略。</strong></p><p>当然也存在一种叫作<strong>内存映射的方式，就是内核通过内存映射，直接将内核空间中的一块内存区域分享给用户空间只读使用，这样的方式可以节省一次数据拷贝。这个能力在 Java 的 NIO 中称作 DirectMemory，对应 C 语言是 mmap。</strong></p><hr /><p><strong>缓冲区</strong><br />上面的设计中，我们已经开始用缓冲区解决问题了。那么具体什么是缓冲区呢？缓冲区就是一块用来做缓冲的内存区域。在上面的例子当中，为了应对频繁的字节读取，我们在内存当中设置一个 2k 大小缓冲区。这样读取 2048 次，才会真的发生一次读取。同理，如果应对频繁的字节写入，也可以使用缓冲区。</p><p>不仅仅如此，比如说你设计一个秒杀系统，如果同时到达的流量过高，也可以使用缓冲区将用户请求先存储下来，再进行处理。这个操作我们称为削峰，削去流量的峰值。</p><p>缓冲区中的数据通常具有朴素的公平，说白了就是<strong>排队，先进先出（FIFO）</strong>。从数据结构的设计上，缓冲区像一个队列。在实际的使用场景中，缓冲区有一些自己特别的需求，比如说缓冲区需要被重复利用。多次读取数据，可以复用一个缓冲区，这样可以节省内存，也可以减少分配和回收内存的开销。</p><p>文件流 -&gt; 缓冲区 -&gt; 网络流</p><p>举个例子：读取一个流的数据到一个缓冲区，然后再将缓冲区中的数据交给另一个流。 比如说读取文件流中的数据交给网络流发送出去。首先，我们要将文件流的数据写入缓冲区，然后网络流会读取缓冲区中的数据。这个过程会反反复复进行，直到文件内容全部发送。</p><p>这个设计中，缓冲区需要支持这几种操作：</p><ul><li>写入数据</li><li>读出数据</li><li>清空（应对下一次读写）</li></ul><p>那么具体怎么设计这个缓冲区呢？如下图所示：</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/buffering.png" alt="buffering" /></p><blockquote><p>将 position 设置为 0，limit 不变的操作称为flip操作，flip 本意是翻转，在这个场景中是读、写状态的切换。</p></blockquote><p>读取操作可以控制循环从 position 一直读取到 limit，这样就可以读取出 a,b,c,d。那么如果要继续写入应该如何操作呢？ 这个时候就需要用到缓冲区的clear操作，这个操作会清空缓冲区。具体来说，clear操作会把 position,limit 都设置为 0，而不需要真的一点点擦除缓冲区中已有的值，就可以做到重复利用缓冲区了。</p><p><strong>写入过程从 position = 0 开始，position 和 limit 一起自增。读取时，用flip操作切换缓冲区读写状态。读取数据完毕，用clear操作重置缓冲区状态。</strong></p><hr /><blockquote><p>总结: 流是随着时间产生的数据。数据抽象成流，是因为客观世界存在着这样的现象。数据被抽象成流之后，我们不需要把所有的数据都读取到内存当中进行计算和迭代，而是每次处理或者计算一个缓冲区的数据。</p><p><strong>缓冲区的作用是缓冲，它在高频的 I/O 操作中很有意义</strong>。针对不同场景，也不只有这一种缓冲区的设计，比如<strong>用双向链表实现队列（FIFO 结构）可以作为缓冲区</strong>；<strong>Redis 中的列表可以作为缓冲区</strong>；<strong>RocketMQ，Kafka 等也可以作为缓冲区</strong>。针对某些特定场景，比如高并发场景下的下单处理，可能会用订单队列表（MySQL 的表）作为缓冲区。</p><p>因此从这个角度来说，作为开发者我们首先要有缓冲的意识，去减少 I/O 的次数，提升 I/O 的性能，然后才是思考具体的缓冲策略。</p></blockquote><hr /><blockquote><p>问题：在缓存区的设计中，还通常有一个rewind操作，这个操作用来做什么的。</p></blockquote><h3 id="12-网络io模型bio-nio和aio有什么区别"><a class="markdownIt-Anchor" href="#12-网络io模型bio-nio和aio有什么区别"></a> **12.  网络I/O模型：BIO, NIO和AIO有什么区别</h3><p>在处理 I/O 的时候，要结合具体的场景来思考程序怎么写。从程序的 API 设计上，我们经常会看到 3 类设计：BIO、NIO 和 AIO 。</p><p>从本质上说，讨论 BIO、NIO、AIO 的区别，其实就是在讨论 I/O 的模型，我们可以从下面 3 个方面来思考 。</p><ul><li>编程模型：合理设计 API，让程序写得更舒服。</li><li>数据的传输和转化成本：比如减少数据拷贝次数，合理压缩数据等。</li><li>高效的数据结构：利用好缓冲区、红黑树等</li></ul><hr /><p><strong>I/O编程模型</strong></p><p><strong>BIO</strong>（Blocking I/O，阻塞 I/O），API 的设计会阻塞程序调用。</p><p><strong>NIO</strong>（None Blocking I/O, 非阻塞I/O），API的设计不会阻塞程序的调用</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte a &#x3D; readKey()</span><br></pre></td></tr></table></figure><p>假设readKey方法从键盘读取一个按键，如果是非阻塞 I/O 的设计，readKey不会阻塞当前的线程。你可能会问：那如果用户没有按键怎么办？在阻塞 I/O 的设计中，如果用户没有按键线程会阻塞等待用户按键，在非阻塞 I/O 的设计中，线程不会阻塞，没有按键会返回一个空值，比如 null。</p><p><strong>线程的上下文切换(Context Switch)</strong>: 从一个线程执行切换到另一个线程执行</p><p>最后我们说说 <strong>AIO</strong>（Asynchronous I/O， 异步 I/O），API 的设计会多创造一条时间线。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func callBackFunction(byte keyCode) &#123;</span><br><span class="line">  &#x2F;&#x2F; 处理按键</span><br><span class="line">&#125;</span><br><span class="line">readKey( callBackFunction )</span><br></pre></td></tr></table></figure><p>在异步 I/O 中，readKey方法会直接返回，但是没有结果。结果需要一个回调函数callBackFunction去接收。从这个角度看，其实有两条时间线。第一条是程序的主干时间线，readKey的执行到readKey下文的程序都在这条主干时间线中。而callBackFunction的执行会在用户按键时触发，也就是时间不确定，因此callBackFunction中的程序是另一条时间线也是基于这种原因产生的，我们称作异步，异步描述的就是这种时间线上无法同步的现象，你不知道callbackFunction何时会执行。</p><p>但是我们通常说某某语言提供了异步 I/O，不仅仅是说提供上面程序这种写法，上面的写法会产生一个叫作回调地狱的问题，本质是异步程序的时间线错乱，导致维护成本较高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">request(&quot;&#x2F;order&#x2F;123&quot;, (data1) -&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;..</span><br><span class="line">  request(&quot;&#x2F;product&#x2F;456&quot;, (data2) -&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; ..</span><br><span class="line">    request(&quot;&#x2F;sku&#x2F;789&quot;, (data3) -&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F;...</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>比如上面这段程序（称作回调地狱）维护成本较高，因此通常提供异步 API 编程模型时，我们会提供一种将异步转化为同步程序的语法。比如下面这段伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future future1 &#x3D; request(&quot;&#x2F;order&#x2F;123&quot;)</span><br><span class="line">Future future2 &#x3D; request(&quot;&#x2F;product&#x2F;456&quot;)</span><br><span class="line">Future future3 &#x3D; request(&quot;&#x2F;sku&#x2F;789&quot;)</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">order &#x3D; future1.get()</span><br><span class="line">product &#x3D; future2.get()</span><br><span class="line">sku &#x3D; future3.get()</span><br></pre></td></tr></table></figure><p>request 函数是一次网络调用，请求订单 ID=123 的订单数据。本身 request 函数不会阻塞，会马上执行完成，而网络调用是一次异步请求，调用不会在request(&quot;/order/123&quot;)下一行结束，而是会在未来的某个时间结束。因此，我们用一个 Future 对象封装这个异步操作。future.get()是一个阻塞操作，会阻塞直到网络调用返回。</p><p>在request和future.get之间，我们还可以进行很多别的操作，比如发送更多的请求。 像 Future 这样能够将异步操作再同步回主时间线的操作，我们称作异步转同步，也叫作异步编程。</p><hr /><p><strong>数据的传输和转化成本</strong></p><p>上面我们从编程的模型上对 I/O 进行了思考，接下来我们从内部实现分析下 BIO、NIO 和 AIO。无论是哪种 I/O 模型，<strong>都要将数据从网卡拷贝到用户程序（接收），或者将数据从用户程序传输到网卡（发送）</strong>。</p><p>另一方面，<strong>有的数据需要编码解码，比如 JSON 格式的数据</strong>。还<strong>有的数据需要压缩和解压</strong>。数据从网卡到内核再到用户程序是 2 次传输。注意，将数据从内存中的一个区域拷贝到另一个区域，这是一个 CPU 密集型操作。数据的拷贝归根结底要一个字节一个字节去做。</p><p>网卡 -&gt; 内核 -&gt; 用户程序</p><p>从网卡到内核空间的这步操作，可以用 <strong>DMA</strong>（Direct Memory Access）技术控制。DMA 是一种小型设备，用 DMA 拷贝数据可以不使用 CPU，从而节省计算资源。遗憾的是，通常我们写程序的时候，不能直接控制 DMA，因此 DMA 仅仅用于设备传输数据到内存中。</p><p>不过，<strong>从内核到用户空间这次拷贝，可以用内存映射技术，将内核空间的数据映射到用户空间</strong>。</p><p>无论I/O的编程模型如何选择，数据传输和转化成本是逃不掉的，通过<strong>DMA技术</strong>和<strong>内存映射技术</strong>，就可以节省成本：</p><ul><li>减少数据传输</li><li>数据压缩解压</li><li>数据编码解码</li></ul><hr /><p><strong>数据结构运用</strong></p><p>在处理网络 I/O 问题的时候，还有一个重点问题要注意，就是数据结构的运用。</p><p><strong>缓冲区</strong></p><p>是一种在处理 I/O 问题中常用的数据结构，一方面<strong>缓冲区起到缓冲作用</strong>，在瞬时 I/O 量较大的时候，利用排队机制进行处理；另一方面，<strong>缓冲区起到一个批处理的作用</strong>，比如 1000 次 I/O 请求进入缓冲区，可以合并成 50 次 I/O 请求，那么整体性能就会上一个档次。</p><p>举个例子，比如你有 1000 个订单要写入 MySQL，如果这个时候你可以将这 1000 次请求合并成 50 次，那么磁盘写入次数将大大减少。同理，假设有 10000 次网络请求，如果可以合并发送，会减少 TCP 协议握手时间，可以最大程度地复用连接；另一方面，如果这些请求都较小，还可以粘包复用 TCP 段。在处理 Web 网站的时候，经常会碰到将多个 HTTP 请求合并成一个发送，从而减少整体网络开销的情况。</p><p>除了上述两方面原因，<strong>缓冲区还可以减少实际对内存的诉求</strong>。数据在网卡到内核，内核到用户空间的过程中，建议都要使用缓冲区。当收到的某个请求较大的时候，抽象成流，然后使用缓冲区可以减少对内存的使用压力。这是因为使用了缓冲区和流，就不需要真的准备和请求数据大小一致的内存空间了。可以将缓冲区大小规模的数据分成多次处理完，实际的内存开销是缓冲区的大小</p><p><strong>I/O 多路复用模型</strong></p><p>在运用数据结构的时候，还要思考 I/O 的多路复用用什么模型。</p><p>假设你在处理一个高并发的网站，每秒有大量的请求打到你的服务器上，你用多少个线程去处理 I/O 呢？对于没有需要压缩解压的场景，处理 I/O 的主要开销还是数据的拷贝。那么一个 CPU 核心每秒可以完成多少次数据拷贝呢？</p><p>拷贝，其实就是将内存中的数据从一个地址拷贝到另一个地址。再加上有 <strong>DMA，内存映射等技术</strong>，拷贝是非常快的。不考虑 DMA 和内存映射，一个 3GHz 主频的 CPU 每秒可以拷贝的数据也是百兆级别的。当然，速度还受限于内存本身的速度。因此总的来说，<strong>I/O 并不需要很大的计算资源</strong>。通常我们在处理高并发的时候，也不需要大量的线程去进行 I/O 处理。</p><p>对于多数应用来说，处理 I/O 的成本小于处理业务的成本。处理高并发的业务，可能需要大量的计算资源。每笔业务也可能会需要更多的 I/O，比如远程的 RPC 调用等。</p><p>因此我们在处理高并发的时候，一种常见的 I/O 多路复用模式就是由<strong>少量的线程处理大量的网络接收、发送工作</strong>。然后再由更多的线程，通常是一个线程池处理具体的业务工作。</p><p>在这样一个模式下，有一个核心问题需要解决，就是当操作系统内核监测到一次 I/O 操作发生，它如何具体地通知到哪个线程调用哪段程序呢？</p><p>这时，<strong>一种高效的模型会要求我们将线程、线程监听的事件类型，以及响应的程序注册到内核</strong>。具体来说，比如某个客户端发送消息到服务器的时候，我们需要尽快知道哪个线程关心这条消息（处理这个数据）。例如 <strong>epoll 就是这样的模型，内部是红黑树。我们可以具体地看到文件描述符构成了一棵红黑树，而红黑树的节点上挂着文件描述符对应的线程、线程监听事件类型以及相应程序。</strong></p><p>讲了这么多，缓冲区 和 BIO、AIO、NIO 有什么关系？这里有两个联系。</p><p>首先是无论哪种编程模型都需要使用缓冲区，也就是说 <strong>BIO、AIO、NIO 都需要缓冲区，因此关系很大</strong>。在我们使用任何编程模型的时候，如果内部没有使用缓冲区，那么一定要在外部增加缓冲区。<strong>另一个联系是类似 epoll 这种注册+消息推送的方式，可以帮助我们节省大量定位具体线程以及事件类型的时间。这是一个通用技巧，并不是独有某种 I/O 模型才可以使用。</strong></p><p>不过从能力上分析，使用类似 epoll 这种模型，确实没有必要让处理 I/O 的线程阻塞，因为操作系统会将需要响应的事件源源不断地推送给处理的线程，因此可以考虑不让处理线程阻塞（比如用 NIO）</p><hr /><blockquote><p>总结: 从 3 个方面讨论了 I/O 模型。</p><p>第一个是编程模型，阻塞、非阻塞、异步 3 者 API 的设计会有比较大的差异。通常情况下我们说的异步编程是异步转同步。异步转同步最大的价值，就是提升代码的可读性。可读，就意味着维护成本的下降以及扩展性的提升。</p><p>第二个在设计系统的 I/O 时，另一件需要考虑的就是数据传输以及转化的成本。传输主要是拷贝，比如可以使用内存映射来减少数据的传输。但是这里要注意一点，内存映射使用的内存是内核空间的缓冲区，因此千万不要忘记回收。因为这一部分内存往往不在我们所使用的语言提供的内存回收机制的管控范围之内。</p><p>最后是关于数据结构的运用，针对不同的场景使用不同的缓冲区，以及选择不同的消息通知机制，也是处理高并发的一个核心问题。</p><p>从上面几个角度去看 I/O 的模型，你会发现，编程模型是编程模型、数据的传输是数据的传输、消息的通知是消息的通知，它们是不同的模块，完全可以解耦，也可以根据自己不同的业务特性进行选择。虽然在一个完整的系统设计中，往往提出的是一套完整的解决方案 ，但实际上我们还是应该将它们分开去思考，这样可以产生更好的设计思路。</p></blockquote><blockquote><p>问题： BIO、NIO 和 AIO 有什么区别？</p><p>总的来说，这三者是三个 I/O 的编程模型。BIO 接口设计会直接导致当前线程阻塞。NIO 的设计不会触发当前线程的阻塞。AIO 为 I/O 提供了异步能力，也就是将 I/O 的响应程序放到一个独立的时间线上去执行。但是通常 AIO 的提供者还会提供异步编程模型，就是实现一种对异步计算封装的数据结构，并且提供将异步计算同步回主线的能力。</p><p>通常情况下，这 3 种 API 都会伴随 I/O 多路复用。如果底层用红黑树管理注册的文件描述符和事件，可以在很小的开销内由内核将 I/O 消息发送给指定的线程。另外，还可以用 DMA，内存映射等方式优化 I/O。</p></blockquote><blockquote><p>问题： I/O 多路复用用协程和用线程的区别？</p><p>线程是执行程序的最小单位。I/O 多路复用时，会用单个线程处理大量的 I/O。还有一种执行程序的模型，叫协作程，协程是轻量级的线程。操作系统将执行资源分配给了线程，然后再调度线程运行。如果要实现协程，就要利用分配给线程的执行资源，在这之上再创建更小的执行单位。协程不归操作系统调度，协程共享线程的执行资源。</p><p>而 I/O 多路复用的意义，是减少线程间的切换成本。因此从设计上，只要是用单个线程处理大量 I/O 工作，线程和协程是一样的，并无区别。如果是单线程处理大量 I/O，使用协程也是依托协程对应线程执行能力。</p></blockquote><h3 id="13-面试中如何回答怎样实现rpc框架的问题"><a class="markdownIt-Anchor" href="#13-面试中如何回答怎样实现rpc框架的问题"></a> <strong>13.  面试中如何回答“怎样实现RPC框架”的问题</strong></h3><p>随着微服务架构的盛行，远程调用成了开发微服务必不可少的能力，RPC 框架作为微服务体系的底层支撑，也成了日常开发的必备工具。当下，RPC 框架已经不仅是进行远程调用的基础工具，还需要提供路由、服务发现、负载均衡、容错等能力。那么今天，我们就以“怎样实现 RPC 框架”为引，从设计者角度看看如何设计一个 RPC 框架。</p><p>RPC（Remote Procedure Call）远程过程调用，顾名思义最基本的能力当然是远程调用一个过程。放到今天的面向对象的语言中，其实就是调用一个远程的方法。在远程我们必须先定义这个方法，然后才可以通过 RPC 框架调用该方法，远程调用不仅可以传参数、获取到返回值，还可以捕捉调用过程中的异常。RPC 让远程调用就像本地调用一样。</p><p>假设我们实现了一个rpc对象，其中的invoke方法可以实现远程调用。下面这段伪代码在调用远程的greetings方法（RPC 调用），并向远程方法传递参数arg1``arg2，然后再接收到远程的返回值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result &#x3D; rpc.invoke(&quot;greetings&quot;, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><p>复制<br />这段程序将本地看作 一个 RPC 的客户端，将远程看作一个 RPC 的服务端。如下图所示：</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/RPC.png" alt="rpc" /></p><p>服务 A 发起远程方法调用，RPC 客户端通过某种协议将请求发送给服务 B，服务 B 解析请求，进行本地方法的调用，将结果返回到服务 B 的 RPC 服务端，最终返回到服务 A。</p><p>对服务 A 来说，调用的是一个函数，从接口到返回值的设计，和调用本地函数并没有太大的差别。</p><p>当然，我们不能完全忽略这是一次远程方法调用，因为远程调用的开销较大。如果程序员没有意识到调用远程方法有网络开销，就可能会写出下面这段程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i &#x3D; 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">  rpc.invoke(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以写出上面的程序，是因为 没有意识到 rpc.invoke 是一次远程调用。在实际的操作过程中，rpc.invoke可能被封装到了某个业务方法中，程序员调用的时候便容易忽视这是一次远程操作。所以 RPC 调用时就要求我们对性能有清晰的认识。</p><hr /><p><strong>多路复用的优化</strong></p><p>RPC 提供的是远程方法的调用，但<strong>本质上是数据的传递</strong>，传递数据有一个最基本的问题要处理，就是提升吞吐量（单位时间传递的数据量）</p><p>如果<strong>为每个远程调用（请求）建立一个连接，就会造成资源的浪费，因此通常我们会考虑多个请求复用一个连接，叫<code>作多路复用</code></strong>。</p><p>在具体实现多路复用的时候，也会有不同的策略。假设我们要发送数据 A、B、C、D，那么一种方式是建立一个连接，依次将 A、B、C、D 发过去，就像下图这样：</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/rpc2.png" alt="rpc" /></p><p>在 A 较大的时候，B，C，D 就只能等 A 完全传送完成才能发生传送。这样的模型对于 RPC 请求/响应大小不平均的网络不太友好，体积小的请求/响应可能会因为一些大体积的请求/响应而延迟。</p><p>因此还有另一种常见的多路复用方案，就是将 A,B,C,D切片一起传输，如上图(3)所示</p><p>上图中，我们用不同颜色代表不同的传输任务。采用顺序传输方案将 A、B、C、D 用一个连接传输节省了握手、挥手的成本。<strong>切片传输的方案在这之上，将数据切片可以保证大、小任务并行，不会因为大任务阻塞小任务。</strong></p><p>另外还有一个<strong>需要考虑的点，是单个 TCP 连接的极限传输速度受到窗口大小、缓冲区等因素的制约，不一定可以用满网络资源</strong>。如果传输量特别大的时候，有可能需要考虑提供多个连接，每个连接再去考虑多路复用的情况。</p><hr /><p><strong>调用约定和命名</strong></p><p>接下来，我们一起思考下服务的命名。远程调用一个函数，命名空间＋类名＋方法名是一个比较好的选择，简而言之，每个可以远程调用的方法就是一个字符串。</p><p>比如远程调用一个支付服务对象 PayService 的 pay 方法</p><ul><li>命名空间可能是 trade.payment</li><li>对象名称是 PayService</li><li>方法名称是 pay</li></ul><p>组合起来可以是一个完整的字符串，例如用 # 分割<code>trade.payment#PayService#pay</code>。</p><p>在进行远程调用的时候，给远程方法命名是调用约定的一部分。我们通过调用命名空间下完整的名称调用远程方法。在面向对象的语言中，还有一种常见的做法是<strong>先不具体指定调用的方法，而是先创造一个远程对象的实例</strong>。比如上面例子中我们先通过 RPC 框架构造一个 PayService 对象的实例。这里会用到一些特别的编程技巧，比如代理设计模式、动态接口生成等。</p><p>不过归根结底，我们调用的本质就是字符串名称。而实现这个调用，你需要知道两件事情：</p><ul><li>IP 是多少，也就是方法在哪台机器上调用；</li><li>端口是多少，也就是哪个服务提供这个调用。</li></ul><hr /><p><strong>注册和发现</strong></p><p>调用的时候，我们需要<strong>根据字符串（命名）去获取 IP 和端口（机器和服务）</strong>。</p><p>机器可以是虚拟机、容器、实体机，也可以是某个拥有虚拟网卡的代理。在网络的世界中，需要的只是网络接口和 IP 地址。而操作系统区分应用需要的是端口。所以，在调用过程中，我们需要的是一个注册表，存储了字符串和 IP + 端口的对应关系。</p><p>聪明的同学可能马上会想到，用 <strong>Redis 的hash对象存储这个对应关系就很不错</strong>。当我们上线一个服务的时候，就在 Redis 的某个hash对象中存储它和它对应的 IP 地址 + 端口列表。为什么是存一个列表？因为一个服务可能由多个机器提供。</p><p>通常我们<strong>将写这个hash对象的过程，也就是服务被记录的过程称作<code>注册</code></strong>。我们远程调用一个 RPC 服务的时候，调用端提供的是 RPC 服务的名称（例如：命名空间+对象+方法），<strong>根据名称查找到提供服务的 IP + 端口清单并指定某个 IP + 端口（提供服务）的过程称作<code>发现</code></strong>。</p><p>当然，我们不能就这样简单理解成：注册就是写一个共享的哈希表，发现就是查哈希表再决定服务的响应者。在实际的设计中，要考虑的因素会更多。</p><p>比如基于 Redis 的实现，如果所有 RPC 调用都需要去 Redis 查询，会造成负责发现的中间件压力较大。</p><ul><li>实际的操作过程中，往往会增加缓存。也就是 RPC 调用者会缓存上一次调用的 IP + 端口。但是这样设计，缓存又可能会和注册表之间产生数据不一致的问题。</li><li>这个时候，可以考虑由分布式共识服务比如 ZooKeeper 提供订阅，让 RPC 调用者订阅到服务地址的变更，及时更新自己的缓存。</li></ul><p><strong>设计注册和发现两个功能的最大的价值是让客户端不再需要关注服务的部署细节，这样方便在全局动态调整服务的部署策略</strong>。</p><hr /><p><strong>负载均衡的设计</strong></p><p>在设计 RPC 框架的时候，负载均衡器的设计往往需要和 RPC 框架一起考虑。<strong>因为 RPC 框架提供了注册、发现的能力，提供发现能力的模块本身就是一个负载均衡器</strong>。因此负载均衡可以看作发现模块的一个子组件。请求到达 RPC 的网关（或某个路由程序）后，发现组件会提供服务对应的所有实例（IP + 端口），然后负载均衡算法会指定其中一个响应这个请求。</p><hr /><p>可用性和容灾</p><ul><li>当一个服务实例崩溃的时候（不可用），因为有发现模块的存在，可以及时从注册表中删除这个服务实例。<ul><li>只要服务本身有足够多的实例，比如多个容器而且部署在不同的机器上，那么完全不可能用的风险会大大降低。当然，可用性是不可能 100% 实现的。</li></ul></li><li>另外，<strong>注册表和 RPC 调用者之间必然存在不一致现象，而且注册表的更新本身也可能滞后</strong>。比如确认一个服务有没有崩溃，可能需要一个<strong>心跳程序持续请求这个服务</strong>，因此 RPC 的调用者如果调用到一个不存在的服务，或者调用到一个发生崩溃的服务，需要自己重新去发现组件申请新的服务实例（地址 + 端口）。</li><li><strong>如果遇到临时访问量剧增，需要扩容的场景。这个时候只需要上线更多的容器，并且去注册即可</strong>。当然这要求部署模块和注册模块之间有较高的协同，这块可以<strong>用自动化脚本衔接</strong>。</li></ul><hr /><blockquote><p>总结</p><p>设计一个 RPC 框架最基础的能力就是实现远程方法的调用。这里需要一个调用约定，</p><ul><li>比如怎么描述一个远程的方法，</li><li>发送端怎么传递参数，</li><li>接收方如何解析参数？</li><li>如果发生异常应该如何处理？</li></ul><p>具体来说，这些事情都不难实现，只是比较烦琐。</p><ul><li>其实不仅仅在 RPC 调用时有调用约定</li><li>编译器在实现函数调用的时候，也会有调用约定。</li><li>另外，还有一些在 RPC 基础上建立起来的更复杂、更体系化的约定，比如说面向服务架构（SOA）。</li></ul><p>在实现了基本调用能力的基础上，<strong><code>接下来就是提供服务的注册、发现能力。有了这两个能力，就可以向客户端完全屏蔽服务的部署细节，并衍生出容灾、负载均衡的设计。[我不理解]</code></strong></p><p>当然，程序员还需要思考底层具体网络的传输问题。</p><ul><li>如果用 TCP 要思考多路复用以及连接数量的问题；</li><li>如果是 UDP，需要增加对于可靠性保证的思考。</li><li>如果使用了消息队列，还需要考虑服务的幂等性设计等。</li></ul></blockquote><hr /><blockquote><p>问题： 如何理解Dubbo的几个组成部分Consumer, Provider, Monitor和Registry?</p></blockquote><h2 id="web技术"><a class="markdownIt-Anchor" href="#web技术"></a> Web技术</h2><ul><li>HTTP协议-&gt;Web技术生态</li></ul><h3 id="14-dns域名解析系统cname记录的作用是"><a class="markdownIt-Anchor" href="#14-dns域名解析系统cname记录的作用是"></a> <strong>14. DNS域名解析系统：CNAME记录的作用是</strong></h3><p>在浏览器中输入一个 URL，或者用curl请求一个网址……域名系统（Domain Name System）就开始工作了。作为互联网的一个重要成员，域名系统是将互联网资源和地址关联起来的一个分布式数据库。</p><hr /><p>统一资源定位符（URL, Uniform Resource Locator）可以通过字符串定位一个互联网的资源,比如视频、图片、文件、网页。</p><p>下图是一个 URL 的示例：</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/url.png" alt="url" /></p><ul><li>Scheme 部分代表协议，不只有 https，还有 ftp、ssh 等。不同协议代表着不同类型的应用在提供资源。</li><li>Host 部分代表站点，我们今天介绍的 DNS 主要作用就是根据 Host 查找 IP 地址。</li><li>Port 是端口，代表提供服务的应用。</li><li>Path 是路径，代表资源在服务中的路径。</li><li>Query 是查询条件，代表需要的是资源中的某一个部分。</li><li>Fragment 是二级查询条件，通常不在服务端响应，而是用于前端展示定位内容。</li></ul><p>总的来说，URL 是一种树状的设计， Host 代表主机（对应的 IP 地址由 DNS 服务提供）；Port 代表应用；Path 代表资源在应用中的路径；Query 代表对资源的查询条件。通过这种设计，互联网中万亿级别的资源都可以得到有效区分。</p><p>树状的设计在今天计算机中也非常常见，比如</p><ul><li>文件目录的设计</li><li>源代码块的嵌套设计</li><li>JSON 和 XML 的设计，都是树状关系。</li></ul><hr /><p><strong>域名系统 DNS</strong>（Domain Name System，域名系统）是一个<strong>将域名和 IP 地址相互映射的分布式服务</strong>。</p><p><strong>根域名服务器</strong> （Root Name Server） 位于最顶层的是根域名服务器</p><p>DNS 本身是一个出色的分布式架构。</p><p>人们在全世界范围内搭建了多台根域名服务器，2016 年的统计数据中，全世界目前有 13 台 IPv4 根服务器，25 台 IPv6 根服务器。</p><p><strong>根域名服务器存储的不是域名和 IP 的映射关系，而是一个目录。</strong></p><p>如果将所有的域名记录都存放到根域名服务器，从存储量上来说，不会非常巨大。要知道一个域名记录——域名、IP 地址和额外少量信息，并不需要大量存储空间。</p><p>但是如果全世界所有的 DNS 请求都集中在少量的根服务器上，这个访问流量就会过于巨大。而且一旦发生故障，很容易导致大面积瘫痪。</p><p>而且因为根服务器较少，所以如果全部都走根服务器，不同客户端距离根服务器距离不同，感受到的延迟也不一样，这样对用户来说不太友好。</p><p>因此，<strong>因为流量、防止单点故障、平衡地理分布等问题，根域名服务器只是一个目录，并不提供具体的数据。</strong></p><p><strong>域名分级和数据分区</strong></p><p>我们知道中文字典可以按照偏旁部首以及拼音索引，和字典类似，根服务器提供的目录也有一定的索引规则。</p><ul><li>在域名的世界中，通过分级域名的策略建立索引。伴随着域名的分级策略，实际上是域名数据库的拆分。</li><li>通过域名的分级，可以将数据库划分成一个个区域。</li></ul><p>平时我们看到的.com.cn.net等，称为顶级域名。比如对于 <a href="http://www.artisan.com">www.artisan.com</a> 这个网址来说，<strong>com是顶级域名，artisan是二级域名，www是三级域名</strong>。</p><p>域名分级当然是为了建立目录和索引，并对数据存储进行分区。</p><ul><li>根DNS服务器<ul><li>com DNS服务器<ul><li>baidu</li><li>taobao</li></ul></li><li>net DNS服务器</li><li>org DNS服务器</li><li></li></ul></li></ul><p>DNS 的存储设计是一个树状结构。叶子节点中才存放真实的映射关系，中间节点都是目录。存储分成 3 层：</p><ul><li>顶部第一级是根 DNS 存储，存储的是顶级域的目录，被称作根 DNS 服务器；</li><li>第二级是顶级域存储，存储的是二级域的目录，被称作顶级域 DNS 服务器（Top Level DNS，TLD）；</li><li>最后一级是叶子节点，存储的是具体的 DNS 记录，也被称作权威 DNS 服务器。</li></ul><p><strong>DNS 查询过程</strong><br />当用户在浏览器中输入一个网址，就会触发 DNS 查询。这个时候在上述的 3 个层级中，还会增加本地 DNS 服务器层级。本地 DNS 服务器包括用户自己路由器中的 DNS 缓存、小区的 DNS 服务器、ISP 的 DNS 服务器等。<br />主要步骤如下：</p><ul><li>用户输入网址，查询本地 DNS。<ul><li>本地 DNS 是一系列 DNS 的合集，比如 ISP 提供的 DNS、公司网络提供的 DNS。本地 DNS 是一个代理，将 DNS 请求转发到 DNS 网络中。如果本地 DNS 中已经存在需要的记录，也就是本地 DNS 缓存中找到了对应的 DNS 条目，就会直接返回，而跳过之后的步骤。</li></ul></li><li>客户端请求根 DNS 服务器。<ul><li>如果本地 DNS 中没有对应的记录，那么请求会被转发到根 DNS 服务器。根 DNS 服务器只解析顶级域，以“<a href="http://www.artisan.com">www.artisan.com</a>”为例，根 DNS 服务器只看 com 部分。</li></ul></li><li>根 DNS 服务器返回顶级 DNS 服务器的 IP。</li><li>客户端请求顶级 DNS 服务器，顶级 DNS 服务器中是具体域名的目录。</li><li>顶级 DNS 服务器返回权威 DNS 服务器的 IP。</li><li>客户端请求权威 DNS 服务器。在权威 DNS 服务器上存有具体的 DNS 记录。以 artisan为例，权威 DNS 服务器中可能有和 <a href="http://artisan.com">artisan.com</a> 相关的上百条甚至更多的 DNS 记录，会根据不同的 DNS 查询条件返回。</li><li>权威 DNS 服务器返回 DNS 记录到本地 DNS 服务器。</li><li>本地 DNS 服务器返回具体的 DNS 记录给客户端。</li></ul><p>在上述 8 个过程全部结束后，客户端通过 DNS 记录中的 IP 地址，可以找到请求服务的主机。 客户端最终可以找到 对应的 IP 地址，从而获得 Web 服务。</p><hr /><p><strong>关于缓存</strong></p><p>在上面的例子当中，每一步都有缓存的设计。浏览器会缓存 DNS，此外，操作系统、路由器、本地 DNS 服务器也会……因此，<strong>绝大多数情况，请求不会到达根 DNS 服务器</strong>。</p><p>以artisan为例，<strong>如果在某个时刻同一个区域内有一个用户触发过上述 1~8 的过程，另一个同区域的用户就可以在本地 DNS 服务器中获得 DNS 记录，而不需要再走到根 DNS 服务器。这种设计，我们称作<code>分级缓存策略</code>。</strong></p><p>在分级缓存策略中，每一层都会进行缓存，经过一层层的缓存，最终命中根 DNS 服务、顶级 DNS 服务器以及权威 DNS 服务的请求少之又少。这样，互联网中庞大流量的 DNS 查询就不需要大量集中的资源去响应。</p><hr /><p><strong>DNS 记录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;定义www.example.com的ip地址</span><br><span class="line">www.example.com.     IN     A     139.18.28.5;</span><br></pre></td></tr></table></figure><p>上面的就是一条 DNS 记录，纯文本即可。</p><ul><li><strong>IN 代表记录用于互联网，是 Intenet 的缩写</strong>。在历史上 Internet 起源于阿帕网，在同时代有很多竞争的网络，IN 这个描述也就保留了下来。</li><li><strong><a href="http://www.example.com">www.example.com</a> 是要解析的域名</strong>。</li><li><strong>A 是记录的类型</strong>，A 记录代表着这是一条用于解析 IPv4 地址的记录。从这条记录可知，www.example.com的 IP 地址是 139.18.28.5。</li><li><strong>;是语句块的结尾，也是注释</strong>。</li></ul><p>那么除了 A 记录，还有哪些 DNS 记录的类型呢？DNS 记录的类型非常多，有 30 多种。其中比较常见的有 A、AAAA、CNAME、MX，以及 NS 等</p><p><strong>CNAME（Canonical Name Record）</strong> 用于定义域名的别名，如下面这条 DNS 记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">; 定义www.example.com的别名</span><br><span class="line">a.example.com.    IN   CNAME   b.example.com.</span><br></pre></td></tr></table></figure><p>当你想把一个网站迁移到新域名，旧域名仍然保留的时候；还有当你想将自己的静态资源放到 CDN 上的时候，CNAME 就非常有用</p><p><strong>AAAA 记录</strong> 前面我们提到，A 记录是域名和 IPv4 地址的映射关系。和 A 记录类似，AAAA 记录则是域名和 IPv6 地址的映射关系。</p><p>MX 记录（Mail Exchanger Record）<br />MX 记录是邮件记录，用来描述邮件服务器的域名。</p><p>在工作中，我们经常会发邮件到某个同事的邮箱。比如说，发送一封邮件到 <a href="mailto:xiaoming@artisan.com">xiaoming@artisan.com</a>，那么artisan如何知道哪个 IP 地址是邮件服务器呢？</p><p>这个时候就可以用到下面这条 MX 记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN MX mail.artisan.com</span><br></pre></td></tr></table></figure><p>这样凡是 @artisan的邮件都会发送到 <a href="http://mail.artisan.com">mail.artisan.com</a> 中，而 <a href="http://mail.artisan.com">mail.artisan.com</a> 的 IP 地址可以通过查询 <a href="http://mail.artisan.com">mail.artisan.com</a> 的 A 记录和 AAAA 记录获得。</p><p><strong>NS 记录</strong>（Name Server）记录是描述 DNS 服务器网址。从 DNS 的存储结构上说，Name Server 中含有权威 DNS 服务的目录。也就是说，NS 记录指定哪台 Server 是回答 DNS 查询的权威域名服务器。</p><p>当一个 DNS 查询看到 NS 记录的时候，会再去 NS 记录配置的 DNS 服务器查询，得到最终的记录。如下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.com.     IN      NS      ns1.a.com.</span><br><span class="line">a.com.     IN      NS      ns2.a.com.</span><br></pre></td></tr></table></figure><p>当解析 <a href="http://a.com">a.com</a> 地址时，我们看到 <a href="http://a.com">a.com</a> 有两个 NS 记录，所以确定最终 <a href="http://a.com">a.com</a> 的记录在 <a href="http://ns1.a.com">ns1.a.com</a> 和 <a href="http://ns2.a.com">ns2.a.com</a> 上。从设计上看，ns1 和 ns2 是网站 <a href="http://a.com">a.com</a> 提供的智能 DNS 服务器，可以提供负载均衡、分布式 Sharding 等服务。比如当一个北京的用户想要访问 <a href="http://a.com">a.com</a> 的时候，ns1 看到这是一个北京的 IP 就返回一个离北京最近的机房 IP。</p><p>上面代码中 <a href="http://a.com">a.com</a> 配置了两个 NS 记录。通常 NS 不会只有一个，这是为了保证高可用，一个挂了另一个还能继续服务。通常数字小的 NS 记录优先级更高，也就是 ns1 会优先于 ns2 响应。</p><p>配置了上面的 NS 记录后，如果还配置了 <a href="http://a.com">a.com</a> 的 A 记录，那么这个 A 记录会被 NS 记录覆盖。</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/DNS.png" alt="DNS" /></p><blockquote><p>总结</p><p>用树状结构来分类和索引符合人类的直觉和习惯，URL 的设计遵循的依然是人的思考方式。</p><p>URL 中的 HOST 部分需要被解析为 IP 地址，于是就有了域名系统（DNS）。域名系统是一个分级的分布式系统，整体设计也是一个树状结构。</p><p>顶层的根域名服务器和中间的顶级域名服务器，存储的是目录，最终的 DNS 记录由权威域名服务器提供。DNS 记录并不仅仅只有映射 IP 一种能力，DNS 记录还可以设置网站的别名、邮件服务器、DNS 记录位置等能力。</p></blockquote><blockquote><p>问题： CNAME 记录的作用是？</p><p>CNAME 是一种 DNS 记录，它的作用是将一个域名映射到另一个域名。域名解析的时候，如果看到 CNAME 记录，则会从映射目标重新开始查询。</p></blockquote><h3 id="15-内容分发网络请简述cdn回源是如何工作"><a class="markdownIt-Anchor" href="#15-内容分发网络请简述cdn回源是如何工作"></a> <strong>15.  内容分发网络：请简述CDN回源是如何工作</strong></h3><p>对于一些体量较大的应用来说，如果把大量资源集中到单一节点进行分发，恐怕很难有某个机房可以支撑得住这么大的流量。</p><p>例如一个日活在 100W 的小型互联网产品，如果每次请求需要 1M 的数据，那就刚好是近 1TB 数据。对于这样的数据规模而言，完全由单一节点进行分发是不现实的。</p><p>因此现在<strong>互联网应用在分发内容的时候，并不是从自己架设的服务器上直分发内容，而是走一个叫作<code>内容分发网络（Content Dilivery Network）</code>的互联网底层建设。</strong></p><p>域名系统类似，<strong>内容分发网络（Content Dilivery Network，CDN）是一个专门用来分发内容的分布式应用</strong>。</p><p><strong>CDN 构建在现有的互联网之上，通过在各地部署数据中心，让不同地域的用户可以就近获取内容。</strong></p><p>这里的<strong>内容</strong>通常指的是文件、图片、视频、声音、应用程序安装包等，它们具有一个显著的特征——<strong>无状态</strong>，或者说是静态的。这些资源不像订单数据、库存数据等，它们一旦发布，就很少会发生变化。另一个显著的特征，是这些资源往往会被大量的用户需要，因此分发它们的<strong>流量成本是较高的</strong>。</p><p>为什么不能集中提供这些静态资源呢？这和域名系统的 DNS 记录不能集中提供是一个道理，需要考虑到流量、单点故障、延迟等因素。</p><ul><li>在离用户更近的地理位置提供资源，可以减少延迟。</li><li>按照地理位置分散地提供资源，也可以降低中心化带来的服务压力。</li></ul><p>因此，CDN 的服务商会选择在全球布点，或者在某个国家布点。具体要看 CDN 服务提供商的服务范围。目前国内的阿里云、腾讯云等也在提供 CDN 业务。</p><p><strong>内容的分发</strong></p><p>CDN 是一个分布式的内容分发网络。</p><ul><li>当用户请求一个网络资源时，用户请求的是 CDN 提供的资源。</li><li>和域名系统类似，当用户请求一个资源时，首先会接触到一个类似域名系统中目录的服务，这个服务会告诉用户究竟去哪个 IP 获取这个资源。</li></ul><p>事实上，<strong>很多大型的应用，会把 DNS 解析作为一种负载均衡的手段</strong>。当用户请求一个网址的时候，会从该网站提供的智能 DNS 中获取网站的 IP。</p><p>例如当你请求百度的时候，具体连接到哪个百度的 IP，是由百度使用的智能 DNS 服务决定的。域名系统允许网站自己为自己的产品提供 DNS 解析</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/CDN.png" alt="CDN" /></p><p>当用户请求一个静态资源的时候，首先会触发域名系统的解析。域名系统会将解析的责任交由 CDN 提供商来处理，CDN 的智能 DNS 服务会帮助用户选择离自己距离最近的节点，返回这个节点的 A（或 AAAA）记录。然后客户端会向 CDN 的资源节点发起请求，最终获得资源。</p><p>在上面整个过程当中，CDN 的智能 DNS 还充当了负载均衡的作用。如果一个节点压力过大，则可以将流量导向其他的节点。</p><hr /><p><strong>回源</strong></p><p>讨论了 CDN 的主要设计和架构，但是还有一个问题没有解决——就是<strong>资源怎么进入内容分发网络</strong>? 资源的生产者，也是 CDN 的购买者，目的是向用户提供网络服务。</p><ul><li>那么服务提供者的静态资源如何进入 CDN 呢？</li><li>手动上传、用接口推送，还是通过其他别的方式呢？</li></ul><p><strong>可以把 CDN 想象成一个分布式的分级缓存，再加上数据库的两层设计</strong>，如下图所示：</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/CDN2.png" alt="CDN" /></p><p>用户的请求先到达缓存层，如果缓存被穿透，才到达最终的存储层。缓存的设计必须是分布式的，因为绝大多数的资源使用都会发生在缓存上，只有极少数的请求才会穿透到底层的存储。通常这种设计，我们期望缓存层至少需要帮挡住 99% 的流量。既然缓存层能挡住 99% 的流量，那么实际的数据存储就可以交由源站点完成。</p><p>值得一提的是，在程序设计当中有一个核心的原则，叫作<strong>单一数据源（Single Souce of Truth， SSOT）。这个原则指的是，在程序设计中，应该尽可能地减少数据的来源，最好每个数据来源只有单独一份</strong>。这样能够避免大量的数据不一致以及同步数据的问题。</p><ul><li>基于这样的设计，谁来提供资源的存储呢？</li><li>谁来提供这个单一的数据源呢？当然是服务提供者本身。如果 CDN 再提供 一份资源的存储，不就有两个数据源了吗？而且，只有服务的提供者才能更好地维护这个资源仓库。</li></ul><p>在 CDN 的设计当中，<strong>CDN 实际上提供的是数据的缓存。而原始数据，则由服务的提供者提供</strong>。</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/digcdn.png" alt="dig" /></p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/CDN3.png" alt="CDN" /></p><p><strong>用户请求静态资源通常用自己的域名（防止跨域和一些安全问题）</strong>。为了让用户请求的是自己的网站，而使用的是 CDN 的服务，这里会使用 CNAME 让自己的域名作为 CDN 域名的一个别名。当请求到 CDN 服务的时候，会首先由 CDN 的 DNS 服务帮助用户选择一个最优的节点，这个 DNS 服务还充当了负载均衡的作用。接下来，用户开始向 CDN 节点请求资源。<strong>如果这个时候资源已经过期或者还没有在 CDN 节点上，就会从源站读取数据，这个步骤称为CDN 的<code>回源</code></strong>。</p><p>另一方面，CDN 上缓存的资源通常也会伴随失效时间的设置，当失效之后同样会触发回源。另一种情况是可以通过开放的 API 或者 CDN 管理后台直接删除缓存（让资源失效），这个操作结束后，同样会触发回源。</p><blockquote><p>总结</p><p>CDN 是一种网络应用，作用是分发互联网上的资源。CDN 服务的提供商，会在世界（或国家）范围内设立数据中心，帮助分发资源。用户请求的资源会被 CDN 分发到最临近的节点获取。</p><p>CDN 作为一门生意，CDN 的服务商会大批量的从运营商处获取流量，然后再以较高但是可以接受的价格卖给服务提供方。</p><p>对于中小型互联网公司来说，购买一定的 CDN 流量成本可控，比如 1G 流量在 1 元以内。对于大型的互联网公司，特别是对 CDN 依赖严重的公司，可能还需要自己建设。比如 2021 年抖音每天分发的数据量在 50PB 左右（1PB=1024TB），如此庞大的数据量如果换算成钱是非常高的。按照阿里云的报价，<strong>50PB 的价格是 480W 人民币</strong>。按照这种体量计算，抖音每天要花 480W 人民币，一年是 17 亿。</p><p>所以当你设计一个内容分发的方案时，除了要考虑到其中的技术细节，也要从成本上进行思考，看看能不能从<strong>数据压缩、资源格式</strong>角度做一些文章。</p></blockquote><hr /><blockquote><p>问题： 请简述 CDN 回源是如何工作的？</p></blockquote><p>CDN 回源就是 CDN 节点到源站请求资源，重新设置缓存。通常服务提供方在使用 CDN 的时候，会在自己的某个域名发布静态资源，然后将这个域名交给 CDN。</p><p>比如源站在 <a href="http://s.example.com">s.example.com</a> 中发布静态资源，然后在 CDN 管理后台配置了这个源站。在使用 CDN 时，服务提供方会使用另一个域名，比如说 <a href="http://b.example.com">b.example.com</a>。然后配置将 <a href="http://b.example.com">b.example.com</a> 用 CNAME 记录指向 CDN 的智能 DNS。</p><p>这个时候，<a href="http://xn--b-mo6au08a0wijxgs1vje6b.example.com/a.jpg%EF%BC%8CCDN">如果用户下载b.example.com/a.jpg，CDN</a> 的智能 DNS 会帮用户选择一个最优的 IP 地址（最优的 CDN 节点）响应这次资源的请求。如果这个 CDN 节点没有 a.jpg，CDN 就会到 <a href="http://s.example.com">s.example.com</a> 源站去下载，缓存到 CDN 节点，然后再返回给用户。</p><p>CDN 回源有 3 种情况，</p><ul><li>一种是 CDN 节点没有对应资源时主动到源站获取资源；</li><li>另一种是缓存失效后，CDN 节点到源站获取资源；</li><li>还有一种情况是在 CDN 管理后台或者使用开放接口主动刷新触发回源。</li></ul><hr /><blockquote><p>如果你的应用需要智能 DNS 服务，你将如何实现？</p></blockquote><p>首先你可以在你的域名解析系统中增加两条（或以上）ns 记录。比如说你的域名是 <a href="http://example.com">example.com</a>，那么你可以增加 <a href="http://ns1.exmaple.com">ns1.exmaple.com</a>, <a href="http://ns2.example.com">ns2.example.com</a>。当然，指定这两个域名的 IP 还需要配置两个 A 记录。</p><p>然后你需要两台机器（也可以是容器或者虚拟机），对应 ns1 和 ns2。最好用不在同一个物理机上的两个容器，这样可以避免一台物理机故障导致服务瘫痪。然后在每个容器（虚拟机）上安装一个 Named 服务。</p><p>Named 是一个专门用来提供 DNS 服务的工具，在虚拟机上安装完成 Named 后，这个虚拟机就变成了一个权威服务器节点。</p><p>配置好 Named 后，你需要写几个脚本文件，给要提供 DNS 的域名配置信息。Named 配套使用的有个叫作 GeoDNS 的插件，可以提供基于地理位置的智能 DNS 服务。</p><h3 id="16-http协议面试通关强制缓存和协商缓存的区别是"><a class="markdownIt-Anchor" href="#16-http协议面试通关强制缓存和协商缓存的区别是"></a> <strong>16.  HTTP协议面试通关：强制缓存和协商缓存的区别是</strong></h3><p><strong>超文本传输协议（HyperText Transfer Protocol，HTTP）</strong> 是目前使用最广泛的应用层协议。</p><p>1990 年蒂姆·伯纳斯·李开发了第一个浏览器，书写了第一个 Web 服务器程序和第一张网页。网页用的语言后来被称作超文本标记语言（HTML），而在服务器和客户端之间传输网页的时候，伯纳斯·李没有直接使用传输层协议，而是在 TCP 的基础上构造了一个应用层协议，这个就是超文本传输协议 HTTP。</p><p><strong>万维网（World Wide Web， WWW）</strong> 是伯纳斯·李对这一系列发明，包括 Web 服务、HTTP 协议、HTML 语言等一个体系的综合。</p><p><strong>请求响应和长连接</strong></p><p><strong>HTTP 协议采用请求/返回模型</strong>。客户端（通常是浏览器）发起 HTTP 请求，然后 Web 服务端收到请求后将数据回传。</p><p><strong>HTTP 的请求和响应都是文本，可以简单认为 HTTP 协议利用 TCP 协议传输文本</strong>。当用户想要看一张网页的时候，就发送一个文本请求到 Web 服务器，Web 服务器解析了这段文本，然后给浏览器将网页回传。</p><p>那么这里有一个问题，是不是每次发送一个请求，都建立一个 TCP 连接呢？ 当然不能这样，<strong>为了节省握手、挥手的时间。当浏览器发送一个请求到 Web 服务器的时候，Web 服务器内部就设置一个定时器。在一定范围的时间内，如果客户端继续发送请求，那么服务器就会重置定时器。如果在一定范围的时间内，服务器没有收到请求，就会将连接断开。这样既防止浪费握手、挥手的资源，同时又避免一个连接占用时间过长无法回收导致内存使用效率下降</strong>。</p><p>这个能力可以利用 HTTP 协议头进行配置，比如下面这条请求头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Keep-Alive: timeout&#x3D;5s</span><br></pre></td></tr></table></figure><p>会告诉 Web 服务器连接的持续时间是 5s，如果 5s 内没有请求，那么连接就会断开。</p><hr /><p>Keep-Alive 并不是伯纳斯·李设计 HTTP 协议时就有的能力。伯纳斯·李设计的第一版 HTTP 协议是 0.9 版，后来随着协议逐渐完善，有了 1.0 版。而 Keep-Alive 是 HTTP 1.1 版增加的功能，目的是应对越来越复杂的网页资源加载。从 HTTP 协议诞生以来，网页中需要的资源越来越丰富，打开一张页面需要发送的请求越来越多，于是就产生了 Keep-Alive 的设计。</p><p>同样，当一个网站需要加载的资源较多时，浏览器会尝试并发发送请求（利用多线程技术）。浏览器会限制同时发送并发请求的数量，通常是 6 个，这样做一方面是对用户本地体验的一种保护，防止浏览器抢占太多网络资源；另一方面也是对站点服务的保护，防止瞬时流量过大。</p><p>在 HTTP 2.0 之后，增加了多路复用能力。和 RPC 框架时提到的多路复用类似，请求、返回会被拆分成切片，然后混合传输。这样请求、返回之间就不会阻塞。你可以思考，对于一个 TCP 连接，在 HTTP 1.1 的 Keep-Alive 设计中，第二个请求，必须等待第一个请求返回。如果第一个请求阻塞了，那么后续所有的请求都会阻塞。而 <strong>HTTP 2.0 的多路复用，将请求返回都切分成小片，这样利用同一个连接，请求相当于并行的发出，互相之间不会有干扰。</strong></p><hr /><p><strong>HTTP 方法和 RestFul 架构</strong></p><p>伴随着 HTTP 发展，也诞生了一些著名的架构，比如 RestFul。在面试中，经常会遇到 RestFul，RestFul 是 3 个单词的合并缩写：</p><ul><li>Re（Representational）</li><li>st（State）</li><li>Ful（Transfer）</li></ul><p>这个命名非常有趣，让我联想到 <strong>grep 命令的命名，global regular pattern match</strong>。这是一种非常高端的命名技巧，提取词汇中的一个部分组合成为一个读起来朗朗上口的新词汇，建议在实战命名的时候也可以考虑试试。</p><p><strong>在 RestFul 架构中，状态仅仅存在于服务端，前端无状态。</strong></p><ul><li>状态（State）可以理解为业务的状态，这个状态是由服务端管理的。这个无状态和服务端目前倡导的无状态设计不冲突，现在服务端倡导的无状态设计指的是容器内的服务没有状态，状态全部存到合适的存储中去。所以 Restful 中的 State，是服务端状态。</li></ul><p><strong>前端（浏览器、应用等）没有业务状态，却又要展示内容，因此前端拥有的是状态的表示，也就是 Representation。</strong></p><ul><li>比如一个订单，状态存在服务端（数据库中），前端展示订单只需要部分信息，不需要全部信息。前端只需要展示数据，展示数据需要服务端提供。所以服务端提供的不是状态，而是状态的表示。</li></ul><p>前端没有状态，当用户想要改变订单状态的时候，比如支付，这个时候前端就向服务端提交表单，然后服务端触发状态的变化。这个过程我们称为转化（Transfer）。从这个角度来看，<strong>Restful 讲的是一套前端无状态、服务端管理状态，中间设计转化途径（请求、函数等）的架构方法</strong>。这个方法可以让前后端职责清晰，前端负责渲染， 服务端负责业务。前端不需要业务状态，只需要展示。服务端除了关心状态，还要提供状态的转换接口</p><p><strong>缓存</strong><br />在 HTTP 的使用中，我们经常会遇到两种缓存，强制缓存和协商缓存，接下来举两个场景来说明。</p><ul><li><strong>强制缓存</strong><ul><li>举个例子： 公司用版本号管理某个对外提供的 JS 文件。比如说 libgo.1.2.3.js，就是 libgo 的 1.2.3 版本。其中 1 是主版本，2 是副版本，3 是补丁编号。每次你们有任何改动，都会更新 libgo 版本号。在这种情况下，当浏览器请求了一次 libgo.1.2.3.js 文件之后，还需要再请求一次吗？</li><li>整理下我们的需求，浏览器在第一次进行了GET /libgo.1.2.3.js这个操作后，如果后续某个网页还用到了这个文件（libgo.1.2.3.js），我们不再发送第二次请求。这个方案要求浏览器将文件缓存到本地，并且设置这个文件的失效时间（或者永久有效）。这种<strong>请求过一次不需要再次发送请求的缓存模式，在 HTTP 协议中称为强制缓存</strong>。当一个文件被强制缓存后，下一次请求会直接使用本地版本，而不会真的发出去。</li><li>使用强制缓存时要注意，千万别把需要动态更新的数据强制缓存。一个负面例子就是小明把获取用户信息数据的接口设置为强制缓存，导致用户更新了自己的信息后，一直要等到强制缓存失效才能看到这次更新。</li></ul></li><li><strong>协商缓存</strong><ul><li>我们再说一个场景：小明开发了一个接口，这个接口提供全国省市区的 3 级信息。先问你一个问题，这个场景可以用强制缓存吗？小明一开始觉得强制缓存可以，然后突然有一天接到运营的通知，某市下属的两个县合并了，需要调整接口数据。小明错手不急，更新了接口数据，但是数据要等到强制缓存失效。</li><li><strong>为了应对这种场景，HTTP 协议还设计了协商缓存。协商缓存启用后，第一次获取接口数据，会将数据缓存到本地，并存储下数据的摘要。第二次请求时，浏览器检查到本地有缓存，将摘要发送给服务端。服务端会检查服务端数据的摘要和浏览器发送来的是否一致。如果不一致，说明服务端数据发生了更新，服务端会回传全部数据。如果一致，说明数据没有更新，服务端不需要回传数据</strong>。</li><li><strong>从这个角度看，协商缓存的方式节省了流量。对于小明开发的这个接口，多数情况下协商缓存会生效。当小明更新了数据后，协商缓存失效，客户端数据可以马上更新。和强制缓存相比，协商缓存的代价是需要多发一次请求</strong>。</li></ul></li></ul><blockquote><p>总结</p><p>目前 HTTP 协议已经发展到了 2.0 版本，不少网站都更新到了 HTTP 2.0。大部分浏览器、CDN 也支持了 HTTP 2.0。 可以自行查阅更多关于 <strong>HTTP 2.0 解决队头阻塞、HPack 压缩算法、Server Push 等资料</strong>。</p><p>另外 HTTP 3.0 协议也在建设当中，HTTP 3.0 对 HTTP 2.0 兼容，主要调整发生在网络底层。<strong>HTTP 3.0 开始采用 UDP 协议，并在 UDP 协议之上，根据 HTTP 协议的需求特性，研发了网络层、应用层去解决可靠性等问题</strong>。</p></blockquote><h3 id="17-流媒体技术直播网站是如何实现的"><a class="markdownIt-Anchor" href="#17-流媒体技术直播网站是如何实现的"></a> <strong>17.  流媒体技术：直播网站是如何实现的</strong></h3><p>如何将视频抽象成流？就是传输一部分即可播放一部分</p><ul><li>在实际的操作当中，设计了一种类似目录的格式，将音频数据进行切片，这部分能力利用现有的工具<strong>FFmpeg</strong>就可以轻松做到，安装FFmpeg，利用如下指令处理一个mp4，就可以生成很多切片（切割成HTTP Live Streaming可以播放的切片）和一个目录文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -c:v libx264 -c:a aac -strict -2 -fhls output.m3u8</span><br><span class="line">ls # 可查看目录文件，下载视频时可根据&#96;.m3u8&#96;内容下载对应的&#96;.ts&#96;文件</span><br></pre></td></tr></table></figure><p>流媒体的架构</p><ul><li>视频录制得到MP4等格式的文件</li><li>上传到服务器进行编码[编码产生不同清晰度文件]，产生上述切片文件</li><li>切片文件存储到流媒体服务器中</li><li>然后从视频目录读取</li></ul><p>直播</p><ul><li>录制吨不断上传视频内容</li><li>视频内容编码后由流媒体服务器负责分发</li><li>如果观看人数较多，可以使用CDN回源到流媒体服务器</li><li>m3u8文件可以看作一个动态的文件，能够不断产生新的数据，<strong>因此直播技术中，可以将获取m3u8文件设计成一个接口，不断由播放器获取新的m3u8文件</strong></li></ul><p>其他音视频网站</p><ul><li>将视频编码后切片</li><li>然后利用CDN分发目录和切片文件，就可以播放了</li></ul><p>视频的编码和解码</p><ul><li>视频文件较大，因此在传输前需要压缩</li><li>在播放前需要解码</li></ul><blockquote><p>视频的压缩技术：是针对视频的特征进行特别处理的压缩技术，视频的压缩算法本质上是对图片的压缩，主要依靠人类视觉的残留效应</p></blockquote><p><strong>H264</strong> 就是国际标准化组织在推广的一种编码格式。在 H264 的视频编码技术中，有一个叫作<strong>宏块</strong>的概念。宏块，就是将画面分成大小不等的区域。比如说 8x8、16x16 等。当播放两个连续的画面的时候，你可以理解成两张图片。如果基于图片分析，那么播放的就是很多个宏块。在这连续的两帧画面中，并不是所有的宏块都发生了变化。</p><p><strong>点到点视频技术</strong></p><p>在视频会议、面对面聊天等场景下，需要点到点的视频技术</p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/videoh2h.png" alt="videoh2h" /></p><p>如果是1对1的视频聊天，可以考虑点到点的服务</p><ul><li>Host1 &lt;–(UDP等)–&gt; Host2</li></ul><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/videoh2h1.png" alt="videoh2h2" /><br />在NAT通信中，往往需要在内网的主机发起连接，这个时候NAT模块识别发起的端口并记录。如上图，如果客户是公网IP，Host1可以找到该客户建立连接，但是客户是无法主动连接Host1</p><p>如下图，如果双方都在内网，都需要NAT场景，就无法建立连接。Host1 发送请求但由于客户没有建立连接而被拒绝，反之亦然，类似多线程的死锁问题无法解决。这是就需要第三方服务器，这台服务器可以作，为NAT模块辅助功能，让双方的NAT模块以为和对方发起过连接请求，这个解决方案叫做<strong>NAT穿透</strong></p><p><img src="https://ganshizhong.gitee.io/blogimages/NetWorking/videoh2h2.png" alt="videoh2h2" /></p><p>在WebRTC协议中，可以提供网页版的1对1聊天，如果需要连接两个内网的机器，就需要架设第三方服务。</p><p>如果在线会议，人数较少可以点到点，但人数较多就需要考虑以下方案：</p><ul><li>放弃点到点技术，直接采用类似直播架构的中心化服务</li><li>利用边缘计算，让距离相近的参会者利用共同的离自己最近的服务器交换数据</li></ul><blockquote><p>总结<br />流媒体，就是把多媒体数据抽象成为流进行传输。视频本质上是一张张图片在播放，因此非常适合流传输。要知道，流是随着时间产生的数据。</p><p>通常在一个网络中，<strong>等价成本下吞吐量、丢包率和延迟 3 者不能兼得</strong>。</p><p><strong>对延迟要求较高的场景，可能需要降低视频质量或者部署边缘服务器</strong></p><p>人数较少，可以采用点对点技术，但是要考虑NAT穿透问题</p></blockquote><hr /><blockquote><p>问题： 直播网站是如何实现的</p></blockquote><ul><li>录制端： 负责录制视频直播视频，用流的形式上传</li><li>计算集群：专门负责编码上传的流数据，然后进行压缩、转码、切片等工作</li><li>对象存储：存储原视频和转码后的视频（相当于CDN的源，回源用）</li><li>CDN: 将转码后的内容分发到离用户较近的节点，方便用户获取</li><li>直播APP：给用户看直播时使用</li></ul><hr /><blockquote><p>作业：写一张网页：用webrtc实现点到点通信</p></blockquote><h3 id="18-爬虫和反爬虫如何防止黑产爬取我的数据"><a class="markdownIt-Anchor" href="#18-爬虫和反爬虫如何防止黑产爬取我的数据"></a> <strong>18.  爬虫和反爬虫：如何防止黑产爬取我的数据</strong></h3><p>反爬虫的手段主要有：robots.txt、用户识别、字符加密算法、数据加密算法。</p><p>robots.txt文件规定哪些数据可以爬虫、哪些不可以爬虫；</p><p>针对自己账号范围实现某个功能，如对建立筛选，不属于违法行为；</p><p>爬虫的原理：本质上就是一次网络请求，然后将返回的数据保存下来</p><p>对于搜索引擎的爬虫而言，通常会在请求头中加上自己的标识，比如百度会加上baidu字符串，这样方便网站服务器识别。</p><p>爬虫如果是非法的，往往就需要伪装成浏览器，通常会用到浏览器内核，模拟发出网络请求、</p><p>chronium(Chrome的开源内核)</p><ul><li>用chronium发请求的时候，对于服务提供方的反爬虫系统，请求就变成了一次标准的用户行为，如果对方网站需要登陆才能爬取数据，不法分子还会模拟登陆行为。如果仅仅输入用户名和密码，那这个网站的登陆行为非常容易模拟，只需要找到对应的接口，用户和密码传输过去，就可以拿到访问资源的令牌</li></ul><p>验证码–通过深度学习模型训练图片，进行识别；更难的就是加滑块</p><p>模拟用户动作</p><p>将原始数据存储，然后进行分析</p><p>如果爬取网页数据，后续会用到HTML解析器(Parser)</p><p>如果爬取的接口数据，通常就是分析json</p><p>IP的反追踪，就是利用代理，增加追踪的成本。可以通过大量购买IP然后模拟多用户攻击【临时租用大量的IP地址的价格低廉，降低犯罪成本】</p><p>反爬虫基本操作</p><ul><li><strong>robots.txt</strong> 从法律上告诉爬虫哪些页面是不可爬取的</li><li>用户识别<ul><li><strong>对高频访问的IP加以限制</strong>，但有时候有些公司共用一个IP出口，也不是很有效</li><li><strong>设备指纹</strong>:利用设备上的信息，生成一个具有唯一性的字符串，这种算法是非标准化的，因此不同的数据安全团队会有自己的算法，比限制IP好</li><li>根据唯一用户设置数据安全策略，访问频次，黑名单等</li></ul></li><li><strong>字体加密</strong>, 爬虫爬取的通常就是用户本身可以看到的内容，将UTF8编码中的汉字顺序打乱，然后将对应的数据换序。</li><li><strong>加密传输</strong> APP的数据抓取依赖APP数据传输使用的标准协议，比如用HTTPS协议传输数据的App,爬虫可以在App端安装证书，然后利用代理实现中间人抓包。如果数据用自己的协议加密，抓包的同时，必须破解这个加密协议</li></ul><h2 id="网络安全"><a class="markdownIt-Anchor" href="#网络安全"></a> 网络安全</h2><ul><li>基础设施（证书、加解密、公私钥体系、信任链等）</li><li>具体的攻击手段（DDos、XSS、SQL注入、ARP攻击、中间人攻击等）</li><li>防御手段</li></ul><h3 id="19-网络安全概述对称-非对称加密的区别"><a class="markdownIt-Anchor" href="#19-网络安全概述对称-非对称加密的区别"></a> <strong>19. 网络安全概述：对称、非对称加密的区别</strong></h3><ul><li><p>对称加密：数据加密标准（DES）算法在 1976 年被美国国家标准局定为使用标准，DES 采用的 56 位密钥，每次计算加密 64 位的数据，目前已经被证明可以被暴力破解，<strong>所谓<code>暴力破解</code>，就是遍历所有可能的密钥解析数据的方法</strong>；为了应对暴力破解等问题，很多团队选择对称加密算法时开始使用高级加密标准（AES），这个加密法用 128 位密钥，并设计了更难破解的算法。</p></li><li><p>非对称加密：目前最常见且广泛使用的非对称加密算法是 RSA 算法。RSA 依赖的是大整数的分解，以及一些和素数相关的算法。目前没有理论可以破译 RSA 算法。总体来说，RSA 密钥越长破解成本就越高，因此仍然被广泛使用。</p></li><li><p>对称加密和解密可以用同一套秘钥</p></li><li><p>非对称加密利用数学的方法生成公私钥对，公钥加密的数据私钥可以解密，私钥加密的数据公钥可以解密</p></li><li><p>公钥不能解密公钥加密的数据，私钥也不能解密私钥加密的数据</p></li></ul><h3 id="20-信任链为什么可以相信一个https网站"><a class="markdownIt-Anchor" href="#20-信任链为什么可以相信一个https网站"></a> <strong>20.  信任链：为什么可以相信一个HTTPS网站</strong></h3><p>当用户用浏览器打开一个 HTTPS 网站时，会到目标网站下载目标网站的证书。接下来，浏览器会去验证证书上的签名，一直验证到根证书。如果根证书被预装，那么就会信任这个网站。也就是说，网站的信用是由操作系统的提供商、根证书机构、中间证书机构一起在担保。</p><p>摘要和签名</p><ul><li>MD5</li><li>SHA-1 摘要算法</li></ul><p>摘要是一种数学证明</p><p>在摘要上用私钥加密就是<strong>签名</strong>，签名可以防止数据被篡改、伪造等</p><p>在摘要和签名的基础上，可以利用原本的社会关系，让一些信用优秀的结构提供信用</p><h3 id="21-攻防手段介绍如何低于syn拒绝攻击"><a class="markdownIt-Anchor" href="#21-攻防手段介绍如何低于syn拒绝攻击"></a> <strong>21.  攻防手段介绍：如何低于SYN拒绝攻击</strong></h3><p><strong>DDoS</strong></p><p>拒绝服务攻击(Denial of Service Attack, DoS)，利用大量的流量迅速向一个网站发送出去，攻击者一般没有足够的经济实力购买机器，利用中病毒、木马的肉机组织流量攻击，这种方式也被称为分布式拒绝服务攻击(Distributed Denial of Service Attack, DDoS)</p><ul><li>直接不停发送Ping消息的，利用底层的ICMP协议，称为<strong>ICMP攻击</strong></li><li>走UDP协议的，称为**UDP洪水(UDP Flood)</li><li>不停的用TCP协议发送SYN消息的，也叫SYN攻击</li></ul><p>防范措施：</p><ul><li><strong>防火墙</strong>根据特征识别出攻击行为，通过这样的方式将攻击行为过滤掉，让系统不会因为DDos而过载造成崩溃</li><li><strong>切换流量</strong>，从日常生产环境-同城灾备环境-异地灾备环境</li><li><strong>CDN</strong> 是大量缓存节点，DDoS攻击CDN的时候用不上力<ul><li>设计一台吞吐量极高的代理服务器，作为反向代理挡在所有服务器前面，如果遇到DDoS，代理服务器可以识别出一些特征并丢弃一些流量</li></ul></li></ul><p>在遇到攻击的时候，对服务适当降级也是有必要的，<strong>通过允许防火墙造成一部分的误伤来识别更多的攻击流量</strong></p><p>前端框架 React和 Vue开发基本杜绝XSS攻击</p><hr /><p><strong>中间人攻击</strong></p><p>不法分子利用自己的伪装基站设备伪装成基站</p><hr /><p><strong>跨站脚本攻击(XSS)</strong></p><p>跨站脚本(Cross Site Scripting)，利用漏洞将脚本注入网页，例如提交个人信息的输入框，如果在服务端没有处理好，就可能出发夸张脚本攻击</p><hr /><p>如何抵御 SYN 拒绝攻击？</p><ul><li>SYN 攻击是 DDoS 攻击的一种形式。这种形式攻击者伪装成终端不停地向服务器发起 SYN 请求。</li><li>通常攻击者的“肉鸡”，发送了 SYN 之后，不等给服务端 ACK，就下线了。</li><li>这样攻击者不断发送 SYN ，然后下线，而服务端会等待一段时间（通常会在 3s 以上），等待 ACK。这样就导致了大量的连接对象在服务端被积累。</li></ul><p>针对这个特点，可以实现TCP代理(防火墙)</p><blockquote><p>哪些情况服务器的/etc/passwd文件会被黑客拿走</p></blockquote><h2 id="漫游互联网-什么是蜂窝移动网络"><a class="markdownIt-Anchor" href="#漫游互联网-什么是蜂窝移动网络"></a> 漫游互联网： 什么是蜂窝移动网络</h2><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考：</h2><p><a href="https://www.bilibili.com/video/BV1B34y1e7kU?p=8&amp;spm_id_from=pageDriver&amp;vd_source=27f6135965c74480fdc752d98427d3b2">https://www.bilibili.com/video/BV1B34y1e7kU?p=8&amp;spm_id_from=pageDriver&amp;vd_source=27f6135965c74480fdc752d98427d3b2</a></p><p><a href="https://cloud.tencent.com/developer/article/1862663">https://cloud.tencent.com/developer/article/1862663</a></p><p><a href="https://www.cnblogs.com/jmcui/p/15003579.html#top">https://www.cnblogs.com/jmcui/p/15003579.html#top</a></p><p>非常好的网络基础教程：<a href="https://docs.oracle.com/cd/E19253-01/819-7058/oviewtm-1/index.html">https://docs.oracle.com/cd/E19253-01/819-7058/oviewtm-1/index.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;应用程序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#应用程序&quot;&gt;&lt;/a&gt; 应用程序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;计算机组成原理
&lt;ul&gt;
&lt;li&gt;描述计算机是什么？计算是怎么回事？硬件如何为应用提供计算？&lt;/li&gt;
&lt;/ul&gt;
&lt;/</summary>
      
    
    
    
    <category term="Networking" scheme="http://shizhonggan.github.io/categories/Networking/"/>
    
    
    <category term="Networking" scheme="http://shizhonggan.github.io/tags/Networking/"/>
    
  </entry>
  
  <entry>
    <title>Shell编程学习</title>
    <link href="http://shizhonggan.github.io/2022/05/30/Shell/shell/"/>
    <id>http://shizhonggan.github.io/2022/05/30/Shell/shell/</id>
    <published>2022-05-30T07:54:23.000Z</published>
    <updated>2022-05-31T08:22:22.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="shell-概述"><a href="#shell-概述" class="headerlink" title="shell 概述"></a>shell 概述</h2><p>命令行解释器 </p><p>硬件 -&gt; Linux 内核 -&gt; shell (cd, ls, …) -&gt; 外层应用程序。</p><h2 id="shell-解析器"><a href="#shell-解析器" class="headerlink" title="shell 解析器"></a>shell 解析器</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linux提供的shell解析器有：</span></span><br><span class="line">[ec2-user@master bin]$ cat /bin/shell </span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/usr/bin/sh</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/usr/bin/tmux</span><br><span class="line"></span><br><span class="line">[ec2-user@master bin]$ ll |grep bash</span><br><span class="line">-rwxr-xr-x  1 root root    964608 Oct 31  2018 bash</span><br><span class="line">lrwxrwxrwx  1 root root        10 Feb 26  2019 bashbug -&gt; bashbug-64</span><br><span class="line">-rwxr-xr-x  1 root root      6964 Oct 31  2018 bashbug-64</span><br><span class="line">lrwxrwxrwx  1 root root         4 Feb 26  2019 sh -&gt; bash</span><br></pre></td></tr></table></figure><p>可以看出sh也用的bash解析器</p><h2 id="shell-脚本入门"><a href="#shell-脚本入门" class="headerlink" title="shell 脚本入门"></a>shell 脚本入门</h2><p>脚本格式，如下，开头指定解析器，不是注释</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure><p>初识shell脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@master <span class="built_in">test</span>]$ touch helloworld.sh <span class="comment"># 创建第一个shell脚本</span></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ vi helloworld.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world, ganshizhong&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 执行脚本的三种方式</span></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ sh helloworld.sh</span><br><span class="line">hello world, ganshizhong</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ bash helloworld.sh</span><br><span class="line">hello world, ganshizhong</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ ./helloworld.sh</span><br><span class="line">-bash: ./helloworld.sh: Permission denied</span><br><span class="line"><span class="comment"># 第三种要给权限，如下操作</span></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ ll</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r-- 1 ec2-user ec2-user 44 May 30 14:39 helloworld.sh</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ chmod 777 helloworld.sh <span class="comment"># 赋予+x权限</span></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ ll</span><br><span class="line">total 4</span><br><span class="line">-rwxrwxrwx 1 ec2-user ec2-user 44 May 30 14:39 helloworld.sh</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ ./helloworld.sh</span><br><span class="line">hello world, ganshizhong</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">cd &#x2F;home&#x2F;ec2-user&#x2F;test&#x2F;</span><br><span class="line">touch test1.txt</span><br><span class="line">echo &quot;i love you&quot; &gt;&gt; test1.txt</span><br></pre></td></tr></table></figure><h2 id="shell中的变量"><a href="#shell中的变量" class="headerlink" title="shell中的变量"></a>shell中的变量</h2><h3 id="1-常用变量-HOME-PWD-SHELL-USER等"><a href="#1-常用变量-HOME-PWD-SHELL-USER等" class="headerlink" title="1. 常用变量: $HOME, $PWD, $SHELL, $USER等"></a>1. 常用变量: $HOME, $PWD, $SHELL, $USER等</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$HOME</span>, <span class="variable">$PWD</span>, <span class="variable">$SHELL</span>, <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><h3 id="2-自定义变量"><a href="#2-自定义变量" class="headerlink" title="2. 自定义变量"></a>2. 自定义变量</h3><ol><li>基本语法<ul><li>定义变量：变量=值</li><li>撤销变量：unset 变量</li><li>声明静态变量： readonly变量，注意不能unset</li></ul></li><li>变量定义规则<ul><li>变量可由字母、数字和下划线组成，但不能以数字开头，<strong>环境变量建议大写</strong></li><li><strong>等号两侧不能有空格</strong></li><li>在bash中，<strong>变量默认类型都是字符串类型，无法直接进行数值计算</strong></li><li>变量的值如果有空格，需要使用双引号或单引号括起来</li></ul></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A=1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$A</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> A</span><br><span class="line"></span><br><span class="line"><span class="built_in">readonly</span> B=3</span><br><span class="line"><span class="built_in">unset</span> B <span class="comment"># 不生效</span></span><br><span class="line"></span><br><span class="line">D=<span class="string">&quot;I love gsz&quot;</span></span><br><span class="line"><span class="built_in">echo</span> D</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把变量提升到全局变量，供其他shell程序使用</span></span><br><span class="line"><span class="built_in">export</span> 变量名</span><br></pre></td></tr></table></figure><h3 id="3-特殊变量"><a href="#3-特殊变量" class="headerlink" title="3. 特殊变量"></a>3. 特殊变量</h3><p><strong>$n</strong></p><ul><li>功能描述：n为数字，$0代表该脚本名称，$1-$9代表第一到第九个参数，十以上的参数需要用大括号，如 ${10}</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@master <span class="built_in">test</span>]$ vi parameter.sh</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ sh parameter.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$0</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;$*&quot;</span></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ sh parameter.sh  gsz a aa  aaaa</span><br><span class="line">parameter.sh</span><br><span class="line">gsz a aa</span><br></pre></td></tr></table></figure><p><strong>$#</strong></p><ul><li>功能描述：获取所有输入参数个数，常用循环</li></ul><p><strong>$</strong>*</p><ul><li>功能描述：表示命令行中所有的参数，并把所有参数看作一个整体</li></ul><p><strong>$@</strong></p><ul><li>功能描述：表示命令行中所有的参数，但区分对待每个参数</li></ul><p><strong>$?</strong></p><ul><li>功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0，则不正确。</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>基本语法</p><ul><li>“$((运算式))” 或 “$[运算式]”</li><li>expr +,-,*,/,% 加减乘除取余<blockquote><p>expr运算符间要有空格</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@master <span class="built_in">test</span>]$ expr 3 + 2</span><br><span class="line">5</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ expr `expr 2 + 3` \* 4</span><br><span class="line">20</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ expr `expr 2 + 3` \* 4</span><br><span class="line">20</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ s=$[(2+3)*4]</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ <span class="built_in">echo</span> <span class="variable">$s</span></span><br><span class="line">20</span><br></pre></td></tr></table></figure></li></ul><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ol><li><p>基本语法</p><ul><li>[ condition ]<blockquote><p><strong>注意前后要有空格</strong>，条件非空即为true，[atguigu]返回true,[]返回false.</p></blockquote></li></ul></li><li><p>常用判断条件</p><ul><li>两个整数之间比较<ul><li>=字符串比较</li><li>-lt 小于(less than)</li><li>-le 小于等于(less equal)</li><li>-eq 等于(equal)</li><li>-gt 大于(greater than)</li><li>-ge 大于等于(greater equal)</li><li>-ne 不等于(not equal)</li></ul></li><li>按照文件权限进行判断<ul><li>-r 有读写权限(read)</li><li>-w 有写的权限（write)</li><li>-x 有执行的权限(execute)</li></ul></li><li>按照文件类型进行判断<ul><li>-f 文件存在且是一个常规的文件（file）</li><li>-e 文件存在(existence)</li><li>-d 文件存在并且是一个目录(directory)</li></ul></li><li>多条件判断<ul><li>&amp;&amp; 表示前面一条执行成功，才执行后一条命令</li><li>|| 表示上一条命令执行失败后，才执行下一条命令</li></ul></li></ul></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@master <span class="built_in">test</span>]$ [23 -ge 22]</span><br><span class="line">-bash: [23: <span class="built_in">command</span> not found</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ [ 23 -ge 22 ]</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ [ 23 -le 22 ]</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ [ -w helloworld.sh ]</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ [ 23 -ge 22 ] &amp;&amp; <span class="built_in">echo</span> ok</span><br><span class="line">ok</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ [ 23 -ge 22 ] &amp;&amp; [ ] || <span class="built_in">echo</span> notok</span><br><span class="line">notok</span><br></pre></td></tr></table></figure><h2 id="流程控制（重点）"><a href="#流程控制（重点）" class="headerlink" title="流程控制（重点）"></a>流程控制（重点）</h2><h3 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h3><ol><li>基本语法<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件判断式子 ];<span class="keyword">then</span></span><br><span class="line">   程序</span><br><span class="line"><span class="keyword">elif</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">if</span> [ 条件判断式 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   程序</span><br><span class="line"><span class="keyword">if</span></span><br></pre></td></tr></table></figure><blockquote><p>if后必须有空格</p></blockquote></li><li>例子<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$1</span> -eq 1 ];<span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;ganshizhong is handsome&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$1</span> -eq 2 ];<span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;ganshizhong&quot;</span></span><br><span class="line"><span class="keyword">if</span> </span><br></pre></td></tr></table></figure></li></ol><h3 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a>case 语句</h3><ol><li>基本语法</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">case</span> 值 <span class="keyword">in</span></span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><ol start="2"><li>例子</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">1) </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;print 1&quot;</span></span><br><span class="line">   ;;</span><br><span class="line">2)</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;print 2&quot;</span></span><br><span class="line">   ;;</span><br><span class="line">*) </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;print other&quot;</span></span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><ol><li>基本语法</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((初始值;循环控制条件;变量变化))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   程序</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ol start="2"><li>例子</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">s=0</span><br><span class="line"><span class="keyword">for</span> ((i=1;i&lt;=100;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   s=$[<span class="variable">$s</span>+<span class="variable">$i</span>] </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$s</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">s=0</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ sh for2.sh 1 2 23</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">23</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">s=0</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ sh for2.sh <span class="string">&quot;1 2 23&quot;</span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">23</span><br></pre></td></tr></table></figure><blockquote><p>此处应该注意’$*’和’$@’之间的区别</p></blockquote><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><ol><li>基本语法</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ 条件判断式 ]</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">   程序</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ol start="2"><li>例子</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/bin/bash</span></span><br><span class="line">s=0</span><br><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -le 100 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   s=$[<span class="variable">$i</span>+<span class="variable">$s</span>]</span><br><span class="line">   i=$[<span class="variable">$i</span>+1]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$s</span></span><br></pre></td></tr></table></figure><blockquote><p>条件中 只能用 -le 不能用 &lt;=</p></blockquote><h2 id="read读取控制台输入"><a href="#read读取控制台输入" class="headerlink" title="read读取控制台输入"></a>read读取控制台输入</h2><ol><li>基本语法</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(选项)(参数)</span><br><span class="line">选项：</span><br><span class="line">   -p: 指定读取值时的提示符</span><br><span class="line">   -t: 指定读取值时等待的时间（秒）</span><br><span class="line">参数：</span><br><span class="line">   变量：指定读取值的变量名</span><br></pre></td></tr></table></figure><ol start="2"><li>例子</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -t 7 -p <span class="string">&quot;Enter your name in 7 seconds: &quot;</span> NAME</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$NAME</span></span><br><span class="line"></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ sh read.sh</span><br><span class="line">Enter your name <span class="keyword">in</span> 7 seconds: ganshizhong</span><br><span class="line">ganshizhong</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li>系统函数basename 和 dirname</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">basename [string/pathname] [suffix] <span class="comment">#获取文件名</span></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ basename ./read.sh</span><br><span class="line">read.sh</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ basename ./read.sh .sh</span><br><span class="line"><span class="built_in">read</span></span><br></pre></td></tr></table></figure><blockquote><p>中括号都是可选参数</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dirname 文件绝对路径 <span class="comment"># 获取路径</span></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ dirname /home/ec2-user/<span class="built_in">test</span>/read.sh</span><br><span class="line">/home/ec2-user/<span class="built_in">test</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>自定函数</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname[()]</span><br><span class="line">&#123;</span><br><span class="line">   action;</span><br><span class="line">   [<span class="built_in">return</span> int;]</span><br><span class="line">&#125;</span><br><span class="line">funname</span><br></pre></td></tr></table></figure><blockquote><p>1)必须在调用之前声明函数，shell是逐行运行的，不会先编译</p><p>2)函数返回值，只能通过$?系统变量获得，可以显示加：return返回，如果不加，将以最后一条命令运行结果，作为返回值。return后跟数值n(0-255)</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> sum()</span><br><span class="line">&#123;</span><br><span class="line">   s=0;</span><br><span class="line">   s=$[<span class="variable">$1</span>+<span class="variable">$2</span>]</span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$s</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;input your parameter: &quot;</span> p1</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;input your parameter: &quot;</span> p2</span><br><span class="line">sum <span class="variable">$p1</span> <span class="variable">$p2</span></span><br><span class="line"></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ sh sumfunc.sh</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="shell工具-重点"><a href="#shell工具-重点" class="headerlink" title="shell工具(重点)"></a>shell工具(重点)</h2><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>在文件中负责剪切数据。cut命令从文件的每一行剪切字节、字符和字段并输出。</p><ol><li>基本用法</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">cut [选项参数] filename <span class="comment"># </span></span><br><span class="line">   -f: 列号，提取第几列</span><br><span class="line">   -d: 分隔符，按照指定分隔符分割列</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ cat cut.txt</span><br><span class="line">a b</span><br><span class="line">c d</span><br><span class="line">ee ff</span><br><span class="line">gg   hh</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ cut -d <span class="string">&quot; &quot;</span> -f 1,2 cut.txt</span><br><span class="line">a b</span><br><span class="line">c d</span><br><span class="line">ee ff</span><br><span class="line">gg</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ cat cut.txt |grep ff |cut -d <span class="string">&quot; &quot;</span> -f 1</span><br><span class="line">ee</span><br><span class="line"><span class="comment">## 切割环境变量</span></span><br><span class="line">[ec2-user@master ~]$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/opt/java/jdk1.8.0_271/bin:/opt/hadoop/hadoop-3.2.3/bin:/opt/hadoop/hadoop-3.2.3/sbin:/usr/<span class="built_in">local</span>/bin:/usr/bin:/usr/<span class="built_in">local</span>/sbin:/usr/sbin:/opt/java/jdk1.8.0_271/bin:/home/ec2-user/.<span class="built_in">local</span>/bin:/home/ec2-user/bin</span><br><span class="line">[ec2-user@master ~]$ <span class="built_in">echo</span> <span class="variable">$PATH</span>| cut -d : -f 3-</span><br><span class="line">/opt/hadoop/hadoop-3.2.3/sbin:/usr/<span class="built_in">local</span>/bin:/usr/bin:/usr/<span class="built_in">local</span>/sbin:/usr/sbin:/opt/java/jdk1.8.0_271/bin:/home/ec2-user/.<span class="built_in">local</span>/bin:/home/ec2-user/bin</span><br><span class="line"><span class="comment">## 切割ip</span></span><br><span class="line">[ec2-user@master ~]$ ifconfig eth0 |grep <span class="string">&quot;inet &quot;</span></span><br><span class="line">        inet 192.168.1.4  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">[ec2-user@master ~]$ ifconfig eth0 |grep <span class="string">&quot;inet &quot;</span>|cut  -d <span class="string">&quot;t&quot;</span> -f 2</span><br><span class="line"> 192.168.1.4  ne</span><br><span class="line">[ec2-user@master ~]$ ifconfig eth0 |grep <span class="string">&quot;inet &quot;</span>|cut  -d <span class="string">&quot;t&quot;</span> -f 2| cut -d<span class="string">&quot; &quot;</span> -f2</span><br><span class="line">192.168.1.4</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>缺点，cut只能切一个字符，如果存在很多空格，就会很麻烦</p></blockquote><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>sed是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，成为”模式空间”，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕中。接着处理下一行，这样不断重复，直到文件末尾。<strong>文件内容并没有改变</strong>，除非你使用重定向存储输出。</p><ol><li>基本用法</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sed [选项参数] <span class="string">&quot;command&quot;</span> filename </span><br><span class="line">   选项参数：</span><br><span class="line">      -e: 直接在指令列模式上进行sed的动作编辑</span><br><span class="line">   命令：</span><br><span class="line">      a: 新增，a的后面可以接字串，在下一行出现</span><br><span class="line">      d: 删除</span><br><span class="line">      s：查找并替换</span><br></pre></td></tr></table></figure><ol start="2"><li>案例</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 将&quot;xiao ming&quot;这个单词插入sed.txt第二行，打印。</span></span><br><span class="line">[ec2-user@master ~]$ cat sed.txt</span><br><span class="line">gan shizhong</span><br><span class="line">g sz</span><br><span class="line">[ec2-user@master ~]$ sed <span class="string">&quot;1a xiao ming&quot;</span> sed.txt</span><br><span class="line">gan shizhong</span><br><span class="line">xiao ming</span><br><span class="line">g sz</span><br><span class="line">[ec2-user@master ~]$ cat sed.txt</span><br><span class="line">gan shizhong</span><br><span class="line">g sz</span><br><span class="line"><span class="comment">## 删除&quot;g sz&quot;</span></span><br><span class="line">[ec2-user@master ~]$ sed <span class="string">&quot;/sz/d&quot;</span> sed.txt</span><br><span class="line">gan shizhong</span><br><span class="line">[ec2-user@master ~]$ cat sed.txt</span><br><span class="line">gan shizhong</span><br><span class="line">g sz</span><br><span class="line"><span class="comment">## 替换&quot;g sz&quot; 为 &quot;xiao ming&quot;</span></span><br><span class="line">[ec2-user@master ~]$ sed <span class="string">&quot;s/g sz/xiao ming/g&quot;</span> sed.txt <span class="comment"># g表示</span></span><br><span class="line">gan shizhong</span><br><span class="line">xiao ming</span><br><span class="line"><span class="comment">## 删除第1行，并将&quot;g sz&quot; 替换为&quot;gan sz&quot;</span></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ sed -e <span class="string">&quot;1d&quot;</span> -e <span class="string">&quot;s/g sz/gan sz/g&quot;</span> sed.txt</span><br><span class="line">gan sz</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>一个强大的文本分析工具，把文件逐行读取，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p><ol><li>基本用法<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk [选项参数] <span class="string">&quot;pattern1&#123;action1&#125; pattern2&#123;action2&#125; ...&quot;</span> filename</span><br><span class="line">   pattern: 表示AWK在数据中查找的内容，就是匹配模式</span><br><span class="line">   action: 在找到匹配内容时所执行的一系列命令,基本用<span class="built_in">print</span></span><br><span class="line">   选项参数</span><br><span class="line">      -F: 指定输入文件分析分隔符</span><br><span class="line">      -v: 复制一个用户定义变量 </span><br></pre></td></tr></table></figure></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/passwd ./</span><br><span class="line">sudo chown ec2-user:ec2-user passwd</span><br><span class="line"><span class="comment">## 搜索passwd文件以root关键字开头的所有行，并输出改行的第七列</span></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ awk -F : <span class="string">&#x27;/^root/&#123;print $7&#125;&#x27;</span> passwd</span><br><span class="line">/bin/bash</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ awk -F : <span class="string">&#x27;/^root/&#123;print $1,$7&#125;&#x27;</span> passwd</span><br><span class="line">root /bin/bash</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ awk -F : <span class="string">&#x27;/^root/&#123;print $1 $7&#125;&#x27;</span> passwd</span><br><span class="line">root /bin/bash</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ awk -F : <span class="string">&#x27;/^root/&#123;print $1&quot;,&quot;$7&#125;&#x27;</span> passwd</span><br><span class="line">root,/bin/bash</span><br><span class="line"><span class="comment">## 只显示第一列和第七列，以逗号隔开，且在所有行前面添加列名user,shell在最后一行添加&quot;gsz,/bin/gsz&quot;</span></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ awk -F : <span class="string">&#x27;BEGIN&#123;print &quot;user,shell&quot;&#125; &#123;print $1&quot;,&quot;$7&#125; END&#123;print &quot;gsz,/bin/gsz&quot;&#125;&#x27;</span> passwd</span><br><span class="line"><span class="comment">## passwd中用户id增加数值1并输出</span></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ awk -F : -v i=1 <span class="string">&#x27;&#123;print $3+i&#125;&#x27;</span> passwd</span><br></pre></td></tr></table></figure><blockquote><p><strong>此处要用单引号，单引号里的内容不可转义</strong></p><p>两个斜杠之间时正则表达式</p><p>BEGIN 是所有行前，END是所有行后</p></blockquote><ol start="3"><li>awk 内置变量</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILENAME 文件名</span><br><span class="line">NR 已读的记录数</span><br><span class="line">NF 浏览记录的个数（切割后，列的个数）</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 统计passwd文件中，每行的行号，每行的列数</span></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ awk -F : <span class="string">&#x27;&#123;print &quot;filename:&quot; FILENAME &quot;,linenumber:&quot; NR &quot;,columns:&quot; NF&#125;&#x27;</span> passwd</span><br><span class="line">filename:passwd,linenumber:1,columns:7</span><br><span class="line">filename:passwd,linenumber:2,columns:7</span><br><span class="line">filename:passwd,linenumber:3,columns:7</span><br><span class="line">...</span><br><span class="line"><span class="comment">## 切割IP</span></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ ifconfig eth0 |grep <span class="string">&quot;inet &quot;</span>|awk -F t <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>|awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print$1&#125;&#x27;</span></span><br><span class="line">192.168.1.4</span><br><span class="line"><span class="comment">## 查询sed.txt文件空行所在的行号</span></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ cat sed.txt</span><br><span class="line">gan shizhong</span><br><span class="line"></span><br><span class="line">g sz</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ awk <span class="string">&#x27;/^$/&#123;print NR&#125;&#x27;</span> sed.txt</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort命令实在Linu非常有用，他将文件进行排序，并将排序结果标准输出</p><ol><li>基本语法</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sort (选项) (说明)</span><br><span class="line">   -n: 依照数值大小排序</span><br><span class="line">   -r: 以相反的顺序来排序</span><br><span class="line">   -t: 设置排序时所用的分隔字符</span><br><span class="line">   -k: 指定排序的列</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@master <span class="built_in">test</span>]$ cat sort.sh</span><br><span class="line">bb:40:5.1</span><br><span class="line">bd:30:4.3</span><br><span class="line">xz:50:2.3</span><br><span class="line">cls:10:3.5</span><br><span class="line">ss:25:1.6</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ sort -t : -nrk 2 sort.sh</span><br><span class="line">xz:50:2.3</span><br><span class="line">bb:40:5.1</span><br><span class="line">bd:30:4.3</span><br><span class="line">ss:25:1.6</span><br><span class="line">cls:10:3.5</span><br></pre></td></tr></table></figure><h2 id="企业真实面试题（重点）"><a href="#企业真实面试题（重点）" class="headerlink" title="企业真实面试题（重点）"></a>企业真实面试题（重点）</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求列和</span></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ cat chengji.txt</span><br><span class="line">张三 40</span><br><span class="line">李四 50</span><br><span class="line">王五 60</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ cat chengji.txt | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;sum+=$2&#125; END&#123;print sum&#125;&#x27;</span> </span><br><span class="line">150</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查文件是否存在</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ -f file.txt ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;存在&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;不存在&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 排序</span></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ cat sort.txt</span><br><span class="line">9</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">8</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ sort -n sort.txt |awk <span class="string">&#x27;&#123;a+=$0;print$0&#125;END&#123;print &quot;SUM=&quot;a&#125;&#x27;</span></span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">SUM=50</span><br></pre></td></tr></table></figure><blockquote><p>awk里的变量可以添加可以不添加</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找当前文件夹中，所有的文本文件内容包含“gsz”的文件名称</span></span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ grep -r <span class="string">&quot;sz&quot;</span> /home/ec2-user/<span class="built_in">test</span></span><br><span class="line">/home/ec2-user/<span class="built_in">test</span>/sed.txt:g sz</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ grep -r <span class="string">&quot;shizhong&quot;</span> /home/ec2-user/<span class="built_in">test</span></span><br><span class="line">/home/ec2-user/<span class="built_in">test</span>/helloworld.sh:<span class="built_in">echo</span> <span class="string">&quot;hello world, ganshizhong&quot;</span></span><br><span class="line">/home/ec2-user/<span class="built_in">test</span>/if.sh:      <span class="built_in">echo</span> <span class="string">&quot;ganshizhong is handsome&quot;</span></span><br><span class="line">/home/ec2-user/<span class="built_in">test</span>/if.sh:      <span class="built_in">echo</span> <span class="string">&quot;ganshizhong&quot;</span></span><br><span class="line">/home/ec2-user/<span class="built_in">test</span>/sed.txt:gan shizhong</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ grep -r <span class="string">&quot;shizhong&quot;</span> ./</span><br><span class="line">./helloworld.sh:<span class="built_in">echo</span> <span class="string">&quot;hello world, ganshizhong&quot;</span></span><br><span class="line">./if.sh:        <span class="built_in">echo</span> <span class="string">&quot;ganshizhong is handsome&quot;</span></span><br><span class="line">./if.sh:        <span class="built_in">echo</span> <span class="string">&quot;ganshizhong&quot;</span></span><br><span class="line">./sed.txt:gan shizhong</span><br><span class="line">[ec2-user@master <span class="built_in">test</span>]$ grep -r <span class="string">&quot;shizhong&quot;</span> /home/ec2-user/<span class="built_in">test</span> |cut -d <span class="string">&quot;:&quot;</span> -f 1</span><br><span class="line">/home/ec2-user/<span class="built_in">test</span>/helloworld.sh</span><br><span class="line">/home/ec2-user/<span class="built_in">test</span>/if.sh</span><br><span class="line">/home/ec2-user/<span class="built_in">test</span>/if.sh</span><br><span class="line">/home/ec2-user/<span class="built_in">test</span>/sed.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="正则表达语法"><a href="#正则表达语法" class="headerlink" title="正则表达语法"></a>正则表达语法</h2><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>\</td><td>转义</td></tr><tr><td>^</td><td>开始</td></tr><tr><td>$</td><td>结尾</td></tr><tr><td>*</td><td>0次或多次匹配</td></tr><tr><td>+</td><td>一次或多次匹配</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;shell-概述&quot;&gt;&lt;a href=&quot;#shell-概述&quot; class=&quot;headerlink&quot; title=&quot;shell 概述&quot;&gt;&lt;/a&gt;shell 概述&lt;/h2&gt;&lt;p&gt;命令行解释器 &lt;/p&gt;
&lt;p&gt;硬件 -&amp;gt; Linux 内核 -&amp;gt; shell (</summary>
      
    
    
    
    <category term="Shell" scheme="http://shizhonggan.github.io/categories/Shell/"/>
    
    
    <category term="Shell" scheme="http://shizhonggan.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Spark on YARN 环境搭建</title>
    <link href="http://shizhonggan.github.io/2022/05/25/BigData/SparkYarn/"/>
    <id>http://shizhonggan.github.io/2022/05/25/BigData/SparkYarn/</id>
    <published>2022-05-25T07:54:23.000Z</published>
    <updated>2022-06-01T07:42:58.922Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spark-on-YARN-本质"><a href="#Spark-on-YARN-本质" class="headerlink" title="Spark on YARN 本质"></a>Spark on YARN 本质</h2><p>构建HA standAlone集群可以满足稳定的Spark生产环境要求。</p><p>而在YARN集群之上构建Hadoop集群可以提高资源利用率，因为企业的服务器资源总是紧张的</p><p>YARN本身是一个资源调度框架，负责对运行在内部的计算框架进行资源调度管理</p><p>作为典型的计算框架，Spark本身也是直接运行在YARN中，并接受YARN调度。</p><p>所以，SPARK on YARN 无需部署Spark集群，只要找一台服务器，充当Spark的客户端，既可以提交任务到YARN 集群中运行。</p><p><strong>本质:</strong> </p><ul><li>Master角色由YARN的ResourceManager担任。Worker角色由YARN的NodeManager担任。</li><li>Driver角色运行在YARN容器内 或 提交任务的客户端进程。</li><li>真正干活的Executor运行在YARN提供的容器内。</li></ul><h2 id="配置spark-on-YARN-环境"><a href="#配置spark-on-YARN-环境" class="headerlink" title="配置spark on YARN 环境"></a>配置spark on YARN 环境</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /opt/spark/conf/spark-env.sh</span><br></pre></td></tr></table></figure><blockquote><p>只要配置好HADOOP_CONF_DIR和YARN_CONF_DIR配置即可</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">./bin/spark-submit --master yarn</span><br><span class="line">./bin/spark-submit --master yarn /opt/spark/examples/src/main/python/pi.py 100</span><br></pre></td></tr></table></figure><p><img src="https://ganshizhong.gitee.io/blogimages/BigData/Spark/spark_yarn.png" alt="spark_yarn"></p><p><img src="https://ganshizhong.gitee.io/blogimages/BigData/Spark/spark_yarn_hadoop.png" alt="spark_yarn_hadoop"></p><h2 id="部署模式DeployMode"><a href="#部署模式DeployMode" class="headerlink" title="部署模式DeployMode"></a>部署模式DeployMode</h2><p>Spark on YARN 有两种运行模式：</p><ul><li>Cluster模式：Driver运行在容器内部，和ApplicationMaster在同一个容器内</li><li>Clinet模式：Driver运行在客户端进程中，比如Driver运行在spark-submit程序的进程中</li></ul><p>通过<strong>spark-submit</strong>,<strong>pyspark</strong>,<strong>spark-shell</strong>启动的任务</p><p>cluster模式 效率高，但产生的日志也在容器内部不宜查找</p><h2 id="Spark-on-YARN-两种模式总结"><a href="#Spark-on-YARN-两种模式总结" class="headerlink" title="Spark on YARN 两种模式总结"></a>Spark on YARN 两种模式总结</h2><table><thead><tr><th></th><th>Cluster</th><th>Client</th></tr></thead><tbody><tr><td>Driver运行位置</td><td>YARN容器内</td><td>客户端进程内</td></tr><tr><td>通讯效率</td><td>高</td><td>低于cluster</td></tr><tr><td>日志查看</td><td>日志输出在容器内，查看不方便</td><td>日志输出在客户端的标准输出流中，方便查看</td></tr><tr><td>生产可用</td><td>推荐不推荐</td><td></td></tr><tr><td>稳定性</td><td>稳定</td><td>基于客户端进程，受到客户端进程影响</td></tr></tbody></table><h2 id="两种模式详细流程"><a href="#两种模式详细流程" class="headerlink" title="两种模式详细流程"></a>两种模式详细流程</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Spark-on-YARN-本质&quot;&gt;&lt;a href=&quot;#Spark-on-YARN-本质&quot; class=&quot;headerlink&quot; title=&quot;Spark on YARN 本质&quot;&gt;&lt;/a&gt;Spark on YARN 本质&lt;/h2&gt;&lt;p&gt;构建HA standAlon</summary>
      
    
    
    
    <category term="BigData" scheme="http://shizhonggan.github.io/categories/BigData/"/>
    
    
    <category term="Spark" scheme="http://shizhonggan.github.io/tags/Spark/"/>
    
    <category term="YARN" scheme="http://shizhonggan.github.io/tags/YARN/"/>
    
  </entry>
  
  <entry>
    <title>Spark部署</title>
    <link href="http://shizhonggan.github.io/2022/05/18/BigData/SparkDeploy/"/>
    <id>http://shizhonggan.github.io/2022/05/18/BigData/SparkDeploy/</id>
    <published>2022-05-18T07:54:23.000Z</published>
    <updated>2022-05-18T05:19:27.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="local-部署安装"><a class="markdownIt-Anchor" href="#local-部署安装"></a> Local 部署安装</h2><p>下载地址： <a href="https://dlcdn.apache.org/spark/spark-3.1.3/spark-3.1.3-bin-hadoop3.2.tgz">https://dlcdn.apache.org/spark/spark-3.1.3/spark-3.1.3-bin-hadoop3.2.tgz</a></p><p><a href="https://www.anaconda.com/products/distribution#Downloads">https://www.anaconda.com/products/distribution#Downloads</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">sh Anaconda3-2022.05-Linux-x86_64.sh</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc  <span class="comment"># 使环境生效</span></span><br><span class="line"></span><br><span class="line">conda list <span class="comment"># 正常</span></span><br><span class="line"></span><br><span class="line">python -V <span class="comment">#3.9</span></span><br><span class="line"><span class="comment">## 修改镜像源 </span></span><br><span class="line">vi ~/.condarc <span class="comment">## 网上自己找</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;channels:</span></span><br><span class="line"><span class="string"> - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/linux-64</span></span><br><span class="line"><span class="string"> - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r/linux-64</span></span><br><span class="line"><span class="string"> - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2/linux-64</span></span><br><span class="line"><span class="string"> - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/linux-64</span></span><br><span class="line"><span class="string"> - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro/linux-64</span></span><br><span class="line"><span class="string"> - http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/linux-64</span></span><br><span class="line"><span class="string"> - http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/linux-64</span></span><br><span class="line"><span class="string"> - http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/linux-64</span></span><br><span class="line"><span class="string"> - http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/linux-64</span></span><br><span class="line"><span class="string"> - http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/linux-64</span></span><br><span class="line"><span class="string"> - http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/simpleitk/linux-64</span></span><br><span class="line"><span class="string"> - defaults</span></span><br><span class="line"><span class="string">show_channel_urls: true&#x27;</span> &gt; ~/.condarc</span><br><span class="line">conda config --show channels</span><br><span class="line">conda clean -i <span class="comment">## 保证生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置虚拟环境</span></span><br><span class="line">conda create -n pyspark python=3.8</span><br><span class="line">    environment location: /opt/anaconda3/envs/pyspark</span><br><span class="line"></span><br><span class="line"><span class="comment">#To activate this environment, use</span></span><br><span class="line">$ conda activate pyspark</span><br><span class="line"></span><br><span class="line"><span class="comment"># To deactivate an active environment, use</span></span><br><span class="line">$ conda deactivate</span><br><span class="line"></span><br><span class="line"><span class="comment">################# 安装spark</span></span><br><span class="line">tar -zxvf spark-3.1.3-bin-hadoop3.2.tgz</span><br><span class="line"></span><br><span class="line">ln -s /opt/spark-xxx /opt/spark <span class="comment"># 可以起别名，我这里直接用mv 替换文件夹名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置spark环境变量</span></span><br><span class="line">SPARK_HOME: Spark安装目录</span><br><span class="line">PYSPARK_PYTHON: 表示python想运行Python程序，去哪里找python执行器</span><br><span class="line">JAVA_HOME:告知Java在哪里</span><br><span class="line">HADOOP_CONF_DIR: 告知Spark Hadoop的配置文件位置</span><br><span class="line">HADOOP_HOME: 告知spark Hadoop安装在哪里</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export SPARK_HOME=/opt/spark</span></span><br><span class="line"><span class="string">export PYSPARK_PYTHON=/opt/anaconda3/envs/pyspark/bin/python3.8</span></span><br><span class="line"><span class="string">export JAVA_HOME=/opt/java/jdk1.8.0_271</span></span><br><span class="line"><span class="string">export HADOOP_CONF_DIR=/opt/hadoop/hadoop-3.2.3/etc/hadoop</span></span><br><span class="line"><span class="string">export HADOOP_HOME=/opt/hadoop/hadoop-3.2.3</span></span><br><span class="line"><span class="string">export PATH=$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH &#x27;</span> &gt;&gt; /etc/profile.d/spark-3.1.3.sh</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PYSPARK_PYTHON=/opt/anaconda3/envs/pyspark/bin/python3.8</span></span><br><span class="line"><span class="string">export JAVA_HOME=/opt/java/jdk1.8.0_271&#x27;</span>&gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo su</span><br><span class="line">(base) [root@master ec2-user]<span class="comment"># conda activate pyspark</span></span><br><span class="line">(pyspark) [root@master ec2-user]<span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /opt/spark/bin/</span><br><span class="line"><span class="comment">### pyspark 运行python脚本</span></span><br><span class="line">./pyspark</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i am Spark&quot;</span>)</span><br><span class="line">sc.parallelize([1,2,3,4,5]).map(lambda x: x*10).collect()</span><br></pre></td></tr></table></figure><p><a href="http://ip">http://ip</a>:port 访问相应的端口ip可以看到spark job如下：<br /><img src="https://ganshizhong.gitee.io/blogimages/BigData/Spark/sparkjob.png" alt="sparkjob" /></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### spark-shell 运行scala</span></span><br><span class="line">./spark-shell</span><br><span class="line">sc.parallelize(Array(1,2,3,4,5)).map(x=&gt;x*10).collect()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>spark-shell 运行scala交互如下：<br /><img src="https://ganshizhong.gitee.io/blogimages/BigData/Spark/scala.png" alt="sparkscalajob" /></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### submit-submit 直接运行 </span></span><br><span class="line">./spark-submit --master <span class="built_in">local</span>[*] /opt/spark/examples/src/main/python/pi.py 10 <span class="comment">## 10次迭代求解圆周率</span></span><br></pre></td></tr></table></figure><p><img src="https://ganshizhong.gitee.io/blogimages/BigData/Spark/spark-submit_pi.png" alt="spark-submit_pi" /></p><h2 id="standalone-架构"><a class="markdownIt-Anchor" href="#standalone-架构"></a> Standalone 架构</h2><p>Standalone 模式是Spark自带的一种集群模式，不同于前面本地模式启动多个进程来模拟集群环境，Standalone模式是真实的在多个机器之间搭建spark集群的环境，完全可以利用该模式搭建多机器集群，用于实际的大数据处理。</p><p>Standalone 是完整的spark运行环境，其中：</p><ul><li>Master角色以Master进程存在，worker角色以worker进程存在</li><li>Driver角色在运行时存在于Master进程内，Executor运行于Worker进程内</li></ul><p>Standalone集群在进程上主要有3类进程：</p><ul><li>主节点Master进程：<ul><li>master角色，管理整个集群资源，并托管运行各个任务的Driver</li></ul></li><li>从节点Workers:<ul><li>worker角色，管理每个机器的资源，分配对应的资源来运行Excutor（Task）</li></ul></li><li>历史服务器HistoryServer(可选)：<ul><li>spark Application运行完成以后，保存时间日志数据至HDFS，启动HistoryServer可以查看应用运行相关信息</li></ul></li></ul><h2 id="standalone-集群环境安装"><a class="markdownIt-Anchor" href="#standalone-集群环境安装"></a> Standalone 集群环境安装</h2><p>master 运行Spark的Master进程和1个work进程<br />worker1 运行Spark的1个work进程<br />worker2 运行Spark的1个work进程</p><h3 id="每台机器部署anacondapython-环境略同上"><a class="markdownIt-Anchor" href="#每台机器部署anacondapython-环境略同上"></a> 每台机器部署Anaconda(python) 环境【略，同上】</h3><h3 id="每台机器部署spark-环境略同上"><a class="markdownIt-Anchor" href="#每台机器部署spark-环境略同上"></a> 每台机器部署spark 环境【略,同上】</h3><h3 id="spark集群文件配置"><a class="markdownIt-Anchor" href="#spark集群文件配置"></a> spark集群文件配置</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/spark/conf</span><br><span class="line">cp workers.template workers</span><br><span class="line">cp spark-env.sh.template spark-env.sh</span><br><span class="line">cp spark-defaults.conf.template spark-defaults.conf</span><br><span class="line">cp log4j.properties.template log4j.properties</span><br><span class="line"><span class="comment"># 将spark程序运行的历史日志 存到hdfs的/sparklog文件夹中</span></span><br><span class="line">hadoop fs -mkdir /sparklog</span><br><span class="line">mkdir -p /data/spark/<span class="built_in">log</span>/</span><br></pre></td></tr></table></figure><h4 id="1修改-workers"><a class="markdownIt-Anchor" href="#1修改-workers"></a> 1）修改 workers</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;master</span></span><br><span class="line"><span class="string">worker1</span></span><br><span class="line"><span class="string">worker2&#x27;</span> &gt;&gt; workers</span><br></pre></td></tr></table></figure><h4 id="2-修改-spark-envsh"><a class="markdownIt-Anchor" href="#2-修改-spark-envsh"></a> 2) 修改 <a href="http://spark-env.sh">spark-env.sh</a></h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string">## java安装目录</span></span><br><span class="line"><span class="string">JAVA_HOME=/opt/java/jdk1.8.0_271</span></span><br><span class="line"><span class="string">## HADOOP软件配置文件目录，读取HDFS上文件和运行YARN集群</span></span><br><span class="line"><span class="string">HADOOP_CONF_DIR=/opt/hadoop/hadoop-3.2.3/etc/hadoop</span></span><br><span class="line"><span class="string">YARN_CONF_DIR=/opt/hadoop/hadoop-3.2.3/etc/hadoop</span></span><br><span class="line"><span class="string">## 指定spark master运行在哪台机器</span></span><br><span class="line"><span class="string">export SPARK_MASTER_HOST=master</span></span><br><span class="line"><span class="string">## 指定spark master的通讯端口</span></span><br><span class="line"><span class="string">export SPARK_MASTER_PORT=9777</span></span><br><span class="line"><span class="string">## 告知spark master的webui 端口</span></span><br><span class="line"><span class="string">SPARK_MASTER_WEBUI_PORT=9780</span></span><br><span class="line"><span class="string">## work cpu可用核数</span></span><br><span class="line"><span class="string">SPARK_WORKER_CORES=1</span></span><br><span class="line"><span class="string">## work 可用内存</span></span><br><span class="line"><span class="string">SPARK_WORKER_MEMORY=1g</span></span><br><span class="line"><span class="string">## work 的工作通讯地址</span></span><br><span class="line"><span class="string">SPARK_WORKER_PORT=9778</span></span><br><span class="line"><span class="string">## work 的webui地址</span></span><br><span class="line"><span class="string">SPARK_WORKER_WEBUI_PORT=9781</span></span><br><span class="line"><span class="string">## 设置历史服务器</span></span><br><span class="line"><span class="string"># 配置的意思是 将spark程序运行的历史日志 存到hdfs的/sparklog文件夹中</span></span><br><span class="line"><span class="string">SPARK_HISTORY_OPTS=&quot;-Dspark.history.fs.logDirectory=hdfs://master:9710/sparklog -Dspark.history.fs.cleaner.enabled=true&quot;</span></span><br><span class="line"><span class="string">&#x27;</span> &gt;&gt; spark-env.sh</span><br></pre></td></tr></table></figure><blockquote><p>hdfs://master:9710 对应 fs.defaultFS；同时需要在hadoop下创建/sparklog文件夹 “hadoop fs -mkdir /sparklog”</p></blockquote><h4 id="3-修改-spark-defaultsconf"><a class="markdownIt-Anchor" href="#3-修改-spark-defaultsconf"></a> 3) 修改 spark-defaults.conf</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string"># 开启spark的日期记录功能</span></span><br><span class="line"><span class="string">spark.eventLog.enabled true</span></span><br><span class="line"><span class="string"># 设置spark日志记录路径</span></span><br><span class="line"><span class="string">spark.eventLog.dir hdfs://master:9710/sparklog/</span></span><br><span class="line"><span class="string"># spark.eventLog.dir file:/data/spark/log/</span></span><br><span class="line"><span class="string"># 设置spark日志是否启动压缩</span></span><br><span class="line"><span class="string">spark.eventLog.compress false</span></span><br><span class="line"><span class="string">&#x27;</span> &gt;&gt; spark-defaults.conf</span><br></pre></td></tr></table></figure><h4 id="4-修改-log4jproperties"><a class="markdownIt-Anchor" href="#4-修改-log4jproperties"></a> 4) 修改 log4j.properties</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootCategory=WARN, console <span class="comment"># 修改</span></span><br><span class="line"></span><br><span class="line">cat log4j.properties | grep log4j.rootCategory=</span><br><span class="line">sed -i <span class="string">&#x27;s#log4j.rootCategory=INFO, console#log4j.rootCategory=WARN, console#&#x27;</span> log4j.properties</span><br></pre></td></tr></table></figure><h4 id="复制文件到其他节点"><a class="markdownIt-Anchor" href="#复制文件到其他节点"></a> 复制文件到其他节点</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scp workers 192.168.1.7:/opt/spark/conf</span><br><span class="line">scp spark-env.sh 192.168.1.7:/opt/spark/conf</span><br><span class="line">scp spark-defaults.conf 192.168.1.7:/opt/spark/conf</span><br><span class="line">scp log4j.properties 192.168.1.7:/opt/spark/conf</span><br><span class="line"></span><br><span class="line">scp workers 192.168.1.9:/opt/spark/conf</span><br><span class="line">scp spark-env.sh 192.168.1.9:/opt/spark/conf</span><br><span class="line">scp spark-defaults.conf 192.168.1.9:/opt/spark/conf</span><br><span class="line">scp log4j.properties 192.168.1.9:/opt/spark/conf</span><br></pre></td></tr></table></figure><h3 id="启动spark集群"><a class="markdownIt-Anchor" href="#启动spark集群"></a> 启动spark集群</h3><blockquote><p>一定要用&quot;./path/start-all.sh “或”./start-all.sh&quot;形式， 而不是绝对路径或直接文件执行</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/hadoop/hadoop-3.2.3/etc/hadoop/ &amp;&amp; stop-all.sh</span><br><span class="line"><span class="built_in">cd</span> /data/hadoop/pid/ </span><br><span class="line"></span><br><span class="line">./sbin/start-history-server.sh </span><br><span class="line">./sbin/start-all.sh</span><br></pre></td></tr></table></figure><h3 id="检查spark集群"><a class="markdownIt-Anchor" href="#检查spark集群"></a> 检查spark集群</h3><p><a href="http://ip:9780">http://ip:9780</a></p><p><img src="https://ganshizhong.gitee.io/blogimages/BigData/Spark/sparkclusterdepolysuccessful.png" alt="sparkclusterdepolysuccessful" /></p><h3 id="集群连接测试"><a class="markdownIt-Anchor" href="#集群连接测试"></a> 集群连接测试</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/spark</span><br><span class="line"><span class="comment">## pyspark</span></span><br><span class="line">./bin/pyspark --master spark://master:9777</span><br><span class="line">sc.parallelize([1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5]).map(lambda x: x*10).collect()</span><br><span class="line"></span><br><span class="line">sc.textFile(<span class="string">&quot;hdfs://master:9710/input/word.txt&quot;</span>).flatMap(lambda line: line.split(<span class="string">&quot; &quot;</span>)).map(lambda x:(x,1)).reduceByKey(lambda a,b: a+b).collect()</span><br><span class="line"><span class="comment">## spark-submit</span></span><br><span class="line">./bin/spark-submit --master spark://master:9777 /opt/spark/examples/src/main/python/pi.py 100</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ol><li>StandAlone的原理？</li></ol><p>Master和Worker角色以独立进程的形式存在，并组成Spark运行时环境（集群）</p><ol start="2"><li>Spark角色在StandAlone中的分布？</li></ol><p>Master角色： Master进程， worker角色： worker进程， Driver角色： 以线程运行在Master中，Excutor角色：以线程运行在worker中</p><ol start="3"><li>Standalone如何提交Spark应用？</li></ol><p>./bin/spark-submit --master spark://server:9777</p><ol start="4"><li>Job\Stage\Task的关系？</li></ol><p>一个Spark运行程序会被分成多个子任务（Job）运行，每一个Job会分成多个阶段（Stage）来运行，每个Stage内会分出来多个线程（Task）来执行具体任务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;local-部署安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#local-部署安装&quot;&gt;&lt;/a&gt; Local 部署安装&lt;/h2&gt;
&lt;p&gt;下载地址： &lt;a href=&quot;https://dlcdn.apache.org/spark/sp</summary>
      
    
    
    
    <category term="BigData" scheme="http://shizhonggan.github.io/categories/BigData/"/>
    
    <category term="Spark" scheme="http://shizhonggan.github.io/categories/BigData/Spark/"/>
    
    
  </entry>
  
  <entry>
    <title>Spark StandAlone HA集群搭建</title>
    <link href="http://shizhonggan.github.io/2022/05/18/BigData/SparkStandAloneHA/"/>
    <id>http://shizhonggan.github.io/2022/05/18/BigData/SparkStandAloneHA/</id>
    <published>2022-05-18T07:54:23.000Z</published>
    <updated>2022-05-25T08:29:52.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="StandAlone-HA-运行原理"><a href="#StandAlone-HA-运行原理" class="headerlink" title="StandAlone HA 运行原理"></a>StandAlone HA 运行原理</h2><p>Spark Standalone集群是Master-Slaves架构的集群模式，存在着Master单点故障的问题。</p><h3 id="高可用-HA"><a href="#高可用-HA" class="headerlink" title="高可用 HA"></a>高可用 HA</h3><p>解决单点故障有两种方案：</p><ol><li><p>基于文件系统的单点恢复（Single-Node Recovery with Local File System）:<strong>只能用于开发或测试环境</strong></p></li><li><p>基于zookeeper的Standby Masters(Standby Masters with ZooKeeper): 可用于生产环境</p></li></ol><p>ZooKeeper 提供了一个Leader Election 机制， 利用这个机制可以保证虽然集群存在多个Master，但是只有一个Active的，其他都是Standby。当Active的Master出现故障时，另外的一个Standby Master会被选举出来。由于集群的信息，包括Worker, Driver和Applicaiton 的信息都已经持久化到文件系统，因此在切换的过程中只会影响新的job的提交，对于正在进行的job没有任何的影响。加入ZooKeeper的集群整体架构如下图所示：</p><h2 id="高可用HA-StandAlone集群搭建"><a href="#高可用HA-StandAlone集群搭建" class="headerlink" title="高可用HA StandAlone集群搭建"></a>高可用HA StandAlone集群搭建</h2><blockquote><p>前提： 确保Zookeeper和HDFS均已经启动</p></blockquote><p><strong>修改配置文件即可</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/spark/conf</span><br><span class="line">vi spark-env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string">## java安装目录</span></span><br><span class="line"><span class="string">JAVA_HOME=/opt/java/jdk1.8.0_271</span></span><br><span class="line"><span class="string">## HADOOP软件配置文件目录，读取HDFS上文件和运行YARN集群</span></span><br><span class="line"><span class="string">HADOOP_CONF_DIR=/opt/hadoop/hadoop-3.2.3/etc/hadoop</span></span><br><span class="line"><span class="string">YARN_CONF_DIR=/opt/hadoop/hadoop-3.2.3/etc/hadoop</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># ## 指定spark master运行在哪台机器</span></span><br><span class="line"><span class="string"># export SPARK_MASTER_HOST=master</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 指定spark master的通讯端口</span></span><br><span class="line"><span class="string">export SPARK_MASTER_PORT=9777</span></span><br><span class="line"><span class="string">## 告知spark master的webui 端口</span></span><br><span class="line"><span class="string">SPARK_MASTER_WEBUI_PORT=9780</span></span><br><span class="line"><span class="string">## work cpu可用核数</span></span><br><span class="line"><span class="string">SPARK_WORKER_CORES=1</span></span><br><span class="line"><span class="string">## work 可用内存</span></span><br><span class="line"><span class="string">SPARK_WORKER_MEMORY=1g</span></span><br><span class="line"><span class="string">## work 的工作通讯地址</span></span><br><span class="line"><span class="string">SPARK_WORKER_PORT=9778</span></span><br><span class="line"><span class="string">## work 的webui地址</span></span><br><span class="line"><span class="string">SPARK_WORKER_WEBUI_PORT=9781</span></span><br><span class="line"><span class="string">## 设置历史服务器</span></span><br><span class="line"><span class="string"># 配置的意思是 将spark程序运行的历史日志 存到hdfs的/sparklog文件夹中</span></span><br><span class="line"><span class="string">SPARK_HISTORY_OPTS=&quot;-Dspark.history.fs.logDirectory=hdfs://master:9710/sparklog -Dspark.history.fs.cleaner.enabled=true&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SPARK_DAEMON_JAVA_OPTS=&quot;-Dspark.deploy.recoveryMode=ZOOKEEPER -Dspark.deploy.zookeeper.url=master:2181,worker1:2181,worker2:2181 -Dspark.deploy.zookeeper.dir=/spark-ha&quot;</span></span><br><span class="line"><span class="string">&#x27;</span> &gt;&gt; spark-env.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送到各个节点</span></span><br><span class="line">scp spark-env.sh 192.168.1.7:/opt/spark/conf/</span><br><span class="line">scp spark-env.sh 192.168.1.9:/opt/spark/conf/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">./sbin/stop-all.sh</span><br><span class="line">./sbin/start-all.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个时候 master节点必然是 master</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入worker1节点，启动master，然后jps查看进程</span></span><br><span class="line">./sbin/start-master.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有时候存在端口被占用或顺延，如下方式查端口</span></span><br><span class="line">JPS <span class="comment"># 查看进程ID 34784</span></span><br><span class="line">netstart -anp|grep 34784</span><br></pre></td></tr></table></figure><blockquote><p>master注释掉；spark.deploy.recoveryMode 指定HA模式,基于zookeeper实现;指定zookeeper的连接地址；指定zookeeper中注册临时节点的路径。</p></blockquote><h2 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 只需要把master的停掉</span></span><br><span class="line"><span class="built_in">kill</span> -9 JPS查询master_进程ID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以在worker1节点先启动任务（以pi圆周率任务为例），执行过程中停掉master进程</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;StandAlone-HA-运行原理&quot;&gt;&lt;a href=&quot;#StandAlone-HA-运行原理&quot; class=&quot;headerlink&quot; title=&quot;StandAlone HA 运行原理&quot;&gt;&lt;/a&gt;StandAlone HA 运行原理&lt;/h2&gt;&lt;p&gt;Spark </summary>
      
    
    
    
    <category term="BigData" scheme="http://shizhonggan.github.io/categories/BigData/"/>
    
    
    <category term="Zookeeper" scheme="http://shizhonggan.github.io/tags/Zookeeper/"/>
    
    <category term="Spark" scheme="http://shizhonggan.github.io/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop安装常见错误</title>
    <link href="http://shizhonggan.github.io/2022/05/17/BigData/hadoop_installerror/"/>
    <id>http://shizhonggan.github.io/2022/05/17/BigData/hadoop_installerror/</id>
    <published>2022-05-17T07:54:23.000Z</published>
    <updated>2022-05-17T04:59:01.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tcp端口被占用"><a class="markdownIt-Anchor" href="#tcp端口被占用"></a> tcp端口被占用</h2><p>暴力重启，stop集群后常见该问题，一些端口tcp仍然保持连接，挨个kill较为麻烦，</p><h2 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h2><p>配置文件要认真人配置</p><h2 id="ping-socket-permission-denied-attempting-raw-socket"><a class="markdownIt-Anchor" href="#ping-socket-permission-denied-attempting-raw-socket"></a> ping: socket: Permission denied, attempting raw socket…</h2><p>ICMP协议开通</p><h2 id="javaioioexception-got-error-statuserror-status-message-ack-with-firstbadlink-as-192168179866"><a class="markdownIt-Anchor" href="#javaioioexception-got-error-statuserror-status-message-ack-with-firstbadlink-as-192168179866"></a> java.io.IOException: Got error, status=ERROR, status message , ack with firstBadLink as 192.168.1.7:9866</h2><p>端口打开</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;tcp端口被占用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#tcp端口被占用&quot;&gt;&lt;/a&gt; tcp端口被占用&lt;/h2&gt;
&lt;p&gt;暴力重启，stop集群后常见该问题，一些端口tcp仍然保持连接，挨个kill较为麻烦，&lt;/p&gt;
&lt;h2 id</summary>
      
    
    
    
    <category term="BigData" scheme="http://shizhonggan.github.io/categories/BigData/"/>
    
    <category term="Hadoop" scheme="http://shizhonggan.github.io/categories/BigData/Hadoop/"/>
    
    
  </entry>
  
  <entry>
    <title>Hadoop 部署</title>
    <link href="http://shizhonggan.github.io/2022/05/14/BigData/HadoopDeploy/"/>
    <id>http://shizhonggan.github.io/2022/05/14/BigData/HadoopDeploy/</id>
    <published>2022-05-14T07:54:23.000Z</published>
    <updated>2022-05-18T09:01:12.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><p>三台Linux虚拟机服务器</p><p>node1: Master(HDFS\YARN\Spark) 和 Worker(HDFS\YARN\Spark)<br>node2: Worker(HDFS\YARN\Spark)<br>node3: Worker(HDFS\YARN\Spark) 和 Hive </p><p>Hadoop3集群、JDK1.8、Centos7.6</p><p>192.168.1.4 master 【绑定公网IP】<br>192.168.1.7 worker1<br>192.168.1.9 worker2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname master</span><br><span class="line">hostnamectl set-hostname worker1</span><br><span class="line">hostnamectl set-hostname worker2</span><br></pre></td></tr></table></figure><p>设置免密登录：<br><a href="http://t.zoukankan.com/Nanaya-p-13202946.html">http://t.zoukankan.com/Nanaya-p-13202946.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line">scp &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub ec2-user@192.168.1.7:&#x2F;home&#x2F;ec2-user</span><br><span class="line"></span><br><span class="line">scp &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub ec2-user@192.168.1.9:&#x2F;home&#x2F;ec2-user</span><br><span class="line"></span><br><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line"></span><br><span class="line">vim etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line"></span><br><span class="line">PermitRootLogin yes　# 允许root认证登录</span><br><span class="line">PubkeyAuthentication # 启用公钥私钥配对认证方式</span><br><span class="line">AuthorizedKeysFile .ssh&#x2F;authorized_keys # 公钥文件路径（和上面生成的文件相同）</span><br><span class="line">systemctl restart sshd</span><br><span class="line"></span><br><span class="line">## 配置hosts</span><br><span class="line">echo &#39;192.168.1.4 master</span><br><span class="line">192.168.1.7 worker1</span><br><span class="line">192.168.1.9 worker2&#39; &gt;&gt; &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure><h2 id="Local模式基本原理"><a href="#Local模式基本原理" class="headerlink" title="Local模式基本原理"></a>Local模式基本原理</h2><p>本质：启动一个JVM Process进程（一个进程里面有多个线程），执行任务Task<br>Local模式可以限制模拟Spark集群环境的线程数量，即Local[N]或Local[<em>],其中，N代表可以使用的N个线程，每个线程拥有一个CPU core。如果不指定N,则默认1个线程(该线程有1个Core)。通常Cpu有几个Core，就指定几个线程，最大化利用计算能力。如果是Local[</em>]，则按照Cpu最多的Cores设置线程数。</p><h2 id="下载安装【三台】"><a href="#下载安装【三台】" class="headerlink" title="下载安装【三台】"></a>下载安装【三台】</h2><p>参考：<br><a href="https://blog.csdn.net/dream_an/article/details/80258283">https://blog.csdn.net/dream_an/article/details/80258283</a></p><p><a href="https://blog.csdn.net/weixin_53227758/article/details/121977047">https://blog.csdn.net/weixin_53227758/article/details/121977047</a> [很详细]</p><p><a href="https://blog.csdn.net/zyx1260168395/article/details/120921697?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-120921697-blog-123827164.pc_relevant_antiscanv2&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/zyx1260168395/article/details/120921697?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-120921697-blog-123827164.pc_relevant_antiscanv2&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p><p><a href="https://blog.csdn.net/weixin_49167174/article/details/123827164">https://blog.csdn.net/weixin_49167174/article/details/123827164</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">网上找java8的安装包，百度网盘比较好，官方下载需要一堆注册信息</span><br><span class="line"></span><br><span class="line">mkdir /opt/java <span class="comment"># 上传java</span></span><br><span class="line">tar -zxf jdk-8u271-linux-x64.tar.gz</span><br><span class="line">mv jdk1.8.0_271/ /opt/java/</span><br><span class="line"><span class="comment">## 配置JAVA环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export JAVA_HOME=/opt/java/jdk1.8.0_271</span></span><br><span class="line"><span class="string">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/jre/lib/rt.jar:$&#123;JAVA_HOME&#125;/lib/dt.jar:$&#123;JAVA_HOME&#125;/lib/tools.jar</span></span><br><span class="line"><span class="string">export PATH=$PATH:$&#123;JAVA_HOME&#125;/bin&#x27;</span> &gt; /etc/profile.d/jdk-1.8.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使环境变量生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看java</span></span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><p>hadoop3+配置文件 github配置文件源码地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Hadoop官网：http://hadoop.apache.org/</span><br><span class="line">yum install wget <span class="comment"># 太慢，直接网页下载再上传</span></span><br><span class="line">https://downloads.apache.org/hadoop/common/hadoop-3.2.3/</span><br><span class="line"></span><br><span class="line">mkdir /opt/hadoop</span><br><span class="line"><span class="comment">#共需要配置/opt/hadoop/hadoop-3.2.3/etc/hadoop/下的六个个文件，分别是</span></span><br><span class="line"><span class="comment"># hadoop-env.sh、core-site.xml、hdfs-site.xml、yarn-site.xml、mapred-site.xml、workers</span></span><br><span class="line">tar -zxf hadoop-3.2.3.tar.gz </span><br><span class="line">mv hadoop-3.2.3 /opt/hadoop/</span><br></pre></td></tr></table></figure><h2 id="修改master配置文件"><a href="#修改master配置文件" class="headerlink" title="修改master配置文件"></a>修改master配置文件</h2><blockquote><p>配置文件，主从都一样，并不影响，除非主节点你不设置DataNode</p></blockquote><h3 id="配置文件备份"><a href="#配置文件备份" class="headerlink" title="配置文件备份"></a>配置文件备份</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/hadoop/hadoop-3.2.3/etc/hadoop/</span><br><span class="line">cp hadoop-env.sh hadoop-env.sh.bak</span><br><span class="line">cp core-site.xml core-site.xml.bak</span><br><span class="line">cp hdfs-site.xml hdfs-site.xml.bak</span><br><span class="line">cp yarn-site.xml yarn-site.xml.bak</span><br><span class="line">cp mapred-site.xml mapred-site.xml.bak</span><br><span class="line">cp workers workers.bak</span><br></pre></td></tr></table></figure><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/hadoop/tmp /data/hadoop/hdfs/data /data/hadoop/hdfs/name /data/hadoop/pid/ /data/hadoop/<span class="built_in">log</span>/</span><br></pre></td></tr></table></figure><h3 id="修改hadoop-env-sh-环境变量"><a href="#修改hadoop-env-sh-环境变量" class="headerlink" title="修改hadoop-env.sh 环境变量"></a>修改hadoop-env.sh 环境变量</h3><p><a href="https://baijiahao.baidu.com/s?id=1668099113918809329&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1668099113918809329&amp;wfr=spider&amp;for=pc</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export JAVA_HOME=/opt/java/jdk1.8.0_271</span></span><br><span class="line"><span class="string">export HADOOP_HOME=/opt/hadoop/hadoop-3.2.3</span></span><br><span class="line"><span class="string">export HADOOP_PID_DIR=/data/hadoop/pid</span></span><br><span class="line"><span class="string">export HADOOP_LOG_DIR=/data/hadoop/log</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export HADOOP_MAPRED_HOME=$HADOOP_HOME</span></span><br><span class="line"><span class="string">export HADOOP_COMMON_HOME=$HADOOP_HOME</span></span><br><span class="line"><span class="string">export HADOOP_HDFS_HOME=$HADOOP_HOME</span></span><br><span class="line"><span class="string">export YARN_HOME=$HADOOP_HOME</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export HADOOP_CONF_DIR=$&#123;HADOOP_HOME&#125;/etc/hadoop</span></span><br><span class="line"><span class="string">export HDFS_CONF_DIR=$&#123;HADOOP_HOME&#125;/etc/hadoop</span></span><br><span class="line"><span class="string">export YARN_CONF_DIR=$&#123;HADOOP_HOME&#125;/etc/hadoop</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># export HIVE_HOME=/opt/hive</span></span><br><span class="line"><span class="string"># export HBASE_HOME=/opt/hbase</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH</span></span><br><span class="line"><span class="string">export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop</span></span><br><span class="line"><span class="string">export YARN_CONF_DIR=$HADOOP_HOME/etc/hadoop</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export HDFS_NAMENODE_USER=&quot;root&quot;</span></span><br><span class="line"><span class="string">export HDFS_DATANODE_USER=&quot;root&quot;</span></span><br><span class="line"><span class="string">export HDFS_SECONDARYNAMENODE_USER=&quot;root&quot;</span></span><br><span class="line"><span class="string">export YARN_RESOURCEMANAGER_USER=&quot;root&quot;</span></span><br><span class="line"><span class="string">export YARN_NODEMANAGER_USER=&quot;root&quot; &#x27;</span> &gt;&gt; /opt/hadoop/hadoop-3.2.3/etc/hadoop/hadoop-env.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>也可以在/etc/profile.d/中配置</p></blockquote><h3 id="修改-core-site-xml"><a href="#修改-core-site-xml" class="headerlink" title="修改 core-site.xml"></a>修改 core-site.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://master:9710<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>io.file.buffer.size<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>131072<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>/data/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>name: <strong>fs.default.name</strong> 和<strong>fs.defaultFS</strong> 区别：FS是两台主机以上进行高可用配置，name则是单点使用;value: NameNode URI</p></blockquote><blockquote><p>name: <strong>io.file.buffer.size</strong>: Size of read/write buffer used in SequenceFiles</p></blockquote><blockquote><p>name: <strong>hadoop.tmp.dir</strong>： A base for other temporary directories.</p></blockquote><h3 id="修改-hdfs-site-xml"><a href="#修改-hdfs-site-xml" class="headerlink" title="修改 hdfs-site.xml"></a>修改 hdfs-site.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Configurations for NameNode: --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/data/hadoop/hdfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.blocksize<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>268435456<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.ttp-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:9711<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.handler.count<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Configurations for DataNode: --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/data/hadoop/hdfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>name: <strong>dfs.blocksize</strong>: HDFS blocksize of 256MB for large file-systems.</p></blockquote><blockquote><p>name: <strong>dfs.namenode.http-address</strong>: The address and the base port where the dfs namenode web ui will listen on.</p></blockquote><blockquote><p>name: <strong>dfs.namenode.handler.count</strong>: More NameNode server threads to handle RPCs from large number of DataNodes.</p></blockquote><blockquote><p>name: <strong>dfs.datanode.data.dir</strong>: If this is a comma-delimited list of directories, then data will be stored in all named directories, typically on different devices.</p></blockquote><h3 id="修改-yarn-site-xml"><a href="#修改-yarn-site-xml" class="headerlink" title="修改 yarn-site.xml"></a>修改 yarn-site.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Configurations for ResourceManager and NodeManager: 未配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Configurations for ResourceManager: --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:9712<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:9713<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:9714<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Configurations for NodeManager: --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.env-whitelist<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_HOME,PATH,LANG,TZ,HADOOP_MAPRED_HOME<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Configurations for History Server: 暂时不配置吧--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修改-mapred-site-xml"><a href="#修改-mapred-site-xml" class="headerlink" title="修改 mapred-site.xml"></a>修改 mapred-site.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Configurations for MapReduce Applications: --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Configurations for MapReduce JobHistory Server: --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:9715<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修改-workers"><a href="#修改-workers" class="headerlink" title="修改 workers"></a>修改 workers</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master</span><br><span class="line">worker1</span><br><span class="line">worker2</span><br></pre></td></tr></table></figure><h3 id="复制Hadoop文件到其他集群、配置Hadoop环境变量、格式化hdfs、开启集群、查看、关闭、重置集群"><a href="#复制Hadoop文件到其他集群、配置Hadoop环境变量、格式化hdfs、开启集群、查看、关闭、重置集群" class="headerlink" title="复制Hadoop文件到其他集群、配置Hadoop环境变量、格式化hdfs、开启集群、查看、关闭、重置集群"></a>复制Hadoop文件到其他集群、配置Hadoop环境变量、格式化hdfs、开启集群、查看、关闭、重置集群</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/hadoop/tmp /data/hadoop/hdfs/data /data/hadoop/hdfs/name /data/hadoop/pid/ /data/hadoop/<span class="built_in">log</span>/</span><br><span class="line"></span><br><span class="line">scp hadoop-env.sh 192.168.1.7:/opt/hadoop/hadoop-3.2.3/etc/hadoop/</span><br><span class="line">scp core-site.xml 192.168.1.7:/opt/hadoop/hadoop-3.2.3/etc/hadoop/</span><br><span class="line">scp hdfs-site.xml 192.168.1.7:/opt/hadoop/hadoop-3.2.3/etc/hadoop/</span><br><span class="line">scp yarn-site.xml 192.168.1.7:/opt/hadoop/hadoop-3.2.3/etc/hadoop/</span><br><span class="line">scp mapred-site.xml 192.168.1.7:/opt/hadoop/hadoop-3.2.3/etc/hadoop/</span><br><span class="line">scp workers 192.168.1.7:/opt/hadoop/hadoop-3.2.3/etc/hadoop/</span><br><span class="line"></span><br><span class="line">scp hadoop-env.sh 192.168.1.9:/opt/hadoop/hadoop-3.2.3/etc/hadoop/</span><br><span class="line">scp core-site.xml 192.168.1.9:/opt/hadoop/hadoop-3.2.3/etc/hadoop/</span><br><span class="line">scp hdfs-site.xml 192.168.1.9:/opt/hadoop/hadoop-3.2.3/etc/hadoop/</span><br><span class="line">scp yarn-site.xml 192.168.1.9:/opt/hadoop/hadoop-3.2.3/etc/hadoop/</span><br><span class="line">scp mapred-site.xml 192.168.1.9:/opt/hadoop/hadoop-3.2.3/etc/hadoop/</span><br><span class="line">scp workers 192.168.1.9:/opt/hadoop/hadoop-3.2.3/etc/hadoop/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="格式化并启动集群"><a href="#格式化并启动集群" class="headerlink" title="格式化并启动集群"></a>格式化并启动集群</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/opt/hadoop/hadoop-3.2.3/bin/hdfs namenode -format </span><br><span class="line">/opt/hadoop/hadoop-3.2.3/sbin/start-all.sh</span><br><span class="line"></span><br><span class="line">/opt/hadoop/hadoop-3.2.3/sbin/start-dfs.sh</span><br><span class="line">/opt/hadoop/hadoop-3.2.3/sbin/start-yarn.sh</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><pre><code>## 报错参考:https://mathsigit.github.io/blog_page/2017/11/16/hole-of-submitting-mr-of-hadoop300RC0/https://blog.csdn.net/qianhuihan/article/details/83379837https://www.jianshu.com/p/9ebe74753794https://stackoverflow.com/questions/50927577/could-not-find-or-load-main-class-org-apache-hadoop-mapreduce-v2-app-mrappmaster</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础环境&quot;&gt;&lt;a href=&quot;#基础环境&quot; class=&quot;headerlink&quot; title=&quot;基础环境&quot;&gt;&lt;/a&gt;基础环境&lt;/h2&gt;&lt;p&gt;三台Linux虚拟机服务器&lt;/p&gt;
&lt;p&gt;node1: Master(HDFS\YARN\Spark) 和 Worker(H</summary>
      
    
    
    
    <category term="BigData" scheme="http://shizhonggan.github.io/categories/BigData/"/>
    
    <category term="Spark" scheme="http://shizhonggan.github.io/categories/BigData/Spark/"/>
    
    
  </entry>
  
  <entry>
    <title>Spark框架概述</title>
    <link href="http://shizhonggan.github.io/2022/05/01/BigData/SparkOverview/"/>
    <id>http://shizhonggan.github.io/2022/05/01/BigData/SparkOverview/</id>
    <published>2022-05-01T07:54:23.000Z</published>
    <updated>2022-05-18T08:57:50.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spark定义"><a class="markdownIt-Anchor" href="#spark定义"></a> Spark定义</h2><p>Apache Spark是用于<strong>大规模数据</strong>（Large-scala data）处理的<strong>统一</strong>（unified）分析引擎。</p><p>Spark最早源于一篇论文Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing, 该论文是由加州大学伯克利分校的Matei Zaharia 等人发表的。论文中提出了一种弹性分布式数据集（即：RDD）的概念。</p><p>A distributed memory abstraction that lets programmers perform in-memory computations on large clusters in a fault-tolerant manner.</p><p>RDD是一种分布式内存抽象，其使得程序员能够在大规模集群中做内存运算，并且有一定的容错。而这也是整个Spark的核心数据结构，Spark整个平台围绕着RDD进行。</p><p><img src="https://ganshizhong.gitee.io/blogimages/BigData/Spark/sparkdatatask.png" alt="spark" /></p><h2 id="spark-vs-hadoopmapreduce"><a class="markdownIt-Anchor" href="#spark-vs-hadoopmapreduce"></a> Spark VS Hadoop(MapReduce)</h2><table><thead><tr><th></th><th>Haddop</th><th>Spark</th></tr></thead><tbody><tr><td>类型</td><td>基础平台，包含计算（MapReduce）、存储（HDFS）、调度(YARN)</td><td>纯计算工具（分布式）</td></tr><tr><td>场景</td><td>海量数据批处理(离线计算，磁盘迭代计算)</td><td>海量数据的批处理（内存计算、交互式计算）、海量数据流计算</td></tr><tr><td>价格</td><td>对机器要求低，便宜</td><td>堆内存有要求，相对较贵</td></tr><tr><td>编程范式</td><td>Map+Reduce, API较为底层，算法适应性差</td><td>RDD组成DAG有向环图，API较为顶层，方便使用</td></tr><tr><td>数据存储结构</td><td>MapReduce中间计算结果在HDFS磁盘上，延迟大</td><td>RDD中间运算结果在内存中，延迟小</td></tr><tr><td>运行方式</td><td>Task以进程方式维护，任务启动慢</td><td>Task以线程方式维护，任务启动快，可批量创建提高并行能力</td></tr></tbody></table><h2 id="spark四大特点"><a class="markdownIt-Anchor" href="#spark四大特点"></a> Spark四大特点</h2><ul><li>速度快 比Hadoop快一百倍<ul><li>Spark处理数据时，可以将中间内存处理结果存储到内存中</li><li>Spark提供了非常丰富的算子(API),可以做到复杂任务在一个Spark程序中完成</li></ul></li><li>易于使用 概念多，编程容易<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df &#x3D; spark.read.json(&quot;logs.json&quot;) # 读取数据</span><br><span class="line">df.where(&quot;age &gt; 20&quot;) # 过滤</span><br><span class="line">  . select(&quot;name.first&quot;).show() # 选取字段，进行展示</span><br></pre></td></tr></table></figure></li><li>通用性强<ul><li>在Spark的基础上，提供了Spark SQL、Spark Streaming、 MLib及 Graph在内的多个工具库</li></ul></li><li>运行方式 可以在Hadoop和Mesos上，也支持Standalone的独立运行模式，也支持云上Kubernetes（2.3以上版本）。<ul><li>数据源支持HDFS，Hbase,Cassandra和Kafak等多种途径</li></ul></li></ul><h2 id="spark框架模块"><a class="markdownIt-Anchor" href="#spark框架模块"></a> Spark框架模块</h2><p>Spark Core: Spark的核心，Spark核心功能均由Spark Core模块提供，是Spark运行的基础。Spark Core以RDD为数据抽象，提供Python, JAVA,Scala，R语言的API,可以编程进行海量离线数据处理</p><p>SparkSQL: 基于Spark Core之上，提供<strong>结构化数据</strong>的处理模块。SparkSQL支持以SQL语言对数据进行处理，SparkSQL本身针对<strong>离线计算</strong>场景。同时基于SparkSQL,Spark提供了<strong>StructuredStreaming模块</strong>，可以以SparkSQL为基础，进行数据的<strong>流式计算</strong>。</p><p>SparkStreaming: 以SparkCore为基础，提供数据的<strong>流式计算</strong>【有一定缺陷】</p><p>MLib: 以SparkCore为基础，进行<strong>机器学习计算</strong>，内置了大量的机器学习库和API算法。方便用户以分布式计算的模式进行机器学习计算</p><p>GraphX: 以SparkCore为基础，进行<strong>图计算</strong>，提供了大量的图计算API，方便用于以分布式计算模式进行图计算</p><h2 id="spark运行模式"><a class="markdownIt-Anchor" href="#spark运行模式"></a> Spark运行模式</h2><p>本地模式（单机, Local）【开发测试环境】</p><ul><li>以<strong>一个独立的进程</strong>，通过其内部的多个线程来模拟整个Spark运行时环境</li></ul><p>Standalone模式（集群）</p><ul><li>Spark中的各个角色以<strong>独立进程</strong>的形式存在，并组成Spark集群环境</li></ul><p>Hadoop YARN模式（集群）</p><ul><li>Spark的各个角色运行在<strong>YARN的容器内部</strong>，并组成Spark集群环境</li></ul><p>Kubernetes模式（容器集群）</p><ul><li>Spark中的各个角色<strong>运行在Kubernetes的容器内部</strong>，并组成Spark集群环境</li></ul><p>云服务模式（运行在云平台上）</p><h2 id="spark的架构角色"><a class="markdownIt-Anchor" href="#spark的架构角色"></a> Spark的架构角色</h2><p><img src="https://ganshizhong.gitee.io/blogimages/BigData/Spark/sparkframe.png" alt="sparkframe" /></p><h3 id="yarn-主要有四类角色从2个层面去看"><a class="markdownIt-Anchor" href="#yarn-主要有四类角色从2个层面去看"></a> YARN 主要有四类角色，从2个层面去看：</h3><p>资源管理层面</p><ul><li>集群资源管理者(Master):ResourceManager</li><li>单机资源管理者(Worker):NodeManager</li></ul><p>任务计算层面</p><ul><li>单任务管理者(Master):ApplicationMaster</li><li>单任务执行者(worker):Task(容器内计算框架的工作角色)</li></ul><h3 id="spar-主要有四类角色从2个层面去看"><a class="markdownIt-Anchor" href="#spar-主要有四类角色从2个层面去看"></a> Spar 主要有四类角色，从2个层面去看：</h3><p>资源管理层面</p><ul><li>集群资源管理者(Master)</li><li>单机资源管理者(Worker)</li></ul><p>任务计算层面</p><ul><li>单任务管理者(Driver)</li><li>单任务执行者(Executor)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;spark定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#spark定义&quot;&gt;&lt;/a&gt; Spark定义&lt;/h2&gt;
&lt;p&gt;Apache Spark是用于&lt;strong&gt;大规模数据&lt;/strong&gt;（Large-scala data）处理</summary>
      
    
    
    
    <category term="BigData" scheme="http://shizhonggan.github.io/categories/BigData/"/>
    
    <category term="Spark" scheme="http://shizhonggan.github.io/categories/BigData/Spark/"/>
    
    
  </entry>
  
  <entry>
    <title>那些有点意思的python面试题</title>
    <link href="http://shizhonggan.github.io/2022/04/26/Python/interview1/"/>
    <id>http://shizhonggan.github.io/2022/04/26/Python/interview1/</id>
    <published>2022-04-26T07:00:04.000Z</published>
    <updated>2022-04-26T08:56:55.394Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla</summary>
      
    
    
    
    <category term="Python" scheme="http://shizhonggan.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="http://shizhonggan.github.io/tags/Python/"/>
    
    <category term="面试" scheme="http://shizhonggan.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>基于Ansible API的任务管理web系统</title>
    <link href="http://shizhonggan.github.io/2022/03/18/Ansible/ansible_api/"/>
    <id>http://shizhonggan.github.io/2022/03/18/Ansible/ansible_api/</id>
    <published>2022-03-18T07:35:04.000Z</published>
    <updated>2022-03-18T08:28:38.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://github.com/lfbear/ansible-api">https://github.com/lfbear/ansible-api</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#参考&quot;&gt;&lt;/a&gt; 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lfbear/ansible-api&quot;&gt;https://github.com/lfbea</summary>
      
    
    
    
    <category term="Ansible" scheme="http://shizhonggan.github.io/categories/Ansible/"/>
    
    
    <category term="Ansible" scheme="http://shizhonggan.github.io/tags/Ansible/"/>
    
    <category term="devops" scheme="http://shizhonggan.github.io/tags/devops/"/>
    
    <category term="python3" scheme="http://shizhonggan.github.io/tags/python3/"/>
    
    <category term="django" scheme="http://shizhonggan.github.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>基于Ansible API的任务管理web系统</title>
    <link href="http://shizhonggan.github.io/2022/03/18/Ansible/ansible_ui/"/>
    <id>http://shizhonggan.github.io/2022/03/18/Ansible/ansible_ui/</id>
    <published>2022-03-18T07:35:04.000Z</published>
    <updated>2022-04-27T08:07:43.413Z</updated>
    
    <content type="html"><![CDATA[<p>AWX 是开源的ansible web工具</p><p>该教程是在Centos7/8下完成部署。</p><h2 id="配置selinux"><a class="markdownIt-Anchor" href="#配置selinux"></a> 配置SElinux</h2><p>Centos/RHEL 7/8 在默认情况下 SELiunx是开启状态，这里需要时期失效，将SELinux配置文件中的 SELINUX=enforcing 修改为 SELINUX=disable。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vi &#x2F;etc&#x2F;sysconfig&#x2F;selinux</span><br><span class="line">...</span><br><span class="line">SELINUX&#x3D;disabled</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>保存退出后，reboot重启服务器。</p><h2 id="配置epel源"><a class="markdownIt-Anchor" href="#配置epel源"></a> 配置epel源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y update</span><br><span class="line">yum -y install epel-release</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="所需要的安装包"><a class="markdownIt-Anchor" href="#所需要的安装包"></a> 所需要的安装包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install git gcc gcc-c++ ansible nodejs gettext device-mapper-persistent-data lvm2 bzip2 python3-pip nano wget</span><br></pre></td></tr></table></figure><h2 id="安装docker"><a class="markdownIt-Anchor" href="#安装docker"></a> 安装docker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo –directory-prefix &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line"></span><br><span class="line">yum -y install docker-ce</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">systemctl status docker</span><br><span class="line"></span><br><span class="line">wget https:&#x2F;&#x2F;files.pythonhosted.org&#x2F;packages&#x2F;0b&#x2F;f5&#x2F;be8e741434a4bf4ce5dbc235aa28ed0666178ea8986ddc10d035023744e6&#x2F;pip-20.2.4.tar.gz  #下载安装包</span><br><span class="line">tar -zxvf pip-20.2.4.tar.gz  # 解压</span><br><span class="line">cd pip-20.2.4&#x2F;</span><br><span class="line">sudo python setup.py install #给予权限不然可能安装失败</span><br><span class="line">pip install -U pip #再次更新</span><br><span class="line"></span><br><span class="line">pip install --ignore-installed requests</span><br><span class="line">pip install docker-compose # centos7用pip centos8用</span><br></pre></td></tr></table></figure><h2 id="安装awx"><a class="markdownIt-Anchor" href="#安装awx"></a> 安装AWX</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b 17.1.0 https://github.com/ansible/awx.git</span><br><span class="line">openssl rand -base64 30</span><br><span class="line">    p6gtdhmTKiyObdOM19CCqri2gNxPD+9xLNuyaxHy</span><br><span class="line">vi ~/awx/installer/inventory</span><br><span class="line"><span class="comment">#####</span></span><br><span class="line">postgres_data_dir=”/var/lib/awx/pgdocker”</span><br><span class="line">docker_compose_dir=”/var/lib/awx/awxcompose”</span><br><span class="line"></span><br><span class="line">pg_username=awx</span><br><span class="line">pg_password=Password@123</span><br><span class="line">pg_database=postgres</span><br><span class="line">admin_user=admin</span><br><span class="line">admin_password=Password@123</span><br><span class="line"></span><br><span class="line">secret_key=rVVKN3T9BaLffFhS4/kx8q6nyTiK660L28+yt0px</span><br><span class="line"></span><br><span class="line">awx_alternate_dns_servers=”114.114.114.114″</span><br><span class="line"></span><br><span class="line">project_data_dir=/var/lib/awx/projects</span><br><span class="line"><span class="comment">#####</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook -i ~/awx/installer/inventory ~/awx/installer/install.yml</span><br></pre></td></tr></table></figure><blockquote><p>这里postgre docker容器起不起来，配置文件选择的12版本，修改为10版本就行，同时不做升级操作。网上有解决办法是改成12.1-apline版本，因此根据不同环境，自行选择</p></blockquote><h2 id="完成如下"><a class="markdownIt-Anchor" href="#完成如下"></a> 完成如下</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="防火墙"><a class="markdownIt-Anchor" href="#防火墙"></a> 防火墙</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">## 访问AWX</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;www.abidibo.net&#x2F;blog&#x2F;2012&#x2F;06&#x2F;29&#x2F;deploy-django-applications-nginx-uwsgi-virtualenv-south-git-and-fabric-part-5&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">## 魔改</span><br><span class="line"></span><br><span class="line">### AWX_WEB </span><br></pre></td></tr></table></figure><p>“/home/ec2-user/work/awx_data/awx/awxcompose/nginx.conf:/etc/nginx/nginx.conf:ro”,<br />“/home/ec2-user/work/awx_data/awx/awxcompose/SECRET_KEY:/etc/tower/SECRET_KEY:rw”,<br />“awxcompose_rsyslog-socket:/var/run/awx-rsyslog:rw”,<br />“awxcompose_rsyslog-config:/var/lib/awx/rsyslog:rw”,<br />“awxcompose_supervisor-socket:/var/run/supervisor:rw”,<br />“/home/ec2-user/work/awx_data/awx/projects:/var/lib/awx/projects:rw”,<br />“/home/ec2-user/work/awx_data/awx/awxcompose/credentials.py:/etc/tower/conf.d/credentials.py:rw”,<br />“/home/ec2-user/work/awx_data/awx/awxcompose/redis_socket:/var/run/redis:rw”,<br />“/home/ec2-user/work/awx_data/awx/awxcompose/environment.sh:/etc/tower/conf.d/environment.sh:rw”</p><p>STATIC_ROOT = ‘/var/lib/awx/public/static’</p><p>PROJECTS_ROOT = ‘/var/lib/awx/projects’</p><p>AWX_ANSIBLE_COLLECTIONS_PATHS = ‘/var/lib/awx/vendor/awx_ansible_collections’</p><p>JOBOUTPUT_ROOT = ‘/var/lib/awx/job_status’</p><p>SECRET_KEY = get_secret()</p><p>ALLOWED_HOSTS = [’*’]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>docker exec -it awx_web bash<br />cat /etc/nginx/nginx.conf<br />location /static/ {<br />alias /var/lib/awx/public/static/;<br />}</p><pre><code>    location /favicon.ico &#123; alias /var/lib/awx/public/static/favicon.ico; &#125;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>dnf -y update &amp;&amp;     dnf -y install epel-release ‘dnf-command(config-manager)’ &amp;&amp;     dnf module -y enable ‘postgresql:10’ &amp;&amp;     dnf config-manager --set-enabled powertools &amp;&amp;     dnf -y install ansible     gcc     gcc-c++     git-core     glibc-langpack-en     libcurl-devel     libffi-devel     libtool-ltdl-devel     make     nodejs     nss     openldap-devel     patch     @postgresql:10     postgresql-devel     python3-devel     python3-pip     python3-psycopg2     python3-setuptools     swig     unzip     xmlsec1-devel     xmlsec1-openssl-devel</p><p>ansible-playbook -i installer/inventory installer/build.yml -vvvvvv &amp;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 自定义Ansible Tower LOGO</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;sh</span><br><span class="line"># 上传custom_console_logo.png到&#x2F;var&#x2F;lib&#x2F;awx&#x2F;public&#x2F;static&#x2F;assets&#x2F;</span><br><span class="line">vi &#x2F;var&#x2F;lib&#x2F;awx&#x2F;public&#x2F;static&#x2F;local_settings.json</span><br><span class="line">&#123;  “custom_logo” ： true &#125; # 如何设置为false 或不修改，则无法生效</span><br></pre></td></tr></table></figure><h2 id="awx-1710-部署-参考"><a class="markdownIt-Anchor" href="#awx-1710-部署-参考"></a> awx 17.1.0 部署 参考</h2><p><a href="https://n-guitar.hatenablog.com/entry/2021/10/16/020000">https://n-guitar.hatenablog.com/entry/2021/10/16/020000</a></p><p><a href="https://mpolinowski.github.io/devnotes/2021-04-28-ansible-tower-rhel">https://mpolinowski.github.io/devnotes/2021-04-28-ansible-tower-rhel</a></p><h2 id="免密登录"><a class="markdownIt-Anchor" href="#免密登录"></a> 免密登录</h2><p>使用方法参考文献</p><p>免密登录</p><p><a href="https://blog.csdn.net/qq_36830911/article/details/108107926">https://blog.csdn.net/qq_36830911/article/details/108107926</a></p><p><a href="http://t.zoukankan.com/Nanaya-p-13202946.html">http://t.zoukankan.com/Nanaya-p-13202946.html</a></p><p>使用方法</p><p><a href="https://blog.51cto.com/u_10616534/2407182">https://blog.51cto.com/u_10616534/2407182</a></p><p><a href="https://www.onitroad.com/jc/ya/ansible/how-to-add-new-inventory-create-host-credential-awx-ansible-tower.html">https://www.onitroad.com/jc/ya/ansible/how-to-add-new-inventory-create-host-credential-awx-ansible-tower.html</a></p><p><a href="https://www.unixarena.com/2018/12/awx-ansible-tower-inventory-bulk-hosts-import.html/">https://www.unixarena.com/2018/12/awx-ansible-tower-inventory-bulk-hosts-import.html/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;AWX 是开源的ansible web工具&lt;/p&gt;
&lt;p&gt;该教程是在Centos7/8下完成部署。&lt;/p&gt;
&lt;h2 id=&quot;配置selinux&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#配置selinux&quot;&gt;&lt;/a&gt; 配置SElinux&lt;/h</summary>
      
    
    
    
    <category term="Ansible" scheme="http://shizhonggan.github.io/categories/Ansible/"/>
    
    
    <category term="Ansible" scheme="http://shizhonggan.github.io/tags/Ansible/"/>
    
    <category term="devops" scheme="http://shizhonggan.github.io/tags/devops/"/>
    
    <category term="python3" scheme="http://shizhonggan.github.io/tags/python3/"/>
    
    <category term="django" scheme="http://shizhonggan.github.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>Django RESTframework 教程</title>
    <link href="http://shizhonggan.github.io/2022/03/16/Django/DjangoRESTframework/"/>
    <id>http://shizhonggan.github.io/2022/03/16/Django/DjangoRESTframework/</id>
    <published>2022-03-16T03:03:04.000Z</published>
    <updated>2022-04-02T09:03:36.097Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p><img src="https://ganshizhong.gitee.io/blogimages/Django/web1.png" alt="前后端不分离" /></p><p><img src="https://ganshizhong.gitee.io/blogimages/Django/web2.png" alt="前后端分离" /></p><h2 id="序列化和反序列化"><a class="markdownIt-Anchor" href="#序列化和反序列化"></a> 序列化和反序列化</h2><p>序列化：将程序中的一个数据结构转化为其他格式（字典、JSON、xml等），例如django中将模型类对象转化为JSON字符串，这一过程被称为序列化。增改查，删不用返回</p><p>反序列化：修改和新增</p><ul><li>增：校验请求数据-&gt; 执行反序列化 -&gt; 保存数据库 -&gt; 将保存的对象序列化输出</li><li>删：判断要删除的数据是否存在 -&gt; 执行数据库删除</li><li>改：判断要修改的数据是否存在  -&gt; 校验请求的数据 -&gt; 执行反序列化过程 -&gt; 保存数据库 -&gt; 将保存的对象序列化返回</li><li>查：查询数据库 -&gt; 将数据库序列化返回</li></ul><h2 id="drf作用"><a class="markdownIt-Anchor" href="#drf作用"></a> DRF作用</h2><p>Django REST framework 可以帮助我们简化序列化和反序列化部分的代码编写，大大提高REST API的开发速度。</p><h2 id="drf特点"><a class="markdownIt-Anchor" href="#drf特点"></a> DRF特点</h2><ul><li>提供了定义序列化器Serializer的方法，可以快速根据Django ORM 或者其他库自动序列化/反序列化</li><li>提供了丰富的类视图、Mixin扩展类，简化视图的编写</li><li>丰富的定制层级：函数视图、类视图、试图集合到自动生成API，满足各种需求</li><li>多种身份认证和权限认证方式的支持</li><li>内置了限流系统</li><li>直观的API web界面</li><li>可扩展性，插件丰富</li></ul><h2 id="相关文档"><a class="markdownIt-Anchor" href="#相关文档"></a> 相关文档</h2><p>官方文档： <a href="http://www.django-rest-framework.org/">http://www.django-rest-framework.org/</a></p><p>源码：<a href="https://github.com/encode/django-rest-framework/tree/master">https://github.com/encode/django-rest-framework/tree/master</a></p><h2 id="drf安装使用"><a class="markdownIt-Anchor" href="#drf安装使用"></a> DRF安装使用</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 环境依赖</span></span><br><span class="line">pip install djangorestframework</span><br><span class="line">pip install markdown       <span class="comment"># Markdown support for the browsable API.</span></span><br><span class="line">pip install django-filter  <span class="comment"># Filtering support</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Add &#x27;rest_framework&#x27; to your INSTALLED_APPS setting.</span></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;rest_framework&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">## If you&#x27;re intending to use the browsable API you&#x27;ll probably also want to add REST framework&#x27;s login and logout views. Add the following to your root urls.py file.</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">    path(<span class="string">&#x27;api-auth/&#x27;</span>, include(<span class="string">&#x27;rest_framework.urls&#x27;</span>)) <span class="comment"># Note that the URL path can be whatever you want.</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">## </span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># Use Django&#x27;s standard `django.contrib.auth` permissions,</span></span><br><span class="line">    <span class="comment"># or allow read-only access for unauthenticated users.</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_PERMISSION_CLASSES&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加路由</span></span><br><span class="line">from django.urls import path, include</span><br><span class="line">from django.contrib.auth.models import User</span><br><span class="line">from rest_framework import routers, serializers, viewsets</span><br><span class="line"></span><br><span class="line"><span class="comment"># Serializers define the API representation.</span></span><br><span class="line">class UserSerializer(serializers.HyperlinkedModelSerializer):</span><br><span class="line">    class Meta:</span><br><span class="line">        model = User</span><br><span class="line">        fields = [<span class="string">&#x27;url&#x27;</span>, <span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;is_staff&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ViewSets define the view behavior.</span></span><br><span class="line">class UserViewSet(viewsets.ModelViewSet):</span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    serializer_class = UserSerializer</span><br><span class="line"></span><br><span class="line"><span class="comment"># Routers provide an easy way of automatically determining the URL conf.</span></span><br><span class="line">router = routers.DefaultRouter()</span><br><span class="line">router.register(r<span class="string">&#x27;users&#x27;</span>, UserViewSet)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Wire up our API using automatic URL routing.</span></span><br><span class="line"><span class="comment"># Additionally, we include login URLs for the browsable API.</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, include(router.urls)),</span><br><span class="line">    path(<span class="string">&#x27;api-auth/&#x27;</span>, include(<span class="string">&#x27;rest_framework.urls&#x27;</span>, namespace=<span class="string">&#x27;rest_framework&#x27;</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="drf-序列化器"><a class="markdownIt-Anchor" href="#drf-序列化器"></a> DRF 序列化器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class BookInfo(models.Model):</span><br><span class="line">    btitle &#x3D; models.CharField(max_length&#x3D;30, verbose_name &#x3D;&#39;名称&#39;)</span><br><span class="line">    bup_date &#x3D; models.DateField(auto_now&#x3D;True, verbose_name&#x3D;&#39;发布日期&#39;)</span><br><span class="line"></span><br><span class="line">## 自定义序列化器</span><br><span class="line">class BookInfoSerializer1(serializers.Serializer):</span><br><span class="line">    # read_only&#x3D;True 只做序列化 write_only&#x3D;True 只做反序列化</span><br><span class="line">    id &#x3D; serializers.IntegerField(label&#x3D;&quot;ID&quot;, read_only&#x3D;True)</span><br><span class="line">    btitle &#x3D; serializers.CharField(max_length&#x3D;30, label&#x3D;&#39;名称&#39;,required&#x3D;True)</span><br><span class="line">    bup_date &#x3D; serializers.DateField(label&#x3D;&#39;发布日期&#39;)</span><br><span class="line">    hello &#x3D; serializers.CharField(max_length&#x3D;10) # 新添加的字段</span><br><span class="line"></span><br><span class="line">from booktest.serializers import BookInfoSerializer, HeroInfoSerializer</span><br><span class="line">from booktest.models import BookInfo, HeroInfo</span><br><span class="line">book &#x3D; BookInfo.objects.get(id&#x3D;1)</span><br><span class="line">s &#x3D; BookInfoSerializer1(instance&#x3D;book, many&#x3D;False)</span><br><span class="line">s.data</span><br><span class="line"></span><br><span class="line">books &#x3D; BookInfo.objects.all()</span><br><span class="line">s &#x3D; BookInfoSerializer1(instance&#x3D;books, many&#x3D;True)</span><br><span class="line">s.data</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>序列化器中的字段个数可以与模型的属性个数不同<ul><li>可以添加不存在的，也可以不写，但是不能修改</li></ul></li><li>创建序列化器有两个参数BookInfoSerializer(instance, data)<ul><li>S = BookInfoSerializer(instance=book, many=true) 只做序列化， S.data 可以取值<ul><li>序列化 == 模型数据 -&gt; python字典（用于输出，返回数据给前端）</li></ul></li><li>S = BookInfoSerializer(data=data) 只做反序列化<ul><li>反序列化 == 前端发送的数据 -&gt; 经过验证 -&gt; python字典 -&gt;save -&gt;模型类对象（用于输入，接受前端数据）</li></ul></li></ul></li></ul><blockquote><p>jsonresponse 如果返回的是列表，safe=False; 序列化如果是一个查询集合，many=True</p></blockquote><h2 id="drf-关联序列化"><a class="markdownIt-Anchor" href="#drf-关联序列化"></a> DRF 关联序列化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 只能序列化输出, 默认是将关联模型的ID序列化</span><br><span class="line">hbook &#x3D; serializers.PrimaryKeyRelatedField(label&#x3D;&quot;书籍&quot;,read_only&#x3D;True) </span><br><span class="line"></span><br><span class="line"># 默认是将关联模型的__str__方法返回值序列化</span><br><span class="line">hbook &#x3D; serializers.StringRelatedField(label&#x3D;&quot;书籍&quot;, read_only&#x3D;True)  </span><br><span class="line"></span><br><span class="line"># 关联模型对象的序列化器中所有字段序列化出来</span><br><span class="line">hbook &#x3D; BookInfoSerializer1(read_only&#x3D;True) </span><br><span class="line"></span><br><span class="line"># 如果一里面关联序列化多时，需要指定many&#x3D;True</span><br><span class="line">heroinfo_set &#x3D; HeroInfoSerializer1(many&#x3D;True)</span><br></pre></td></tr></table></figure><blockquote><p>两个序列化器只能一个做关联</p></blockquote><h2 id="drf-反序列化"><a class="markdownIt-Anchor" href="#drf-反序列化"></a> DRF 反序列化</h2><ul><li>is_valid()方法 ：在获取序列化的数据前，通过该方法进行验证</li><li>errors属性: 验证失败，可以通过序列化器对象的errors属性获取错误信息，返回字典</li><li>validated_data属性： 验证成功，获取数据</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;btitle&#x27;</span>: <span class="string">&#x27;三国&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">serializer = BookInfoSerializer(data=data)</span><br><span class="line">serializer.is_valid() <span class="comment"># 调用序列化器的校验方法， True或False【必须执行】</span></span><br><span class="line">serializer.is_valid(raise_exception=<span class="literal">True</span>) <span class="comment"># 校验出错后，自动抛出错误信息</span></span><br><span class="line">serializer.errors <span class="comment"># 获取校验的错误信息，可不用，用上面这一个</span></span><br><span class="line">serializer.validated_data <span class="comment"># 获取反序列化校验后的数据还是字典【然后执行】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 额外对某些字段进行校验</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoSerializer1</span>(<span class="params">serializers.Serializer</span>):</span></span><br><span class="line">    <span class="comment"># read_only=True 只做序列化 write_only=True 只做反序列化</span></span><br><span class="line">    <span class="built_in">id</span> = serializers.IntegerField(label=<span class="string">&quot;ID&quot;</span>, read_only=<span class="literal">True</span>)</span><br><span class="line">    btitle = serializers.CharField(max_length=<span class="number">30</span>, label=<span class="string">&#x27;名称&#x27;</span>,required=<span class="literal">True</span>)</span><br><span class="line">    bup_date = serializers.DateField(label=<span class="string">&#x27;发布日期&#x27;</span>)</span><br><span class="line">    hello = serializers.CharField(max_length=<span class="number">10</span>) <span class="comment"># 新添加的字段</span></span><br><span class="line">    <span class="comment">## 以下是反序列化进行的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_btitle</span>(<span class="params">self, value</span>):</span> <span class="comment"># 对某字段单独添加校验，注意命名</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;django&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> value.lower():</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&quot;图书不是关于Django的&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span>(<span class="params">self, attrs</span>):</span></span><br><span class="line">        <span class="comment"># 多个字段进行联合校验</span></span><br><span class="line">        attrs[<span class="string">&quot;hello&quot;</span>] = <span class="string">&quot;word&quot;</span> <span class="comment"># 添加数据   </span></span><br><span class="line">        <span class="keyword">return</span> attrs </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">validate_btitle</span>(<span class="params">self, value</span>):</span> <span class="comment"># 对某字段单独添加校验，注意命名</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;django&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> value.lower():</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&quot;图书不是关于Django的&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self, validated_data</span>):</span></span><br><span class="line">        <span class="comment"># validated_data 反序列化校验后的字典型数据</span></span><br><span class="line">        <span class="comment"># 当调用序列化器的save方法时，如果当初创建序列化器对象是没有给instance传参数</span></span><br><span class="line">        book = BookInfo.objects.create(**validated_data)</span><br><span class="line">        BookInfo.objects.create(**&#123;<span class="string">&#x27;btitle&#x27;</span>:<span class="string">&#x27;三国&#x27;</span>&#125;) <span class="comment"># 将字典 转换成 关键字=value 这种格式</span></span><br><span class="line">        BookInfo.objects.create(</span><br><span class="line">            btitle=<span class="string">&quot;三国&quot;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> book</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, instance, validated_data</span>):</span></span><br><span class="line">        <span class="comment"># 如果传入参数，实际上会调用该方法</span></span><br><span class="line">        instance.btitle = validated_data.get(<span class="string">&#x27;btitle&#x27;</span>)</span><br><span class="line">        instance.save()</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line"><span class="comment">## 校验成功后操作</span></span><br><span class="line">serializer.save() <span class="comment"># 会执行序列化器中的create方法或update方法</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://ganshizhong.gitee.io/blogimages/Django/web1.png&quot; alt=&quot;</summary>
      
    
    
    
    <category term="Django" scheme="http://shizhonggan.github.io/categories/Django/"/>
    
    
    <category term="Django" scheme="http://shizhonggan.github.io/tags/Django/"/>
    
    <category term="RESTful" scheme="http://shizhonggan.github.io/tags/RESTful/"/>
    
    <category term="API" scheme="http://shizhonggan.github.io/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>基于docker部署的gitlab迁移</title>
    <link href="http://shizhonggan.github.io/2022/03/16/Docker/gitlabmigrate/"/>
    <id>http://shizhonggan.github.io/2022/03/16/Docker/gitlabmigrate/</id>
    <published>2022-03-16T03:03:04.000Z</published>
    <updated>2022-07-26T07:53:38.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>准备一台新云主机，系统centos7.6，挂载一块硬盘（以往经验挺耗内存的）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#0. 挂载硬盘</span></span><br><span class="line">fdisk -l <span class="comment"># 查看磁盘</span></span><br><span class="line">fdisk /dev/vdc <span class="comment"># 对磁盘进行分区</span></span><br><span class="line">n</span><br><span class="line">e <span class="comment"># 选择拓展分区</span></span><br><span class="line">w <span class="comment"># 退出</span></span><br><span class="line">fdisk /dev/vdc </span><br><span class="line">n </span><br><span class="line">l <span class="comment"># 创建逻辑分区</span></span><br><span class="line">w <span class="comment"># 退出</span></span><br><span class="line">vi /etc/fstab <span class="comment"># 修改挂载配置文件信息，添加：</span></span><br><span class="line">/etc/vdc5 /../work/ default 0 0 <span class="comment"># 绝对路径</span></span><br><span class="line">mount /etc/vdc5 /../work/ <span class="comment"># 挂载重启也无事</span></span><br><span class="line"><span class="comment">#1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过 uname -r 命令查看你当前的内核版本</span></span><br><span class="line"></span><br><span class="line">$ uname -r</span><br><span class="line"><span class="comment"># 2、使用 root 权限登录 Centos。确保 yum 包更新到最新。</span></span><br><span class="line"></span><br><span class="line">$ sudo yum update</span><br><span class="line"><span class="comment">#3、卸载旧版本(如果安装过旧版本的话)</span></span><br><span class="line"></span><br><span class="line">$ sudo yum remove docker  docker-common docker-selinux docker-engine</span><br><span class="line"><span class="comment">#4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</span></span><br><span class="line"></span><br><span class="line">$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="comment">#5、设置yum源</span></span><br><span class="line"></span><br><span class="line">$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment">#6、可以查看所有仓库中所有docker版本，并选择特定版本安装</span></span><br><span class="line"></span><br><span class="line">$ yum list docker-ce --showduplicates | sort -r</span><br><span class="line"></span><br><span class="line"><span class="comment">#7、安装docker</span></span><br><span class="line"></span><br><span class="line">$ sudo yum install docker-ce  <span class="comment">#由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0</span></span><br><span class="line">$ sudo yum install &lt;FQPN&gt;  <span class="comment"># 例如：sudo yum install docker-ce-17.12.1.ce</span></span><br><span class="line">sudo yum install docker-ce-17.12.1.ce</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改docker.service配置文件，在EXECStart的后面增加 --graph=/data/docker(修改后的docker存储路径)。</span></span><br><span class="line"><span class="comment"># 方法一：【这个比较好】</span></span><br><span class="line">cat /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;data-root&quot;</span>: <span class="string">&quot;/home/ec2-user/work/docker&quot;</span>,</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;http://hub-mirror.c.163.com&quot;</span>], <span class="comment"># 这个下载速度挺快</span></span><br><span class="line">  <span class="string">&quot;mtu&quot;</span>: 1400</span><br><span class="line">&#125;</span><br><span class="line">方法二：【一般】</span><br><span class="line">vim /usr/lib/systemd/system/docker.service</span><br><span class="line">......</span><br><span class="line">ExecStart=/usr/bin/dockerd --graph=/data/docker</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行下列命令然后重启docker</span></span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">disable</span> docker.service</span><br><span class="line">systemctl <span class="built_in">enable</span> docker.service</span><br></pre></td></tr></table></figure><h2 id="搭建私人git仓库"><a href="#搭建私人git仓库" class="headerlink" title="搭建私人git仓库"></a>搭建私人git仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --detach \</span><br><span class="line">  --hostname gitlab.ganshizhong.com \</span><br><span class="line">  --publish 8011:80 --publish 8010:22 \</span><br><span class="line">  --name gitlab \</span><br><span class="line">  --restart always \</span><br><span class="line">  --volume /home/ec2-user/work/gitlab/config:/etc/gitlab \</span><br><span class="line">  --volume /home/ec2-user/work/gitlab/logs:/var/<span class="built_in">log</span>/gitlab \</span><br><span class="line">  --volume /home/ec2-user/work/gitlab/data:/var/opt/gitlab \</span><br><span class="line">  --shm-size 256m \</span><br><span class="line">  gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure><h2 id="更换远程仓库地址"><a href="#更换远程仓库地址" class="headerlink" title="更换远程仓库地址"></a>更换远程仓库地址</h2><p>首先进入项目所在文件夹，右键git bash</p><p>（1）查看当前的远程地址</p><pre><code>      git remote -v</code></pre><p>（2）删除当前的远程地址</p><pre><code>     git remote rm origin</code></pre><p>（3）添加远程地址</p><p>  git remote add origin <a href="http://119.255.249.177:8011/ganshizhong/sinnet.git">http://119.255.249.177:8011/ganshizhong/sinnet.git</a>     (git@…)</p><p>（*4）首次推代码</p><pre><code>     git push -u origin master</code></pre><p><a href="http://119.255.249.177:8011/ganshizhong/sinnet">http://119.255.249.177:8011/ganshizhong/sinnet</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;p&gt;准备一台新云主机，系统centos7.6，挂载一块硬盘（以往经验挺耗内存的）&lt;/p&gt;
&lt;figure class=&quot;high</summary>
      
    
    
    
    <category term="Docker" scheme="http://shizhonggan.github.io/categories/Docker/"/>
    
    
    <category term="docker" scheme="http://shizhonggan.github.io/tags/docker/"/>
    
    <category term="gitlab" scheme="http://shizhonggan.github.io/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>Python 内存管理 &amp; 垃圾回收</title>
    <link href="http://shizhonggan.github.io/2022/03/09/Python/memoryManagement/"/>
    <id>http://shizhonggan.github.io/2022/03/09/Python/memoryManagement/</id>
    <published>2022-03-09T06:39:04.000Z</published>
    <updated>2022-03-09T09:03:39.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="非人话定义"><a class="markdownIt-Anchor" href="#非人话定义"></a> 非人话定义</h2><ul><li>引用计数器为主</li><li>标记清楚和分代回收为辅</li><li><ul><li>缓存机制</li></ul></li></ul><h2 id="python-垃圾回收"><a class="markdownIt-Anchor" href="#python-垃圾回收"></a> Python 垃圾回收</h2><h3 id="引用计数器"><a class="markdownIt-Anchor" href="#引用计数器"></a> 引用计数器</h3><h4 id="1-环状的双向链表-refchain-循环双向链表"><a class="markdownIt-Anchor" href="#1-环状的双向链表-refchain-循环双向链表"></a> <strong>1. 环状的双向链表 refchain , 循环双向链表</strong></h4><p>python 创建的任何对象都会放在refchain链表中。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">&quot;gsz&quot;</span></span><br><span class="line">age=<span class="number">27</span></span><br><span class="line">hobby =[<span class="string">&quot;游泳&quot;</span>]</span><br><span class="line"></span><br><span class="line">name=<span class="string">&quot;gsz&quot;</span> 内部会创建一些数据【上一个对象、下一个对象、类型、引用的个数】</span><br><span class="line">new= name 这个时候new会直接应用，并且引用个数+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">age=<span class="number">27</span> 内部会创建一些数据【上一个对象、下一个对象、类型、引用的个数、value=<span class="number">18</span>】</span><br><span class="line"></span><br><span class="line">hobby =[<span class="string">&quot;游泳&quot;</span>] 内部会创建一些数据【上一个对象、下一个对象、类型、引用的个数、items=元素、元素个数】</span><br></pre></td></tr></table></figure><p>在C源码中，通过**PyObject结构体（4个值）**体现每个对象都有相同的值</p><p>多个元素组成的对象，<strong>PyObject</strong>+<strong>ob_size</strong></p><h4 id="2-类型封装结构"><a class="markdownIt-Anchor" href="#2-类型封装结构"></a> <strong>2. 类型封装结构</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data&#x3D;3.14</span><br><span class="line"></span><br><span class="line">内部会创建：</span><br><span class="line">    _ob_pre &#x3D; refchain中的上一个对象</span><br><span class="line">    _ob_next &#x3D; refchain中的下一个对象</span><br><span class="line">    ob_refcnt&#x3D;1</span><br><span class="line">    ob_type&#x3D;float</span><br><span class="line">    ob_fval &#x3D; 3.13</span><br></pre></td></tr></table></figure><h4 id="3-引用计数器"><a class="markdownIt-Anchor" href="#3-引用计数器"></a> <strong>3. 引用计数器</strong></h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v1 =<span class="number">3.14</span></span><br><span class="line">v2=<span class="number">999</span></span><br><span class="line">v3=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>python程序运行时，会根据数据类型的不同找到其对应的结构体，根据结构体中的字段来进行创建相关的数据，然后将对象添加refchain双线链表中。</p><p>在C源码中有两个关键的结构体，PyObject,PyVarObject</p><p>每个对象中有ob_refcnt就是引用计数器，默认值为1，当其他变量引用对象时，应用计数器就会发生变化。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引用</span></span><br><span class="line">a=<span class="number">999</span></span><br><span class="line">b=a <span class="comment"># 计数器+1</span></span><br><span class="line"><span class="comment"># 删除引用</span></span><br><span class="line">a=<span class="number">999</span></span><br><span class="line">b=a  <span class="comment"># a和b指向同一个对象</span></span><br><span class="line"><span class="keyword">del</span> b <span class="comment"># b变量删除，b对应对象引用计数器-1</span></span><br><span class="line"><span class="keyword">del</span> a <span class="comment"># a变量删除，a对应对象引用计数器-1</span></span><br></pre></td></tr></table></figure><blockquote><p>当一个对象的引用计数器为0时，意味着没有人在使用这个对象了，这个对象就是垃圾，然后进行垃圾回收。<br />回收：1.将对象从reflchain链表移除；2.将对象销毁，内存归还。</p></blockquote><h4 id="4-循环引用存在问题"><a class="markdownIt-Anchor" href="#4-循环引用存在问题"></a> <strong>4. 循环引用存在问题</strong></h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">v2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">v1.append(v2) <span class="comment"># 引用计数器+1=2</span></span><br><span class="line">v2.append(v1) <span class="comment"># 引用计数器+1=2</span></span><br><span class="line"><span class="keyword">del</span> v1 <span class="comment"># 引用计数器-1</span></span><br><span class="line"><span class="keyword">del</span> v2 <span class="comment"># 引用计数器-1</span></span><br></pre></td></tr></table></figure><blockquote><p>此时，变量v1,v2删除，但是指向的数据对象并没有销毁，这些数据一直存在内存中</p></blockquote><h3 id="标记清除"><a class="markdownIt-Anchor" href="#标记清除"></a> 标记清除</h3><p>目的：为了解决引用计数器循环引用的不足</p><p>实现方法： 在python的底层再维护一个链表，链表中专门放那些可能存在循环引用的对象（list,tuple,dict,set等可能被引用的数据）</p><p>在python内部 某种情况下触发，会去扫描 可能存在循环应用的链表中的每个元素，检查是否有循环引用，如果有让双方的引用计数器-1；如果是0则垃圾回收。</p><p>也存在问题：</p><ul><li>什么时候扫描？</li><li>链表扫描代价大，耗时久</li></ul><h3 id="分代回收"><a class="markdownIt-Anchor" href="#分代回收"></a> 分代回收</h3><ol><li>将可能存在循环引用的对象维护成三个链表：<ul><li>0代： 0代中对象个数达到700个扫描一次</li><li>1代： 0代扫描10次，1代扫描一次</li><li>2代： 1代扫描10次，2代扫描一次</li></ul></li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>python中维护了一个refchain的双向环状链表，这个链表中存储程序创建的对象，每种类型的对象中都有一个ob_refcnt引用计数器的值，引用个数+1，-1，最后当引用计数器变为0时会进行垃圾回收（对象销毁、refchain中移除）</p><p>但是，在python中对于那些可以有多个元素组成的对象会存在循环引用的问题，为了解决这个问题python又引用标记清除和分代回收，在内部为四个链表。</p><p>在源码内部当达到各自的阈值，就会触发扫描链表进行标记清除的东走（有循环则各自-1）</p><p><strong>但是，源码内部在上述的流程中提出了优化机制</strong></p><h3 id="缓存机制"><a class="markdownIt-Anchor" href="#缓存机制"></a> 缓存机制</h3><h4 id="1-池"><a class="markdownIt-Anchor" href="#1-池"></a> <strong>1. 池</strong></h4><p>为了避免重复创建和销毁常见对象，维护池。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动解释器时，python内部会帮助创建-5，-4，...257</span></span><br><span class="line">v1 = <span class="number">7</span> <span class="comment"># 内部不会开辟，直接去池中获取</span></span><br><span class="line">v2 = <span class="number">9</span> <span class="comment"># 内部不会开辟，直接去池中获取</span></span><br><span class="line">v3 = <span class="number">9</span> <span class="comment"># 内部不会开辟，直接去池中获取</span></span><br></pre></td></tr></table></figure><h4 id="2-free_listfloatlisttupledict"><a class="markdownIt-Anchor" href="#2-free_listfloatlisttupledict"></a> <strong>2. free_list（float/list/tuple/dict）</strong></h4><p>当一个对象的引用计数器为0时，按理说应该回收，但内部不会直接回收，而是将对象添加到free_list链表中当缓存，以后再创建对象时，不会重新开辟内存，而是直接使用free_list</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v1 = <span class="number">3.14</span> <span class="comment"># 开辟内存，内部存储结构体中定义的那几个值，并存到refchain中</span></span><br><span class="line"><span class="keyword">del</span> v1  <span class="comment"># refchain中移除，将对象添加到free_list中，当free_list满了则销毁</span></span><br><span class="line">v9 =<span class="number">99.99</span> <span class="comment"># 不会重新开辟内存，去free_list中获取对象，对象内部数据初始化，再放到refchain中</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://pythonav.com/wiki/detail/6/88/">https://pythonav.com/wiki/detail/6/88/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;非人话定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#非人话定义&quot;&gt;&lt;/a&gt; 非人话定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;引用计数器为主&lt;/li&gt;
&lt;li&gt;标记清楚和分代回收为辅&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;缓存机制&lt;/li&gt;</summary>
      
    
    
    
    <category term="Python" scheme="http://shizhonggan.github.io/categories/Python/"/>
    
    
    <category term="python" scheme="http://shizhonggan.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python发布包和模块--setup.py</title>
    <link href="http://shizhonggan.github.io/2022/03/09/Python/setup/"/>
    <id>http://shizhonggan.github.io/2022/03/09/Python/setup/</id>
    <published>2022-03-09T06:39:04.000Z</published>
    <updated>2022-03-24T09:07:18.654Z</updated>
    
    
    
    
    <category term="Python" scheme="http://shizhonggan.github.io/categories/Python/"/>
    
    
    <category term="python" scheme="http://shizhonggan.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python 并发编程</title>
    <link href="http://shizhonggan.github.io/2022/02/25/Python/concurrentprogramming/"/>
    <id>http://shizhonggan.github.io/2022/02/25/Python/concurrentprogramming/</id>
    <published>2022-02-25T08:39:04.000Z</published>
    <updated>2022-02-25T06:10:49.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发编程"><a class="markdownIt-Anchor" href="#并发编程"></a> 并发编程</h2><h3 id="并发编程程序提速方法"><a class="markdownIt-Anchor" href="#并发编程程序提速方法"></a> 并发编程，程序提速方法：</h3><ul><li>单线程串行<ul><li>不加改造的程序</li><li>CPU-IO-CPU-IO… IO期间CPU是等待状态的</li></ul></li><li>多线程并发<ul><li>threading</li><li>IO的同时让CPU进行其他任务，IO执行完CPU执行下一步任务</li></ul></li><li>多CPU并行<ul><li>multiprocessing</li><li>每个CPU都可以 CPU-IO…</li></ul></li><li>多机器并行<ul><li>hadoop/hive/spark</li><li></li></ul></li></ul><p><a href="https://blog.csdn.net/chenkaifang/article/details/80961211">https://blog.csdn.net/chenkaifang/article/details/80961211</a><br /><a href="https://www.dongwm.com/archives">https://www.dongwm.com/archives</a></p><h3 id="python-对并发编程的支持"><a class="markdownIt-Anchor" href="#python-对并发编程的支持"></a> python 对并发编程的支持</h3><ul><li><p>多线程：threading, 利用CPU和IO可以同时执行的原理，让CPU在IO的同时执行其他任务</p></li><li><p>多进程：multiprocessing, 利用多核CPU的能力，真正的并行执行任务</p></li><li><p>异步IO: asyncio, 在单线程利用CPU和IO同时执行的原理，实现函数异步执行</p></li><li><p>使用Lock对资源加锁，防止冲突访问</p></li><li><p>使用Queue实现不同线程/进程之间的数据通信，实现生产者-消费者模式</p><ul><li>改造爬虫，边爬虫-边解析</li></ul></li><li><p>使用线程池Pool/进程池Pool，简化线程/进程的任务提交，等待结束、获取结果</p></li><li><p>使用subprocess启动外部程序的京城，并进行输入输出交互</p></li></ul><h3 id="cpu密集型计算-io密集型计算"><a class="markdownIt-Anchor" href="#cpu密集型计算-io密集型计算"></a> CPU密集型计算、IO密集型计算</h3><ul><li>CPU密集型（CPU-bound）<ul><li>也叫计算密集型，是指I/O在很短的时间就可以完成，CPU需要大量的计算和处理，特点CPU占用率很高；</li><li>例如：压缩解压缩、加密解密、正则表达式搜索</li></ul></li><li>IO密集型（I/O bound）<ul><li>IO密集型指的是系统运作大部分的状况是CPU在等待I/O（硬盘/内存）的读写操作，CPU占用率仍然较低。</li><li>例如：文件处理程序（文件读取），网络爬虫程序（大量的下载）、多谢数据库程序</li></ul></li></ul><h3 id="多线程-多进程-多协程的对比"><a class="markdownIt-Anchor" href="#多线程-多进程-多协程的对比"></a> 多线程、多进程、多协程的对比</h3><ul><li>多进程Process(multiprocessing)<ul><li>优点：可以利用多核CPU并行运算</li><li>缺点：占用资源最多、可启动数目比线程少</li><li>适用于：CPU密集型计算</li></ul></li><li>多线程Thread(threadin)<ul><li>优点：相比进程，更轻量级，占用资源少</li><li>缺点：（Python多线程只能同时用一个CPU）<ul><li>相比进程：多线程只能并发执行，不能利用多CPU（GIL);</li><li>相比协程：启动数目有限制，占用内存资源，有线程切换开销</li></ul></li><li>适用于：IO密集型计算、同时运行的任务数目要求不多</li></ul></li><li>多协程Coroutine(asyncio)<ul><li>优点：内存开销最少、启动协程数量最多</li><li>缺点：支持的库有限制（aiohttp vs requests）、代码实现复杂</li><li>适用于: IO密集型计算、需要超多任务运行、但有现成库支持的场景</li></ul></li></ul><p>一个<strong>进程</strong>中可以启动N个<strong>线程</strong>，一个线程中可以启动N个<strong>协程</strong></p><h3 id="根据任务选择对应技术"><a class="markdownIt-Anchor" href="#根据任务选择对应技术"></a> 根据任务选择对应技术</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> CPU密集型：</span><br><span class="line">    使用多进程Multiprocessing</span><br><span class="line"><span class="keyword">elif</span> IP密集型：</span><br><span class="line">    <span class="keyword">if</span> 任务多 <span class="keyword">and</span> 有协程库支持 <span class="keyword">and</span> 协程实现复杂度不高：</span><br><span class="line">        使用多协程asyncio</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        使用多线程threading</span><br></pre></td></tr></table></figure><h2 id="python被吐槽慢头号嫌疑犯全局解释器锁gil"><a class="markdownIt-Anchor" href="#python被吐槽慢头号嫌疑犯全局解释器锁gil"></a> Python被吐槽慢，头号嫌疑犯，全局解释器锁GIL</h2><p>相比C/C++/JAVA,Python确实慢，在一些特殊场景下，Python比C++慢100~200倍</p><p>由于速度慢的原因，很多公司的基础架构代码依然用C/C++开发<br />比如各大公司阿里/腾讯/快手的推荐引擎、搜索引擎、存储引擎等底层对性能要求高的模块</p><p>Python速度慢两大原因：</p><ul><li>动态类型语言，边解释边执行，一个变量可以做数字、字符串或者列表，所以执行过程中都要检查变量类型，导致很慢</li><li>GIL无法利用多核CPU并发执行</li></ul><h3 id="gil"><a class="markdownIt-Anchor" href="#gil"></a> GIL</h3><p>全局解释器锁（Global Interpreter Lock, GIL），是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行，即便在多核心处理上，使用GIL的解释器也只允许同一时间执行一个线程。</p><p><img src="https://ganshizhong.gitee.io/blogimages/Python/concurrentprogramming/GIL.png" alt="http://www.dabeaz.com/python/UnderstandingGIL.pdf" /></p><p>GIL的存在，即使电脑有多核CPU，单个时刻也只能使用1个，相比并发加速的C/C++慢</p><h3 id="为什么有gil这个东西"><a class="markdownIt-Anchor" href="#为什么有gil这个东西"></a> 为什么有GIL这个东西</h3><p>python设计初期，为了规避并发问题引入了GIL，现在想去除去不掉了</p><p>为了解决多线程之间数据完整性和状态同步问题</p><p>python中对象的管理，是使用引用计数器进行的，引用数为0则释放对象</p><p>开始：线程A和线程B都引用了对象obj, obj.ref_num=2, 线程A和B都想撤销对obj的引用</p><p><img src="https://ganshizhong.gitee.io/blogimages/Python/concurrentprogramming/GILreason.png" alt="whyGIL" /></p><p><strong>GIL确实有好处：简化了Python对共享资源的管理</strong></p><h3 id="如何规避gil带来的限制"><a class="markdownIt-Anchor" href="#如何规避gil带来的限制"></a> 如何规避GIL带来的限制</h3><ol><li>多线程threading机制依然是有用的，用于IO密集型计算<ul><li>因为I/O(read,write,send,recv,etc.)期间，线程会释放GIL，实现CPU和IO的并行，因此多线程用于IO密集型计算依然可以大幅度提升速度</li><li>但多线程用于CPU密集型计算时，只会更加拖慢速度</li></ul></li><li>使用multiprocessing 的多进程机制实现并行计算、利用多核CPU优势<ul><li>为了应对GIL，python提供了multiprocessing</li></ul></li></ol><h2 id="python多线程加速爬虫程序"><a class="markdownIt-Anchor" href="#python多线程加速爬虫程序"></a> python多线程加速爬虫程序</h2><h3 id="python创建多线程的方法"><a class="markdownIt-Anchor" href="#python创建多线程的方法"></a> python创建多线程的方法</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 准备一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    do_craw(a,b)</span><br><span class="line"><span class="comment"># 怎样创建一个线程</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">t = threading.Thread(target=my_func, args=(<span class="number">100</span>,<span class="number">200</span>))</span><br><span class="line"><span class="comment"># 启动线程</span></span><br><span class="line">t.start()</span><br><span class="line"><span class="comment"># 等待结束</span></span><br><span class="line">t.join()</span><br></pre></td></tr></table></figure><h3 id="multi-threads-example"><a class="markdownIt-Anchor" href="#multi-threads-example"></a> multi-threads example</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">urls = [<span class="string">f&quot;https://www.cnblogs.com/#p<span class="subst">&#123;page&#125;</span>&quot;</span> <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">50</span>+<span class="number">1</span>)]</span><br><span class="line"><span class="comment"># urls = [&quot;https://www.cnblogs.com/#p&#123;&#125;&quot;.format(page) for page in range(1,50+1)]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">craw</span>(<span class="params">url</span>):</span></span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span>(url,<span class="built_in">len</span>(r.text))</span><br><span class="line"></span><br><span class="line">craw(urls[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## multi thread</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_thread</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;single thread begin&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        craw(url)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;single thread end&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_thread</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;multi-thread begin&quot;</span>)</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        threads.append(</span><br><span class="line">            threading.Thread(target=craw, args=(url,))</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.start()</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;multi-thread end&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    single_thread()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;single thread cost: &quot;</span>, end-start, <span class="string">&quot;seconds&quot;</span>)</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    multi_thread()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;multi-thread cost: &quot;</span>, end - start, <span class="string">&quot;seconds&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多组件的pipeline技术架构"><a class="markdownIt-Anchor" href="#多组件的pipeline技术架构"></a> 多组件的Pipeline技术架构</h3><p>复杂的事情一般不会一下子做完，而是会分很多中间步骤一步一步完成</p><p><img src="https://ganshizhong.gitee.io/blogimages/Python/concurrentprogramming/pipeline.png" alt="pipeline" /></p><h3 id="多线程数据通信的quenequeue"><a class="markdownIt-Anchor" href="#多线程数据通信的quenequeue"></a> 多线程数据通信的quene.Queue</h3><p>queue.Queue可以用于多线程之间的线程安全的数据通信</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入类库</span></span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="comment"># 创建Queue</span></span><br><span class="line">q = queue.Queue()</span><br><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">q.put(item)</span><br><span class="line"><span class="comment"># 获取元素</span></span><br><span class="line">item.get()</span><br><span class="line"><span class="comment"># 查看元素的多少</span></span><br><span class="line">q.qsize()</span><br><span class="line"><span class="comment"># 判断是否为空</span></span><br><span class="line">q.empty()</span><br><span class="line"><span class="comment"># 判断是否已满</span></span><br><span class="line">q.full()</span><br></pre></td></tr></table></figure><h3 id="代码编写实现生产者消费者爬虫"><a class="markdownIt-Anchor" href="#代码编写实现生产者消费者爬虫"></a> 代码编写实现生产者消费者爬虫</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">urls = [<span class="string">f&quot;https://www.cnblogs.com/#p<span class="subst">&#123;page&#125;</span>&quot;</span> <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">50</span>+<span class="number">1</span>)]</span><br><span class="line"><span class="comment"># urls = [&quot;https://www.cnblogs.com/#p&#123;&#125;&quot;.format(page) for page in range(1,50+1)]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">craw</span>(<span class="params">url</span>):</span></span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> r.text</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">txtparse</span>(<span class="params">html</span>):</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    links = soup.find_all(<span class="string">&quot;a&quot;</span>, class_ = <span class="string">&quot;post-item-title&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> [(link[<span class="string">&quot;href&quot;</span>], link.get_text()) <span class="keyword">for</span> link <span class="keyword">in</span> links]</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">urls = [<span class="string">f&quot;https://www.cnblogs.com/#p<span class="subst">&#123;page&#125;</span>&quot;</span> <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">50</span>+<span class="number">1</span>)]</span><br><span class="line"><span class="comment"># urls = [&quot;https://www.cnblogs.com/#p&#123;&#125;&quot;.format(page) for page in range(1,50+1)]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">craw</span>(<span class="params">url</span>):</span></span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> r.text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">txtparse</span>(<span class="params">html</span>):</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    links = soup.find_all(<span class="string">&quot;a&quot;</span>, class_ = <span class="string">&quot;post-item-title&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> [(link[<span class="string">&quot;href&quot;</span>], link.get_text()) <span class="keyword">for</span> link <span class="keyword">in</span> links]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_craw</span>(<span class="params">url_queue: queue.Queue, html_queue: queue.Queue</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        url = url_queue.get()</span><br><span class="line">        html = craw(url)</span><br><span class="line">        html_queue.put(html)</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name, <span class="string">f&quot;craw <span class="subst">&#123;url&#125;</span>&quot;</span>, <span class="string">&quot;url_queue.size=&quot;</span>, url_queue.qsize())</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_parse</span>(<span class="params">html_queue: queue.Queue, fout</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        html = html_queue.get()</span><br><span class="line">        results = txtparse(html)</span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">            fout.write(<span class="built_in">str</span>(result) +<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name, <span class="string">f&quot;results.size&quot;</span>, <span class="built_in">len</span>(results), <span class="string">&quot;html_queue.size=&quot;</span> , html_queue.qsize())</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url_queue = queue.Queue()</span><br><span class="line">    html_queue= queue.Queue()</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        url_queue.put(url)</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        t = threading.Thread(target=do_craw, args=(url_queue,html_queue), name=<span class="string">f&quot;craw<span class="subst">&#123;idx&#125;</span>&quot;</span>)</span><br><span class="line">        t.start()</span><br><span class="line">    fout = <span class="built_in">open</span>(<span class="string">&quot;02.data.txt&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        t = threading.Thread(target=do_parse, args=(html_queue, fout), name=<span class="string">f&quot;parse<span class="subst">&#123;idx&#125;</span>&quot;</span>)</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><h2 id="线程安全"><a class="markdownIt-Anchor" href="#线程安全"></a> 线程安全</h2><h3 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h3><p>线程安全指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p><p>由于现成的执行随时会发生切换，就造成了不可预料的结果，出现线程不安全。</p><blockquote><p>尤其是在远程调用或sleep的时候会经常出现</p></blockquote><p>例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">account, amount</span>):</span></span><br><span class="line">    <span class="keyword">if</span> account.balance &gt;= amount:</span><br><span class="line">        account.balance -=amount</span><br></pre></td></tr></table></figure><p>如果是多线程，同时进行两笔取钱操作，线程切换过程中，系统依次先执行了两次判断语句，导致接下来都完成了取钱操作，就出现了问题。</p><blockquote><p>互斥访问；判断和执行语句捆绑为原子性；mysql幻读</p></blockquote><h3 id="lock用于解决线程安全问题"><a class="markdownIt-Anchor" href="#lock用于解决线程安全问题"></a> Lock用于解决线程安全问题</h3><blockquote><p>锁就是让任务排队;锁让判断和执行语句捆绑上锁同时执行；锁是数据共享的地方；</p></blockquote><p>方法一： try-finally 模式</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">lock = threading.Lock()</span><br><span class="line">lock.acquire()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    lock.release()</span><br></pre></td></tr></table></figure><p>方法二： with模式</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="keyword">with</span> lock:</span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure><p>具体例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, balance</span>):</span></span><br><span class="line">        self.balance = balance</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">account, amount</span>):</span></span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="keyword">if</span> account.balance &gt;= amount:</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">            <span class="built_in">print</span>(threading.current_thread().name, <span class="string">&quot;取钱成功\n&quot;</span>)</span><br><span class="line">            account.balance -= amount</span><br><span class="line">            <span class="built_in">print</span>(threading.current_thread().name, <span class="string">&quot;余额&quot;</span>, account.balance,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(threading.current_thread().name, <span class="string">&quot;取钱失败，余额不足&quot;</span>,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    account = Account(<span class="number">1000</span>)</span><br><span class="line">    ta = threading.Thread(name=<span class="string">&quot;ta&quot;</span>, target=draw, args=(account, <span class="number">800</span>))</span><br><span class="line">    tb = threading.Thread(name=<span class="string">&quot;tb&quot;</span>, target=draw, args=(account, <span class="number">800</span>))</span><br><span class="line">    ta.start()</span><br><span class="line">    tb.start()</span><br></pre></td></tr></table></figure><h2 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h2><h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3><p>新建线程系统需要分配资源、终止线程系统需要回收资源，如果可以重用线程，则可以减去新建/终止的开销。</p><p><img src="https://ganshizhong.gitee.io/blogimages/Python/concurrentprogramming/threadperiod.png" alt="threadperiod" /></p><h3 id="使用线程池的好处"><a class="markdownIt-Anchor" href="#使用线程池的好处"></a> 使用线程池的好处</h3><ol><li>提升性能：因为减去大量新建、终止线程的开销，重用了线程资源</li><li>使用场景：适合处理突发性大量请求或需要大量线程完成任务、但实际处理时间较短</li><li>防御功能：能有效避免系统因创建线程过多，而导致系统负荷过大相应变慢等问题</li><li>代码优势：使用线程池的语法比自己新建线程执行更加简洁</li></ol><h3 id="使用线程池threadpoolexecutor改造爬虫程序"><a class="markdownIt-Anchor" href="#使用线程池threadpoolexecutor改造爬虫程序"></a> 使用线程池ThreadPoolExecutor改造爬虫程序</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">urls = [<span class="string">f&quot;https://www.cnblogs.com/#p<span class="subst">&#123;page&#125;</span>&quot;</span> <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">50</span>+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">craw</span>(<span class="params">url</span>):</span></span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> r.text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">txtparse</span>(<span class="params">html</span>):</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    links = soup.find_all(<span class="string">&quot;a&quot;</span>, class_ = <span class="string">&quot;post-item-title&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> [(link[<span class="string">&quot;href&quot;</span>], link.get_text()) <span class="keyword">for</span> link <span class="keyword">in</span> links]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 用法一</span></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">    results = pool.<span class="built_in">map</span>(craw, urls)</span><br><span class="line">    results = <span class="built_in">list</span>(<span class="built_in">zip</span>(urls, results))</span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment">## 用法二</span></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">    futures = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> url, html <span class="keyword">in</span> results:</span><br><span class="line">        future = pool.submit(txtparse, html)</span><br><span class="line">        futures[future] = url</span><br><span class="line">    <span class="comment">## 方法一：顺序执行</span></span><br><span class="line">    <span class="comment"># for future, url in futures.items():</span></span><br><span class="line">    <span class="comment">#     print(url, future.result())</span></span><br><span class="line">    <span class="comment">## 方法二:这个好，先结束先返回</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(futures):</span><br><span class="line">        url = futures[future]</span><br><span class="line">        <span class="built_in">print</span>(url, future.result())</span><br></pre></td></tr></table></figure><blockquote><p>note: 用法一：map函数，结果和入参顺序对应；用法二：future模式更强大，as_completed顺序不定。</p></blockquote><h2 id="在web服务中使用线程池加速"><a class="markdownIt-Anchor" href="#在web服务中使用线程池加速"></a> 在web服务中，使用线程池加速</h2><h3 id="web服务的架构以及特定"><a class="markdownIt-Anchor" href="#web服务的架构以及特定"></a> web服务的架构以及特定</h3><p><img src="https://ganshizhong.gitee.io/blogimages/Python/concurrentprogramming/webframe.png" alt="webframe" /></p><p>web后台服务的特点</p><ol><li>web 服务对响应时间要求非常高，比如200MS返回</li><li>web 服务有大量的IO操作的调用，比如磁盘文件、数据库、远程API</li><li>web 服务经常需要处理几万人、几百万人的同时请求</li></ol><h3 id="使用线程池threadpoolexecutor加速"><a class="markdownIt-Anchor" href="#使用线程池threadpoolexecutor加速"></a> 使用线程池ThreadPoolExecutor加速</h3><p>使用ThreadPoolExecutor的好处</p><ol><li>方便的将磁盘文件、数据库、远程API的IO调用并发执行</li><li>线程池的线程数目不会无限创建（导致系统挂掉），具有防御功能</li></ol><h3 id="代码用flask实现web服务并实现加速"><a class="markdownIt-Anchor" href="#代码用flask实现web服务并实现加速"></a> 代码用Flask实现web服务并实现加速</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  flask</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_db</span>():</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;db result&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span>():</span></span><br><span class="line">    time.sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;file result&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_api</span>():</span></span><br><span class="line">    time.sleep(<span class="number">0.3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;api result&quot;</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    result_file = read_file()</span><br><span class="line">    result_db =read_db()</span><br><span class="line">    result_api = read_api()</span><br><span class="line">    <span class="keyword">return</span> json.dumps(&#123;</span><br><span class="line">        <span class="string">&quot;result_file&quot;</span>:result_file,</span><br><span class="line">        <span class="string">&quot;result_db&quot;</span>:result_db,</span><br><span class="line">        <span class="string">&quot;result_api&quot;</span>:result_api</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p><img src="https://ganshizhong.gitee.io/blogimages/Python/concurrentprogramming/getapitime.png" alt="responetime" /></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  flask</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_db</span>():</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;db result&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span>():</span></span><br><span class="line">    time.sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;file result&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_api</span>():</span></span><br><span class="line">    time.sleep(<span class="number">0.3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;api result&quot;</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    result_file = read_file()</span><br><span class="line">    result_db =read_db()</span><br><span class="line">    result_api = read_api()</span><br><span class="line">    <span class="keyword">return</span> json.dumps(&#123;</span><br><span class="line">        <span class="string">&quot;result_file&quot;</span>:result_file,</span><br><span class="line">        <span class="string">&quot;result_db&quot;</span>:result_db,</span><br><span class="line">        <span class="string">&quot;result_api&quot;</span>:result_api</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p><img src="https://ganshizhong.gitee.io/blogimages/Python/concurrentprogramming/getapitime1.png" alt="responetime1" /></p><h2 id="多进程multiprocessing-加速程序的运行"><a class="markdownIt-Anchor" href="#多进程multiprocessing-加速程序的运行"></a> 多进程multiprocessing 加速程序的运行</h2><p>有了多线程threading，为什么还要使用多进程multiprocessing?<br />如果遇到了CPU密集型计算，多线程反而会降低执行速度！</p><p><strong>multiprocessing模块就是python为解决GIL缺陷引入的一个模块，原理是用多进程在多CPU并行执行</strong><br /><img src="https://ganshizhong.gitee.io/blogimages/Python/concurrentprogramming/whymultiprocess.png" alt="whymultiprocess" /></p><h3 id="多进程mutliprocessing知识梳理语法上二者十分相似"><a class="markdownIt-Anchor" href="#多进程mutliprocessing知识梳理语法上二者十分相似"></a> 多进程mutliprocessing知识梳理（语法上二者十分相似）</h3><p><img src="https://ganshizhong.gitee.io/blogimages/Python/concurrentprogramming/threadingandmultiprocessing.png" alt="threadingandmultiprocessing" /></p><h3 id="代码对比单线程-多线程-多进程在cpu密集计算速度"><a class="markdownIt-Anchor" href="#代码对比单线程-多线程-多进程在cpu密集计算速度"></a> 代码对比单线程、多线程、多进程在CPU密集计算速度</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor, ThreadPoolExecutor</span><br><span class="line">PRIMES = [<span class="number">112272535095293</span>]*<span class="number">100</span> <span class="comment"># 这个数字很关键，不然很快就判断结束了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span>(<span class="params">n</span>):</span> <span class="comment"># 判单是否是质数</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n ==<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> n %<span class="number">2</span> ==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    sqrt_n = <span class="built_in">int</span>(math.floor(math.sqrt(n)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, sqrt_n+<span class="number">1</span>,<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i ==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_thread</span>():</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> PRIMES:</span><br><span class="line">        is_prime(num)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_thread</span>():</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">        pool.<span class="built_in">map</span>(is_prime, PRIMES)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_process</span>():</span></span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">        pool.<span class="built_in">map</span>(is_prime, PRIMES)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    single_thread()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;single thread cost:&quot;</span>, end-start, <span class="string">&quot;seconds&quot;</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    multi_thread()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;multi thread cost:&quot;</span>, end - start, <span class="string">&quot;seconds&quot;</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    multi_process()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;multi process cost:&quot;</span>, end-start, <span class="string">&quot;seconds&quot;</span>)</span><br><span class="line"><span class="comment">### print结果</span></span><br><span class="line"><span class="comment"># single thread cost: 83.22900080680847 seconds</span></span><br><span class="line"><span class="comment"># multi thread cost: 64.15043830871582 seconds</span></span><br><span class="line"><span class="comment"># multi process cost: 24.825831413269043 seconds</span></span><br></pre></td></tr></table></figure><h3 id="flask服务中使用进程池加速"><a class="markdownIt-Anchor" href="#flask服务中使用进程池加速"></a> Flask服务中使用进程池加速</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span>(<span class="params">n</span>):</span> <span class="comment"># 判单是否是质数</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n ==<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> n %<span class="number">2</span> ==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    sqrt_n = <span class="built_in">int</span>(math.floor(math.sqrt(n)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, sqrt_n+<span class="number">1</span>,<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i ==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/is_prime/&lt;numbers&gt;&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">api_is_prime</span>(<span class="params">numbers</span>):</span></span><br><span class="line">    numbers_list = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> numbers.split(<span class="string">&quot;,&quot;</span>)]</span><br><span class="line">    results = process_pool.<span class="built_in">map</span>(is_prime, numbers_list)</span><br><span class="line">    <span class="keyword">return</span> json.dumps(<span class="built_in">dict</span>(<span class="built_in">zip</span>(numbers_list, results)))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    process_pool = ProcessPoolExecutor()</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><h2 id="python异步io实现并发爬虫"><a class="markdownIt-Anchor" href="#python异步io实现并发爬虫"></a> python异步IO实现并发爬虫</h2><p>单线程爬虫的执行路径</p><p><img src="https://ganshizhong.gitee.io/blogimages/Python/concurrentprogramming/single_thread_spider.png" alt="single_thread_spider" /></p><p>协程：在单线程内实现并发</p><p><img src="https://ganshizhong.gitee.io/blogimages/Python/concurrentprogramming/single_thread_spider.png" alt="asyncio_spider" /></p><h3 id="python异步io库介绍asyncio"><a class="markdownIt-Anchor" href="#python异步io库介绍asyncio"></a> Python异步IO库介绍asyncio</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">urls = [<span class="string">f&quot;https://www.cnblogs.com/#p<span class="subst">&#123;page&#125;</span>&quot;</span> <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">50</span>+<span class="number">1</span>)]</span><br><span class="line"><span class="comment"># 获取事件循环</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 定义协程</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">async_craw</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;craw url: &quot;</span>, url)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">            result = <span class="keyword">await</span> resp.text()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;craw url: <span class="subst">&#123;url&#125;</span>, <span class="subst">&#123;<span class="built_in">len</span>(result)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 创建task列表</span></span><br><span class="line">tasks = [</span><br><span class="line">    loop.create_task(async_craw(url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 执行爬虫事件列表</span></span><br><span class="line">start = time.time()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">end = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;use time seconds: &quot;</span>, end-start)</span><br><span class="line"><span class="comment">## print</span></span><br><span class="line"><span class="comment"># single thread cost:  11.99697756767273 seconds</span></span><br><span class="line"><span class="comment"># multi-thread cost:  1.426210880279541 seconds</span></span><br><span class="line"><span class="comment"># asyncio cost:  1.3427538871765137</span></span><br></pre></td></tr></table></figure><blockquote><p>async 表示这是一个协程，await表示这是一个IO</p></blockquote><blockquote><p>note: 要用在异步IO编程中，依赖的库必须支持异步IO特性;爬虫引用中，requests不支持异步，需要用aiohttp</p></blockquote><h2 id="在异步io中使用信号量控制爬虫并发度"><a class="markdownIt-Anchor" href="#在异步io中使用信号量控制爬虫并发度"></a> 在异步IO中使用信号量控制爬虫并发度</h2><p>信号量（Semaphore），又称为心好累、旗语，是一个同步对象，用于保持在0至指定最大值之间的一个技术之。</p><ul><li>当线程完成一次对该semaphore对象的等待（wait）时，该计数值减一；</li><li>当线程完成一次对semaphore对象的释放（release）时，计数值加一；</li><li>当计数值为0，则线程等待该semaphore对象不再能成功直至该semaphore对象变成signaled状态</li><li>semaphore对象的计数值大于0，为signaled状态；计数值等于0，为nonsignaled状态。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########## 使用方式1</span></span><br><span class="line">sem = asyncio.Semaphore(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># ...later</span></span><br><span class="line">asyncio <span class="keyword">with</span> sem:</span><br><span class="line">    <span class="comment"># work with shared resource</span></span><br><span class="line"><span class="comment">########## 使用方式2</span></span><br><span class="line">sem = asyncio.Semaphore(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># ...later</span></span><br><span class="line"><span class="keyword">await</span> sem.acquire() </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># work with shared resource</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    sem.release()</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">urls = [<span class="string">f&quot;https://www.cnblogs.com/#p<span class="subst">&#123;page&#125;</span>&quot;</span> <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">50</span>+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">semaphore = asyncio.Semaphore(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 获取事件循环</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 定义协程</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">async_craw</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> semaphore:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;craw url: &quot;</span>, url)</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">                result = <span class="keyword">await</span> resp.text()</span><br><span class="line">                <span class="keyword">await</span> asyncio.sleep(<span class="number">5</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;craw url: <span class="subst">&#123;url&#125;</span>, <span class="subst">&#123;<span class="built_in">len</span>(result)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建task列表</span></span><br><span class="line">tasks = [</span><br><span class="line">    loop.create_task(async_craw(url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 执行爬虫事件列表</span></span><br><span class="line">start = time.time()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">end = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;use time seconds: &quot;</span>, end-start)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;并发编程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#并发编程&quot;&gt;&lt;/a&gt; 并发编程&lt;/h2&gt;
&lt;h3 id=&quot;并发编程程序提速方法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#并发编程程序提速方法&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="python" scheme="http://shizhonggan.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://shizhonggan.github.io/tags/python/"/>
    
    <category term="thread" scheme="http://shizhonggan.github.io/tags/thread/"/>
    
    <category term="process" scheme="http://shizhonggan.github.io/tags/process/"/>
    
    <category term="coroutine" scheme="http://shizhonggan.github.io/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>tkinter快速入门</title>
    <link href="http://shizhonggan.github.io/2022/02/21/Python/pywebbakdevtest1/"/>
    <id>http://shizhonggan.github.io/2022/02/21/Python/pywebbakdevtest1/</id>
    <published>2022-02-21T08:39:04.000Z</published>
    <updated>2022-03-09T09:03:44.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-python类变量和实例变量的异同"><a href="#1-python类变量和实例变量的异同" class="headerlink" title="1. python类变量和实例变量的异同"></a>1. python类变量和实例变量的异同</h2><ul><li>类变量：可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。</li><li>实例变量：实例化之后，每个实例单独拥有的变量。<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>():</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    name = <span class="string">&#x27;stu&#x27;</span></span><br><span class="line">    <span class="comment"># age,name是类变量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,age,name</span>):</span></span><br><span class="line">        self.age = age</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="comment"># 访问实例变量(用self.age  self.name)</span></span><br><span class="line"></span><br><span class="line">student1 = student(<span class="number">18</span>,<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(student1.name) </span><br><span class="line"><span class="comment"># 打印实例变量，输出hello</span></span><br><span class="line"><span class="built_in">print</span>(student.name)  </span><br><span class="line"><span class="comment"># 打印类变量，输出stu</span></span><br></pre></td></tr></table></figure><h2 id="2-python中的协程如何实现的"><a href="#2-python中的协程如何实现的" class="headerlink" title="2. python中的协程如何实现的"></a>2. python中的协程如何实现的</h2></li></ul><ul><li>进程：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</li></ul><p>　　2、线程</p><p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</p><p>　　3、协程</p><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>首页 注册 登录<br>V2EX = way to explore<br>V2EX 是一个关于分享和探索的地方<br>现在注册<br>已注册用户请  登录<br>FinClip<br>DataPacket<br>CDN77<br>广告<br>FinClip<br>2022 FinClip 黑客马拉松，寻找「最强大脑」<br>广告<br>rapospectreV2EX  ›  程序员<br>2017 后端面试经历分享<br>  44     rapospectre · bluedazzle · 2017-03-20 11:36:07 +08:00 · 26188 次点击<br>这是一个创建于 1814 天前的主题，其中的信息可能已经有所发展或是发生改变。<br>0.背景<br>博主本人 2015 年毕业于郫县某 985 大学通信工程系，因为大学期间一直自己创业所以错过了大四秋招春招，毕业后又在北京继续创业一年，但在创业公司一直无法沉淀技术累积，于 16 年年底萌生进大公司学习的想法，于是从 16 年年底开始通过社招找工作。虽然大学就开始做研发，但无奈简历只看毕业工作经验，所以本人简历只有一年工作经验。</p><p>在此总结一篇文章给各位参考；</p><p>1.阿凡题<br>应该算是人生第一场面试，早上 11 点开始，公司是做 k12 在线教育相关业务，在五道口那边；</p><p>一面<br>前台登记后发了一套笔试题，开始写，主要都是 Python 基础知识，不算难，基本就是 可变对象不可变对象区别、 Python 垃圾回收机制之类的题目，有一两道编程题也很简单，最后有个根据题目设计数据表的问题也不难，搞定后等面试官开始二面；</p><p>二面<br>面试官好像是个主管，开始让做自我介绍，他在看我的笔试题，然后根据简历问了一些项目相关的问题以及简单的一些系统设计问题，之后大概问了问笔试题里一些问题和补充，感觉聊的比较开心，面试官也对之前我的经历比较感兴趣，于是去通知 CTO 进行三面；</p><p>三面<br>CTO 面里问题的广度和深度都很大，从服务器部署的相关知识到 Nginx 一些细节问题都有问到，不得不说问的还是比较全面的，印象最深的应该是这个问题：</p><p>浏览器的一个请求从发送到返回都经历了什么，讲的越详细越好<br>我大概讲下我的答案：</p><p>1 、先从网络模型层面：</p><p>client （浏览器）与 server 通过 http 协议通讯， http 协议属于应用层协议， http 基于 tcp 协议，所以 client 与 server 主要通过 socket 进行通讯；</p><p>而 tcp 属于传输层协议、如果走 https 还需要会话层 TLS 、 SSL 等协议； 传输层之下网络层，这里主要是路由协议 OSPF 等进行路由转发之类的。再向下数据链路层主要是 ARP 、 RARP 协议完成 IP 和 Mac 地址互解析，再向下到最底层物理层基本就是 IEEE 802.X 等协议进行数据比特流转成高低电平的的一些定义等等；</p><p>当浏览器发出请求，首先进行数据封包，然后数据链路层解析 IP 与 mac 地址的映射，然后上层网路层进行路由查表路由，通过应用层 DNS 协议得到目标地址对应的 IP ，在这里进行 n 跳的路由寻路；而传输层 tcp 协议可以说下比较经典的三次握手、四次分手的过程和状态机，这里放个图可以作为参考：</p><p>2 、应用层方面：</p><p>数据交换主要通过 http 协议， http 协议是无状态协议，这里可以谈一谈 post 、 get 的区别以及 RESTFul 接口设计，然后可以讲服务器 server 模型 epoll 、 select 等，接着可以根据实际经验讲下 server 处理流程，比如我： server 这边 Nginx 拿到请求，进行一些验证，比如黑名单拦截之类的，然后 Nginx 直接处理静态资源请求，其他请求 Nginx 转发给后端服务器，这里我用 uWSGI, 他们之间通过 uwsgi 协议通讯， uWSGI 拿到请求，可以进行一些逻辑， 验证黑名单、判断爬虫等，根据 wsgi 标准，把拿到的 environs 参数扔给 Django ， Django 根据 wsgi 标准接收请求和 env ， 然后开始 start_response ，先跑 Django 相关后台逻辑， Django 拿到请求执行 request middleware 内的相关逻辑，然后路由到相应 view 执行逻辑，出错执行 exception middleware 相关逻辑，接着 response 前执行 response middleware 逻辑，最后通过 wsgi 标准构造 response ， 拿到需要返回的东西，设置一些 headers ，或者 cookies 之类的，最后 finish_response 返回，再通过 uWSGI 给 Nginx ， Nginx 返回给浏览器。</p><p>谈完后 CTO 根据我说的一些细节提出了一些问题，最后当时就谈了 offer ， CTO 说不走 hr 那边了直接和我谈，比较意外的是 offer 给的比我自己要的还高 5k 。对于第一次找工作的我来说当时满心激动。</p><p>最后大概说说环境：公司在五道口一栋写字楼内容，规模还算比较大，听 CTO 谈做的事情也比较有意思，有机器学习、大数据等等 （ 主要是处理各种初高中学科的题目，涉及到文字识别深度学习等等，当然我如果进去肯定要从业务写起 ），包午餐、下午茶之类的其他我就不太清楚了，因为下午就走了，不过公司好像是每周六天班。公司发展感觉还是比较高速，感兴趣的同学可以去试试。</p><ol start="2"><li>学堂在线<br>公司也在五道口，清华科技园里， Google 前中国办公室对面的楼里 （ 好像现在搬到 Google 那里了 ）</li></ol><p>一面<br>一面面试官应该是个后端研发工程师，感觉有些羞涩，全程一直不看我，主要聊了一些简历里的项目经验，系统设计，然后问了几个简单的算法题和一些 Python 的基本知识，然后就去叫二面面试官了。</p><p>二面<br>二面面试官是部门主管，嗯，这次总算看着我跟我聊了，哈哈，感觉目光交流也很重要，同样问了一些系统设计的问题和经验问题，因为博主 Django 相关的经验还算比较丰富，感觉他们也主要是找业务研发，所以没什么意外就过了。</p><p>三面<br>hr 面，主要问了一些薪资期望，发展规划之类的，主要是聊天，然后就发了 offer 。</p><p>学堂在线主要是做慕课平台，并且是和国内各大高校合作，福利方面因为最后没有去所以不是特别了解，公司环境还是不错的。</p><p>3.果壳<br>果壳在国贸百朗园里，在园区最里面，不是很好找，一进去先发了一套面试题和一张登记表，登记表连父母家庭资料都要，不是很理解要面试者这些信息干什么，又不一定去你家，等入职再填不行吗？所以除了本人信息，其他我没填。（ 面了这么多家就果壳要填这个，还要填特别详细的信息，不能懂 ）</p><p>一面<br>面试题难度适中，不过涉及到的面比较多，还要写数据库查询语句等等，博主非科班，只大概自学过数据库，然后一直在用 orm ，毕业后就没怎么写过原生 SQL ，相关题目只能凭借记忆大概写了下，还有一道题是 用 O(1) 的复杂度实现一个 栈 的出栈入栈和返回 max 、 min 值的操作，其他就是一些 Python 基础和表设计题。</p><p>这里说下这道设计栈的题：</p><p>出入栈函数 O(1) 没什么问题，主要是 max 、 min 操作（ 博主找工作时没看过面试题目，只是刷了一些 LeetCode ，后来发现这道题很经典，网上很多答案）当时没遇到过这种需求，但是可以肯定想要时间复杂度下降，肯定是要用空间去换时间，所以当时有设计了额外的数据结构存 max min ，但当时设计的还是有问题，后面又和面试官讨论了一下，还是没有得出最好的方案，最后回去网上搜了下发现其实很简单，当时只差最后一步，感兴趣的同学可以看下：栈在 O(1) 时间内求 min</p><p>二面<br>面试官一上来就直接拿着笔试题开始一道一道问，嗯，连我叫什么都没让介绍，更别说介绍项目什么的，感觉有点懵逼，全程没一句废话，全是纯技术问题和算法，然后自己擅长的面试官感觉不太感兴趣，我不太熟悉的他很愿意追问，嗯，二脸懵逼，之后又问道 tcp 流量控制，当时直接说错给说了拥塞控制，面试官表示我 tcp 掌握的不好（ 确实是我的问题，回去之后又整个看了一遍 tcp ）。</p><p>最后又问了很多数据库底层的东西，博主完全没接触过，所以面试官表示下一轮面试官有事 （ 哈哈哈 ），接着问我有什么想问的，我问了两个问题面试官表示自己还有事。。。好吧，那就不聊了。</p><p>总结：数据库知识很重要，即使你投的是研发不是 dba ，你也一定要懂数据库底层的基本原理，至少要知道 索引原理、 MySQL 数据引擎等等，因为之后凡是博主挂的面试都有数据库的锅。</p><p>果壳环境看上去有些乱，但比较温馨，但实在不敢恭维面试的方式，所以挂了博主也没惋惜。其他方面就不太了解啦，因为根本没拿到 offer 。</p><p>4.Veeva<br>公司也在国贸附近，是一家给生物科技企业（ 药厂 ）做 crm 的外企 ( 不过国内的好像和国外母公司没什么关系，就是个单独的子公司 )，不算是互联网公司，但是薪资很给力。</p><p>一面<br>首先是 phone interview ， hr 大概问了问跳槽的原因，项目经验，发展规划等，然后发来 homework ，做完后提交；</p><p>二面<br>homework 比较简单，就是一个判断是否润年的函数，不过这里是有坑的，当题目很简单时，人家考验的就不是智商了，而是看你的编码能力，工程化能力及面向对象抽象能力，所以果断完整的写了个工程，加上完整的测试，然后提交之。</p><p>三面<br>hr 说技术同事看了 homework 感觉还是比较 ok 的，所以约面试，首先来的面试官好像就是个 leader ，问了很多 Python 和 Django 相关的基础知识和算法题，现场有个白版，直接在上面她出题，我写，然后她 review ，基本上就是 LeetCode easy 难度的题，没有太大问题。</p><p>四面<br>应该是个技术大牛，问了问经验开始系统设计，我记得当时是让设计一个短网址生成方案，有一些额外要求，比如不能按照字符顺序生成短网址，而是要随机生成，如何避免碰撞，如何最大效率利用所有空间。</p><p>具体方案可以看知乎，上面有人讨论过： 短链接是如何设计的</p><p>然后面试结束。</p><p>面试完后接到 hr 电话说技术同事感觉不错，问我有没有意向入职，但当时考虑还是想去互联网公司所以就拒掉了。不过 veeva 的薪资很给力，感兴趣的同学可以去看看。</p><p>5.知乎<br>博主的 dream company ，哈哈，去面试的时候特紧张。知乎在 768 创意园，环境很棒。</p><p>一面<br>一面面试官问了项目经历及一些个人信息后开始考基础，主要是面试官出题，然后我在纸上写代码，难度适中，因为面试的比较久了，记不太清楚全部题目，记得让手写了快排，然后 Python 相关基础知识，一些 LeetCode 题， tcp 相关知识， epoll 服务模型、 tornado 的一些原理 （ 可以看博主之前文章 tornado ioloop 分析 ）数据库知识 （ 坦白掌握不多 ）末尾问了下二分查找，一面就过了。</p><p>二面<br>面试官好像是商业化后台的主管？问了项目经验，问了经历，对我大学期间创业经历表示赞扬，但毕业后又创业一年表示不满意（ 不是很明白为什么 ），之后开始问一些系统设计相关题目，印象比较深的是设计微信抢红包的构架，嗯，当时根据自己的见解说了一套系统和注意的点以及分配红包的算法，感觉面试官应该不太满意。回去后看了看网上，还真有写，果断研读了一发： 微信红包构架设计.</p><p>后面又聊了一些系统设计相关的内容，然后让我等等。</p><p>三面<br>等了半个小时，期间看到前两面面试官一直在和 hr 讨论，应该是要不要我的问题，半个小时后 hr 来跟我聊了聊规划和项目以及为何来知乎，然后就回去周五前给回复。</p><p>到此大概确定应该要我的可能性不大，应该是当做备胎了。 这里自己的问题主要是系统设计方面当时并没有准备，另一方面数据库这块明明果壳问到了但是没有重视起来。最后，年底出去找工作还是要谨慎，很多大点公司没什么招聘需求，除非特别优秀。</p><p>最后，周五没有收到消息，基本确定挂了，果然在下周周一的时候收到了拒信，这点要赞一下，至少有明确的拒信，不像一些其他公司，嗯，就不明说了。</p><p>知乎氛围觉得还是挺赞的， 福利也很好，包三餐，不加班，嗯，不多说了，都是泪。 最近知乎开始大量招人了，大家可以去试试哦，替我完成我的 dc 梦，哈哈哈。</p><p>6.春雨医生<br>春雨医生在知乎隔壁，真的是紧隔壁，环境也不错~</p><p>一面<br>照例进行自我介绍，然后问项目经验，开始纸上写代码，不过这里要赞一下春雨，面试题都非常接地气，全是根据实际项目里的问题进行编码，比如有个给医生和病人聊天记录分组提醒的题目，都是类似的实际场景题目，完全没有那种纯算法题目，之后又聊了一些 Python Django 基础相关的东西，顺利进入二面。</p><p>二面<br>问了一些项目信息，然后开始系统设计，没记错的话应该是设计一个类似 QQ 的聊天工具，要求有群，并且可以发送图片、语音等各类消息，群管理员可以进行群管理等等。后面又问道数据库，直言数据库基础掌握的比较少，面试官也没有为难我。</p><p>三面<br>三面的时候到晚上饭点了， hr 姐姐超级好，带我去外面中餐馆点菜吃饭，回来后 CTO 面试， 考了阿凡题 CTO 问过的问题： 浏览器的一个请求从发送到返回都经历了什么</p><p>于是本人又根据上面那个流程讲了一遍，接着又问了问自己的发展规划和期望，然后我问了问春雨相关的一些问题，面试结束。</p><p>隔天收到了 offer ， 请我吃饭的小姐姐发给我的，哈哈，但是由于年前无法到岗，只能拒掉了。</p><p>总体讲，春雨环境也很不错，但其他福利我也没有问，所以其他不太清楚咯，有兴趣的同学可以去试试。</p><ol start="7"><li>360<br>360 在酒仙桥，最不靠谱的面试。。。</li></ol><p>直接通过拉钩邀请第二天早上面试，当时已经下午五点。完全没打电话发短信，接到邮件的我一脸懵逼，于是主动打电话过去确认，得到肯定后第二天做两个多小时车赶往望京。 （ 我住在八宝山这块 ）</p><p>一面<br>前台不让进，让通知面试的人来接，等了会儿面试官来接我，然后七绕八绕不知道绕道哪去给了我一份笔试题，让我做，着重强调不要看手机 （ 本来就没打算看好嘛，我坐的头顶有个摄像头，你让我怎么看，哈哈哈 ）写完让我打他电话，然后他就闪了。</p><p>我一看题目，除了前三道是 Python 之后全是 Linux 基础题，当时心里想：不亏是做安全的啊，要求就是不一样，然而博主半吊子 Linux 水平只会一些常用的命令，笔试题里的高端用法实在是臣妾不会做啊，于是本着诚实的原则做完会做的打了电话。</p><p>二面<br>面试官来没有让自我介绍，直接对着题目开始问 （ 我的内心已经产生了抵触感，和果壳一样 ）。第一题是个 Python 改错题，面试官问为何这样改，我大概讲了下，然后是讲了下 lambda 表达式并提供编程例子，面试官看完也没说什么，接着是一个用两个队列模拟栈，写实现代码，也没有太大问题，只是面试官也没有看代码，就是问了我怎么实现。</p><p>接着到了 Linux 部分，基本都不会，会的也只能写出简单的命令，面试官直言：你这个笔试题做的不好啊。怎么都不会 （ 确实有我的问题， Linux 基础不好，但是直接否定了前面其他部分有点冤啊 ）</p><p>接着问了一些项目经验，看到我的开源项目 djanog-simple-serializer 问这是干嘛的，然后我说了下是序列化解决方案，面试官说：序列化不是很简单嘛？（ 我也没说难啊大兄弟，只是其他的没有好用的自己写了个嘛 ）接着面试官问了我一句让我十脸懵逼的话，作为一个不懂 Python 的人，你能给我简单讲讲 Django 和你做的东西吗？当时我的内心全是黑人问号脸， wtf ？不懂 Python ？那你招 Python ？ 怎么面试啊大兄弟，虽然我知道其他语言用的 6 写 Python 也没问题，但是招进来就要写业务你怎么也得找个有相关经验的面试吧，这下我明白为啥之前 Python 部分面试官不怎么看了。 此刻我只想赶紧离开了，于是就说感觉招聘需要和我不太一致，就不耽误时间了。</p><p>好吧，应该我算是遇到个例，请大家不要对 360 产生偏见。</p><ol start="8"><li>今日头条<br>今日头条在中航广场，人民大学旁边，不得不说，是我面试过离我最近的公司，头条大楼很霸气。发展也很迅速。</li></ol><p>一面<br>面试前一天晚上莫名失眠，真的是一宿没睡，睁眼到天亮，然后一脸懵逼的去面试，到了头条前台我勒个去，从没见过这么多人来面试，大厅做不下了，当时心里想：完蛋，这么多人，竞争得多激烈，昨晚还失眠，血崩。</p><p>在前台签到，领了候选人的牌子，等了一会儿就叫到了我，由于面试的人实在太多，我实在 -1 楼食堂进行的面试，一面面试官是广告投放部门的工程师，先自我介绍，谈创业经历，问了 redis 用法及原理 （ 前面几次问到数据库的前车之鉴，博主特意狠狠看了下各种数据库的基本原理 ），然后根据我说使用 hash table 的经验，提了一个分布式 redis 使用 hash 的潜在问题，当时没有想出来，面试官提醒了下大概说到了点子上，主要是分布式机器 hash 后可能存在储存分配不均匀问题。然后 hash 表又问了冲突解决方案，主要是拉链法和进位法，之后聊了 tcp ，没什么问题。 问了排序算法的最小时间复杂度及原因。接着出了一道费那波数列的题，要求在常数时间复杂度内计算任意 fib(n) 当时可能没听清，估计没睡的原因，听成了常数时间复杂度，向面试官确认是常数时间复杂度 （ 面试官可能没听清我说的，以为我说的空间复杂度 ）于是苦思冥想无果，面试官提示动态规划，于是开始推导转移方程，最后面试官说没那么复杂，这时一对才发现我们理解岔了。其实很简单：</p><p>def fib(n):<br>    a, b = 0, 1<br>    for x in xrange(n):<br>        a, b = b, a + b<br>    return b<br>一面问题结束，在我写题的时候面试官看了我的博客和 GitHub ，表示满意 （ 有点惊讶，第一次有面试官看我博客和 GitHub ，虽然简历上有，但从没有人说看过 ），然后又带我把一面所有问题过了一遍，我不清楚的地方都完整的给出了答案，没见过这么好的面试官！！不知道他们给我多少分，我给他们满分！</p><p>二面<br>二面面试官是头条广告后台组主管，对我的创业经历很感兴趣，问了很多相关问题，然后看到我的开源项目又问了一些问题，然后提了一个很有意思的题目，在极端情况下，系统缓存全部失效，该如何防止流量全部打到数据库上，当时从很多方面考虑但是感觉面试官没有非常满意，不过也算是答到了点子上，也就算过了。回去后特意看了看，缓存失效的解决方案，感兴趣的同学自行搜索 “缓存重建”。</p><p>然后问了问一些项目相关的经验和解决方案，出了一道单链表逆置的题目 （ 和面试官透露非科班，没有出很难的题目 ），然而当时大脑基本处于停转状态，太困了，最后写出来有个 bug ，其实题目很简单，回去稍微想了下就写了出来：</p><p>def revese(node):<br>    p = node<br>    cur = node.next<br>    p.next = None<br>    while cur:<br>        tmp = cur.next<br>        cur.next = p<br>        p = cur<br>        cur = tmp<br>    return p<br>面试官表示 coding 能力需要加强，当时也不好说自己没睡觉，就直接说确实能力需要加强。面试关说让我等等去找下一轮面试官，等了一会儿告诉我下个面试官不在，当时觉得我是挂了 （ 结果是面试官真的不在 ），面试官好像看出了我的想法，重复了一句面试官真的不在。让我回去，稍后 hr 约下次面试时间。</p><p>三面<br>三面是一周后的下午 6 点，这次终于来到了面试室，里面有一块白版，三面面试官是广告大组的 leader ，进来没有再考基础题，问过经历后出了五道系统设计题，于是开始在白板上写，大概记得有多端登录管理、二维码登录等等一些设计，要求设计出系统结构，相关数据库和表，博主设计完后给面试官讲了一遍，感觉面试官比较满意，也没再问其他的，直接去叫下一轮面试官了。</p><p>四面<br>四面面试官是头条 data 部门的 vp ，感觉人超级和善，进来直接跟我说一起去吃饭吧，刚好体验下头条食堂，然后，第四轮面试是在饭桌上进行的，主要谈了谈我的项目经验和发展方向以及为何来头条，最后吃完饭面试官说本来这一轮也会考技术，但是感觉聊得不错，就不聊技术了，让我回去等 hr 电话。（ 头条食堂真的不错呀，只是当时没好意思多打，哈哈 ）</p><p>五面<br>hr 电话聊了聊个人发展及规划，然后确定了薪资，就发了 offer ~~</p><p>头条环境非常不错，包三餐，自助食堂，无限水果零食还有下午茶，晚上 10 点后打车报销，入职发 mac ， 住公司周围房补，大小周加班有加班费等等，总之福利非常多 （ 为何我知道的这么多 ）还是推荐大家来哦。</p><p>总结<br>最后，博主选择了头条的 offer 。（ 已经找到当初面试我的大神们，哈哈，开心 ）</p><p>从去年底找工作找到今年节后，终于找到一个满意的 offer ，曾经也纠结过，感觉自己高不成低不就，有段时间甚至拒绝出去找工作。</p><p>很多大公司社招都是三年经验起，所以像博主这种毕业一年的人在没有内推的情况下参加社招非常尴尬，在这里奉劝各位学弟学妹，一定要抓住校招的机会啊！！社招跟你竞争的可不光是你们同级的人。</p><p>找到工作后偶然发现一本神书 《剑指 offer 》我面试过基本所有问题上面都有，推荐大家一定过一遍（ 要是早点看到就好了，哈哈 ）</p><p>这里还有博主当时刷过的 LeetCode <a href="https://github.com/bluedazzle/leetcode_python">https://github.com/bluedazzle/leetcode_python</a> ，可以参考一下，之后有时间博主也打算一直刷下去。</p><p>平时一定要注意多积累，有条件的情况下尽量自己多写一些自己的项目，这样面试会有很大的加分，比如博主之前写过的小程序：式神猎手 ( <a href="https://www.rapospectre.com/blog/create-an-onmyoji-weapp-in-24-hours">https://www.rapospectre.com/blog/create-an-onmyoji-weapp-in-24-hours</a> ) 在面试中就很有益处。</p><p>还没完<br>说到抓住校招，今日头条春招刚刚开始，学弟学妹抓紧机会，本人可以内推哦：</p><p>今日头条春季校园招聘火热进行中！ [面向对象] ： 2017 年应届毕业生和 2018 年应届暑期实习生 [职位方向] ：研发、产品、运营、销售、投资、 HR 等 [春季招聘 - 2017 届] ： <a href="https://job.toutiao.com/campus/spring">https://job.toutiao.com/campus/spring</a> [暑期实习 - 2018 届] ： <a href="https://job.toutiao.com/campus/summer">https://job.toutiao.com/campus/summer</a> [投递时间] ： 3 月 9 日 - 4 月 30 日 [头条邀请码] ： iUGUiF （不区分大小写）</p><p>登录相关网址输入我的头条邀请码即可成功内推哟，快到碗里来！！</p><p>社招的同学也别灰心，只要你找得到我的邮箱（ 应该挺好找的 ），简历发给我，帮你内推~</p><p>当然，对于以上其他家公司，只要我拿到 offer 的公司我都可以帮大家推哟。</p><p>面试过程中还去过几家创业公司聊过，发展也很好，比如 青橙科技、视频帮等等，如果大家感兴趣，我都可以帮大家直推 CTO 。</p><p>原文地址 <a href="https://www.rapospectre.com/blog/2017-backend-interview-share">https://www.rapospectre.com/blog/2017-backend-interview-share</a></p><p>作者：rapospectre</p><p>第 1 条附言  ·  2017-03-20 12:27:24 +08:00<br>fib 数列那里是常数空间复杂度哈，文中写错了。 感谢 @razrlele 指正<br> 面试 Python 博主 官170 条回复  •  2020-10-01 21:47:50 +08:00<br>1  2<br>1<br>❮    ❯<br>everhythm            1<br>everhythm      2017-03-20 11:45:21 +08:00<br>郫县群众握爪，同在帝都<br>metrue            2<br>metrue      2017-03-20 11:50:12 +08:00 via iPhone<br>很详细，可是不知道这样泄漏面试内容是否不妥。<br>ljcarsenal            3<br>ljcarsenal      2017-03-20 11:53:02 +08:00<br>真厉害<br>razrlele            4<br>razrlele      2017-03-20 11:58:30 +08:00 via iPhone<br>你写的那个 fib 应该是 O(n)时间复杂度吧，常数时间复杂度应该是套公式法吧？<br>rapospectre            5<br>rapospectre<br>OP<br>   2017-03-20 12:06:51 +08:00<br>@razrlele 是的，面试要求的是要常数空间复杂度，不是时间复杂度哈。<br>rapospectre            6<br>rapospectre<br>OP<br>   2017-03-20 12:07:53 +08:00<br>@metrue 已经省略了很多关键细节，很多题都没写，都直接拿 LeetCode 代替了，只是写了几个比较有意思的题目。<br>rapospectre            7<br>rapospectre<br>OP<br>   2017-03-20 12:08:28 +08:00<br>@everhythm 哈哈，想念豆瓣不<br>rapospectre            8<br>rapospectre<br>OP<br>   2017-03-20 12:08:47 +08:00<br>@ljcarsenal 客气啦<br>xiahei            9<br>xiahei      2017-03-20 12:25:09 +08:00<br>邀请码已用，简历已投，谢谢楼主！！<br>lichao0x7cc            10<br>lichao0x7cc      2017-03-20 12:43:21 +08:00<br>非常感谢楼主的分享。<br>iloveyou            11<br>iloveyou      2017-03-20 12:57:04 +08:00<br>请问能大概透漏下薪资不，本人最近也打算去帝都发展<br>guoer            12<br>guoer      2017-03-20 13:02:01 +08:00 via iPhone<br>写得很好<br>byebyejude            13<br>byebyejude      2017-03-20 13:03:11 +08:00 via Android<br>又是你电道友。。<br>zhihhh            14<br>zhihhh      2017-03-20 13:08:35 +08:00<br>哈哈 楼主的头像果然在哪儿都一样，超高辨识度。。<br>WangYanjie            15<br>WangYanjie      2017-03-20 13:09:51 +08:00<br>“浏览器的一个请求从发送到返回都经历了什么，讲的越详细越好”<br>另一种思路： Client-&gt;DNS-&gt;Load Balancer-&gt;Web Server<br>Amayadream            16<br>Amayadream      2017-03-20 13:13:45 +08:00 via iPhone<br>写的好详细，楼主也好厉害<br>whiler            17<br>whiler      2017-03-20 13:18:54 +08:00<br>看来博主很少逛河畔，握爪<br>HLT            18<br>HLT      2017-03-20 13:26:23 +08:00<br>看完了</p><p>超赞</p><p>满满的干货</p><p>言语诙谐</p><p>祝一直好运<br>cxyfreedom            19<br>cxyfreedom      2017-03-20 13:31:21 +08:00<br>最早是看 tornado 搜到楼主的，真心不错<br>iloveyou            20<br>iloveyou      2017-03-20 13:40:22 +08:00<br>请问楼主是在哪个平台找的工作？智联还是其他？<br>welkinzh            21<br>welkinzh      2017-03-20 13:41:33 +08:00 via Android<br>学习了 谢谢楼主<br>rapospectre            22<br>rapospectre<br>OP<br>   2017-03-20 13:49:36 +08:00<br>@xiahei 不客气！<br>rapospectre            23<br>rapospectre<br>OP<br>   2017-03-20 13:50:14 +08:00<br>@lichao0x7cc 客气啦<br>lxy            24<br>lxy      2017-03-20 13:51:53 +08:00<br>前段时间找 Django 序列化方案看过楼主的项目，可惜不支持 Python3 ……<br>我一直奇怪应该经常用到的功能怎么在 Django 中就这么麻烦。找了一圈感觉貌似 SqlAlchemy 不错，然而 Django 换 ORM 很麻烦，项目做了一半又不能换 Flask 。最后只能用 Django 内建序列化然后自己手动过滤解决，就是代码丑了点。<br>pathbox            25<br>pathbox      2017-03-20 13:54:07 +08:00 via Android<br>lz 面的是 Python 后端<br>Yc1992            26<br>Yc1992      2017-03-20 13:54:39 +08:00<br>楼主透露下拿到的几个 offer 都有多少呗，说个区间也行呀。<br>rapospectre            27<br>rapospectre<br>OP<br>   2017-03-20 13:54:49 +08:00<br>@iloveyou 就是招聘网站上的薪资差不多哈，具体不便透露。<br>rieuse            28<br>rieuse      2017-03-20 13:55:03 +08:00 via Android<br>看完了，必须点个赞！有帮助<br>rapospectre            29<br>rapospectre<br>OP<br>   2017-03-20 13:55:21 +08:00<br>@guoer 谢谢夸奖<br>rapospectre            30<br>rapospectre<br>OP<br>   2017-03-20 13:55:50 +08:00<br>@byebyejude 道友好<br>rapospectre            31<br>rapospectre<br>OP<br>   2017-03-20 13:56:48 +08:00<br>@zhihhh 哈哈哈哈，我是这只绿狗的米弟<br>rapospectre            32<br>rapospectre<br>OP<br>   2017-03-20 13:57:34 +08:00<br>@WangYanjie 是的，其实把这一套说明白面试官就会很满意了<br>rapospectre            33<br>rapospectre<br>OP<br>   2017-03-20 13:57:48 +08:00<br>@Amayadream 谢谢啦<br>rapospectre            34<br>rapospectre<br>OP<br>   2017-03-20 13:58:15 +08:00<br>@HLT 谢谢祝福！！<br>rapospectre            35<br>rapospectre<br>OP<br>   2017-03-20 13:58:48 +08:00<br>@cxyfreedom 之后还会继续写，谢谢支持！<br>rapospectre            36<br>rapospectre<br>OP<br>   2017-03-20 13:59:26 +08:00<br>@iloveyou 拉钩 boss 指聘以及自己去官网投<br>rapospectre            37<br>rapospectre<br>OP<br>   2017-03-20 13:59:47 +08:00<br>@welkinzh 客气啦<br>jppxhz01            38<br>jppxhz01      2017-03-20 14:00:41 +08:00<br>学长好～<br>rapospectre            39<br>rapospectre<br>OP<br>   2017-03-20 14:00:53 +08:00<br>@lxy 我也很诧异，所以自己写了一套，你需要 py3 支持是嘛？ 好的，最近我更新一下，做好 @ 你哈。<br>fancy20            40<br>fancy20      2017-03-20 14:07:48 +08:00<br>斐波那契数列那个估计期望你能用矩阵快速幂，时间复杂度是 O(logn)<br>iamzhuyi            41<br>iamzhuyi      2017-03-20 14:09:48 +08:00<br>不错 收藏了<br>ansheng            42<br>ansheng      2017-03-20 14:14:34 +08:00<br>被露珠面过<br>AdamChrist            43<br>AdamChrist      2017-03-20 14:19:21 +08:00<br>工作好几年了..楼主说的一些问题我好像都不懂…好惭愧…<br>例如 http 里面具体是怎么样的流程…楼主平时有用到这些知识?<br>imink            44<br>imink      2017-03-20 14:22:53 +08:00<br>和楼主经历差不多，也是本来校招的时候，错过了，然后创业（不过我就创业 3 个月，老板不靠谱，就做不下去了，但是自己积累了技术积淀，而且 leetcode 刷题总体上没断）。开始认真找工作的时候就很尴尬了，对于我这去年九月份毕业的人来说，只能硬着头皮投社招，或者一些校招的补招。恭喜楼主找到工作！我也继续加油！<br>imink            45<br>imink      2017-03-20 14:23:33 +08:00<br>好奇楼主为什么没有投递 bat 大厂的社招？<br>robinlovemaggie            46<br>robinlovemaggie      2017-03-20 14:24:55 +08:00<br>想到当年高考一考定终身，再看现在的社会招聘一面二面…… N 面，还是一样的”理论+答题实践“，我们永远都是那个必须能给出正确答案的人，不知为何心生一种隐隐的悲哀……<br>starryin            47<br>starryin      2017-03-20 14:30:12 +08:00<br>果壳还是一如既往之烂啊，当年被果壳从外地约到北京面试，连一家外企报销机票+住宿面试的机会都没等，提前跑到北京，结果约定面试时间到后面试官迟到 20 分钟，面试刚开始就被人叫去开会，然后对通知的人说给我 20 分钟我把这个人面完，结束后还告诉我回去补做一套果壳的笔试题<br>fxxkgw            48<br>fxxkgw      2017-03-20 14:32:33 +08:00<br>建议 LZ 少说点<br>记得知乎上有个大牛拿到暴雪的 offer 然后洋洋洒洒写一堆最后 offer 会收回了。。<br>quxiangxuanqxx            49<br>quxiangxuanqxx      2017-03-20 14:58:37 +08:00<br>@fxxkgw 那个是真的透露太多了，基本上就差一个监控录像和自己的旁白介绍了。。。。炫耀太过了。。。<br>misaka19000            50<br>misaka19000      2017-03-20 15:04:17 +08:00<br>@fxxkgw 哈哈，暴雪那哥们，也是惨<br>rapospectre            51<br>rapospectre<br>OP<br>   2017-03-20 15:23:18 +08:00<br>@pathbox 恩恩，是哒<br>rapospectre            52<br>rapospectre<br>OP<br>   2017-03-20 15:25:20 +08:00<br>@Yc1992 就是网站上的 15-30 呀<br>rapospectre            53<br>rapospectre<br>OP<br>   2017-03-20 15:26:08 +08:00<br>@rieuse 谢谢支持<br>rapospectre            54<br>rapospectre<br>OP<br>   2017-03-20 15:26:36 +08:00<br>@jppxhz01 学弟好，快到碗里来~<br>rapospectre            55<br>rapospectre<br>OP<br>   2017-03-20 15:27:40 +08:00<br>@fancy20 这个高端了，面试的时候能写出来估计面试官会很满意的<br>rapospectre            56<br>rapospectre<br>OP<br>   2017-03-20 15:28:01 +08:00<br>@iamzhuyi 谢谢呀<br>rapospectre            57<br>rapospectre<br>OP<br>   2017-03-20 15:28:45 +08:00<br>@ansheng 你也加油呀~<br>rapospectre            58<br>rapospectre<br>OP<br>   2017-03-20 15:29:34 +08:00<br>@AdamChrist 会用到，看一些框架源码的时候，需要了解底层的处理逻辑哈<br>rapospectre            59<br>rapospectre<br>OP<br>   2017-03-20 15:30:49 +08:00<br>@imink BAT 社招 三年经验起，要么有人能内推你，要么简历造假。头条发展很迅速呀，对于我现在的发展来讲可能更合适一些<br>rapospectre            60<br>rapospectre<br>OP<br>   2017-03-20 15:31:43 +08:00<br>@robinlovemaggie 哎，没办法，竞争压力过大时只能采取这种相对公平的方式进行角逐了<br>repus911            61<br>repus911      2017-03-20 15:32:18 +08:00<br>小公司躺枪。。。发给面你的人看看去<br>rapospectre            62<br>rapospectre<br>OP<br>   2017-03-20 15:32:18 +08:00<br>@starryin 这个确实有点坑<br>congeec            63<br>congeec      2017-03-20 15:33:04 +08:00 via iPhone<br>@misaka19000 不能更惨了<br>rapospectre            64<br>rapospectre<br>OP<br>   2017-03-20 15:34:08 +08:00<br>@fxxkgw 谢谢大兄弟提醒呀，关于新东家的面试信息你有没有发现除了那两道简单的编程题，我都只说了问题没说答案，哈哈哈。<br>rapospectre            65<br>rapospectre<br>OP<br>   2017-03-20 15:36:02 +08:00<br>@repus911 小公司也有小公司的好啊，把握机会。你认识面我的人，厉害。<br>johnny23            66<br>johnny23      2017-03-20 15:39:20 +08:00 via iPhone<br>清水河小师弟<br>yuzhiquan            67<br>yuzhiquan      2017-03-20 15:44:09 +08:00<br>爆炸了，工作三年的人表示很多不会的啊<br>dreamwar            68<br>dreamwar      2017-03-20 15:45:38 +08:00<br>这帖子强<br>Antidictator            69<br>Antidictator      2017-03-20 15:46:57 +08:00<br>Q ：为什么来知乎？</p><p>A ：因为上班可以刷啊。<br>artandlol            70<br>artandlol      2017-03-20 15:47:21 +08:00 via Android<br>k12 就那几家 让猜猜看<br>jz361            71<br>jz361      2017-03-20 15:56:11 +08:00<br>非常感谢楼主，已经收藏了<br>a87150            72<br>a87150      2017-03-20 15:58:13 +08:00<br>难得的好文<br>Michaelssss            73<br>Michaelssss      2017-03-20 16:03:45 +08:00<br>郫县电子竞技高中的校友好~<br>v2orz            74<br>v2orz      2017-03-20 16:27:59 +08:00<br>有帮助，感谢楼主<br>话说一年经验问这么多，我等偏远地方根本没人可用了……苦<br>缓存失效那一块我得再深入研究一下<br>MushishiXian            75<br>MushishiXian      2017-03-20 16:46:43 +08:00<br>很赞的体会分享,谢谢楼主<br>init            76<br>init      2017-03-20 17:24:27 +08:00<br>楼主你好 我最近也在找工作 前一段时间一直在面试现在处于不想找工作的状态很烦，主要是不想干通讯这一行业了想回到互联网公司，悲催的是手头上的项目更多的是偏底层的，导致找工作颇为坎坷，现在都不知道怎么办了<br>KIDJourney            77<br>KIDJourney      2017-03-20 17:32:16 +08:00<br>讲道理。。我刷题比你多， github 和你差不多，之前在饿厂和美团实习，独立搞服务，竞赛也有成绩，而且我今年才毕业。</p><p>但 我 连 头 条 的 面 试 资 格 都 没 有。</p><p>悲伤的故事。<br>留个联系方式，让我们在寒冷的北京面个基。。。<br>rapospectre            78<br>rapospectre<br>OP<br>   2017-03-20 17:39:03 +08:00<br>@johnny23 学长好~<br>rapospectre            79<br>rapospectre<br>OP<br>   2017-03-20 17:39:29 +08:00<br>@yuzhiquan 我也是临时抱佛脚哈<br>rapospectre            80<br>rapospectre<br>OP<br>   2017-03-20 17:39:43 +08:00<br>@dreamwar 谢谢支持<br>rapospectre            81<br>rapospectre<br>OP<br>   2017-03-20 17:40:09 +08:00<br>@Antidictator 哈哈，那在头条不也可以刷<br>2owe            82<br>2owe      2017-03-20 17:54:04 +08:00<br>赞，细节和原理并重。<br>rapospectre            83<br>rapospectre<br>OP<br>   2017-03-20 17:59:45 +08:00<br>@artandlol 已经写了公司名了哟<br>daozhihun            84<br>daozhihun      2017-03-20 17:59:55 +08:00 via Android<br>赞一个，谢谢楼主分享。顺便问下头条招 Java 么？<br>rapospectre            85<br>rapospectre<br>OP<br>   2017-03-20 18:00:06 +08:00<br>@jz361 感谢支持<br>rapospectre            86<br>rapospectre<br>OP<br>   2017-03-20 18:00:19 +08:00<br>@a87150 谢谢夸奖~<br>rapospectre            87<br>rapospectre<br>OP<br>   2017-03-20 18:01:15 +08:00<br>@Michaelssss 道友好<br>rapospectre            88<br>rapospectre<br>OP<br>   2017-03-20 18:01:58 +08:00<br>@v2orz 面试都不是让你造火箭这种类型嘛，啥都要问，我也很方<br>rapospectre            89<br>rapospectre<br>OP<br>   2017-03-20 18:02:16 +08:00<br>@MushishiXian 谢谢支持<br>stanfordwang            90<br>stanfordwang      2017-03-20 18:03:04 +08:00 via Android<br>谢谢分享<br>rapospectre            91<br>rapospectre<br>OP<br>   2017-03-20 18:03:15 +08:00<br>@init 偏底层试试 C++ 的职位？ 我也不是很了解哈，建议你看看我推荐的书和一些知识，找工作还是挺有帮助的<br>rapospectre            92<br>rapospectre<br>OP<br>   2017-03-20 18:04:28 +08:00<br>@KIDJourney 这么厉害！我可以帮你内推啊，投简历这事还得看运气，好啊，我微信就是 rapospectre<br>rapospectre            93<br>rapospectre<br>OP<br>   2017-03-20 18:04:44 +08:00<br>@2owe 感谢支持!<br>KIDJourney            94<br>KIDJourney      2017-03-20 18:07:33 +08:00<br>@rapospectre 内推了很多次了，每次都是 hr 把我简历刷了。。。。服辣<br>Antidictator            95<br>Antidictator      2017-03-20 18:13:44 +08:00 via Android<br>@rapospectre 头条我只刷开发者<br>Allianzcortex            96<br>Allianzcortex      2017-03-20 18:26:58 +08:00 via iPhone<br>很厉害啊:-D<br>a87150            97<br>a87150      2017-03-20 18:32:22 +08:00<br>@rapospectre 发现一个问题，斐波那契数列 打错成 费那波数列<br>jesson            98<br>jesson      2017-03-20 19:46:01 +08:00<br>好多系统设计题啊？难道创业公司或者 Python 的都喜欢问这些？楼主平时是怎么准备这类题目的？<br>onyourroad            99<br>onyourroad      2017-03-20 19:50:37 +08:00<br>985 不是白给的啊。<br>rapospectre            100<br>rapospectre<br>OP<br>   2017-03-20 19:53:40 +08:00<br>@daozhihun 招，不过进来后应该是要写 Python 或者 golang ，头条面试不考语言本身的，你看我面试的时候一点 Python 知识都没考<br>1  2<br>1<br>❮    ❯<br>万维广告联盟<br>V2EX专享😍对象存储cos硬核福利，官方放价1元/年！ 新老用户多重好礼<br>万维广告<br>关于   ·   帮助文档   ·   API   ·   FAQ   ·   我们的愿景   ·   广告投放   ·   感谢   ·   实用小工具   ·   4641 人在线   最高记录 5497   ·      Select Language<br>创意工作者们的社区<br>World is powered by solitude<br>VERSION: 3.9.8.5 · 46ms · UTC 02:20 · PVG 10:20 · LAX 18:20 · JFK 21:20<br>Developed with CodeLauncher<br>♥ Do have faith in what you’re doing.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-python类变量和实例变量的异同&quot;&gt;&lt;a href=&quot;#1-python类变量和实例变量的异同&quot; class=&quot;headerlink&quot; title=&quot;1. python类变量和实例变量的异同&quot;&gt;&lt;/a&gt;1. python类变量和实例变量的异同&lt;/h2&gt;&lt;ul</summary>
      
    
    
    
    <category term="python" scheme="http://shizhonggan.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://shizhonggan.github.io/tags/python/"/>
    
    <category term="后端" scheme="http://shizhonggan.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Docker 部署 Django-Mysql常见错误</title>
    <link href="http://shizhonggan.github.io/2022/01/30/Django/djangodeployerror/"/>
    <id>http://shizhonggan.github.io/2022/01/30/Django/djangodeployerror/</id>
    <published>2022-01-30T03:03:04.000Z</published>
    <updated>2022-02-08T02:45:08.139Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> apt-get install python3-dev nginx</span><br><span class="line">pip3 install -i  https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple uwsgi</span><br><span class="line"></span><br><span class="line">apt-get install mysql-server mysql-client # 连接数据库需要的环境</span><br><span class="line">apt-get install libmysqlclient-dev</span><br><span class="line">pip3 install -i  https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple mysqlclient</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker: Error response from daemon: driver failed programming external connectivity on endpoint testcontainer (c55fc0dd481c36765fcd968118c3fbf5c7fa686cdfc625c485f963109b0f89e3):  (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0&#x2F;0 --dport 5000 -j DNAT --to-destination 172.17.0.2:80 ! -i docker0: iptables: No chain&#x2F;target&#x2F;match by that name.</span><br><span class="line"> (exit status 1))</span><br><span class="line"></span><br><span class="line"># Enter below command, it will clear all chains.</span><br><span class="line">$ sudo iptables -t filter -F</span><br><span class="line">$ iptables -t filter -X</span><br><span class="line"># Then restart Docker Service using below comamnd</span><br><span class="line">$ systemctl restart docker</span><br><span class="line"></span><br><span class="line">ModuleNotFoundError: No module named &#39;statsmodels&#39;</span><br><span class="line"></span><br><span class="line">pip3 install -i  https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple statsmodels</span><br></pre></td></tr></table></figure><h2 id="django-连接已有的MySQL数据库-操作方式"><a href="#django-连接已有的MySQL数据库-操作方式" class="headerlink" title="django 连接已有的MySQL数据库 操作方式"></a>django 连接已有的MySQL数据库 操作方式</h2><h3 id="方法一：采用django自由的语法进行操作"><a href="#方法一：采用django自由的语法进行操作" class="headerlink" title="方法一：采用django自由的语法进行操作"></a>方法一：采用django自由的语法进行操作</h3><p>参考：<a href="https://docs.djangoproject.com/zh-hans/3.0/howto/legacy-databases/">https://docs.djangoproject.com/zh-hans/3.0/howto/legacy-databases/</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">python manage.py inspectdb <span class="comment"># 将mysql的数据库创建对应的模型</span></span><br><span class="line">python manage.py inspectdb &gt; models.py <span class="comment"># 将结果保存成文件</span></span><br><span class="line">python manage.py database table_name &gt; models.py <span class="comment"># 只输出特定数据库下某张表对应的模型 </span></span><br><span class="line"><span class="comment">## 例如：</span></span><br><span class="line">class Person(models.Model):</span><br><span class="line">    id = models.IntegerField(primary_key=True)</span><br><span class="line">    first_name = models.CharField(max_length=70)</span><br><span class="line">    class Meta:</span><br><span class="line">       managed = False <span class="comment"># 默认不能进行创建、修改和删除 ，此处修改为True</span></span><br><span class="line">       db_table = <span class="string">&#x27;CENSUS_PERSONS&#x27;</span></span><br><span class="line"></span><br><span class="line">python manage.py migrate </span><br></pre></td></tr></table></figure><p>方法一会存在以下几个问题：（django=2.2，本地windows环境）</p><ul><li>生成model.py文件时，应当在app目录下生成，否则会报错，得不到相应的模型</li><li>生成的model.py文件，是utf-16进制（或其他格式），需要转换为utf-8进制，否则无法识别文件，pycharm右下角可以看到文件进制并修改</li><li>数据库的表存在依赖关系，别名重复等情况。在指定特定表生成模型，注意也要将其他表也生成下来，同时别名重复需要加related_name，可以仔细阅读报错信息进行相应操作</li><li>多个数据库之前不容易操作，需要配置多数据库</li><li>多数据库识别，虽然setting配置了多数据库，但是还是要进行路由操作才能识别，否则只能识别default数据库</li></ul><h3 id="方法二：-第三方库"><a href="#方法二：-第三方库" class="headerlink" title="方法二： 第三方库"></a>方法二： 第三方库</h3><p>pymysql，优点：</p><ul><li>免去多数据库的路由配置</li><li>直接用mysql语句</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="Django" scheme="http://shizhonggan.github.io/categories/Django/"/>
    
    
    <category term="Docker" scheme="http://shizhonggan.github.io/tags/Docker/"/>
    
    <category term="Django" scheme="http://shizhonggan.github.io/tags/Django/"/>
    
    <category term="Mysql" scheme="http://shizhonggan.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Ansible学习笔记--roles</title>
    <link href="http://shizhonggan.github.io/2021/12/29/Ansible/roles/"/>
    <id>http://shizhonggan.github.io/2021/12/29/Ansible/roles/</id>
    <published>2021-12-29T02:24:04.000Z</published>
    <updated>2022-01-06T09:01:37.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="roles"><a href="#roles" class="headerlink" title="roles"></a>roles</h2><p>ansible自1.2版本引入的新特性，用于层次性、结构化地组织playbook。<br>roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。<br>要使用roles只需要在playbook中使用include[<strong>已经废弃不用了</strong>]指令即可。<br>简单来讲，roles就是通过分别将变量、文件、任务、模板及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。<br>角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中</p><p>复杂场景：建议使用roles，代码复用度高</p><ul><li>变更指定主机或主机组</li><li>如命名不规范维护和传承成本大</li><li>某些功能需多个Playbook，通过includes即可实现</li></ul><p>角色(roles)：角色集合</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir roles/&#123;mysql,httpd,nginx,memcache&#125; -pv </span><br><span class="line">tree roles</span><br><span class="line">roles/</span><br><span class="line">    mysql/</span><br><span class="line">    httpd/</span><br><span class="line">    nginx/</span><br><span class="line">    memcached/</span><br></pre></td></tr></table></figure><h2 id="基于ansible-roles-安装-nginx"><a href="#基于ansible-roles-安装-nginx" class="headerlink" title="基于ansible roles 安装 nginx"></a>基于ansible roles 安装 nginx</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 环境准备，清除已安装的nginx和用户组</span></span><br><span class="line">ansible internal -m shell -a <span class="string">&#x27;yum -y remove nginx&#x27;</span> -b</span><br><span class="line">ansible internal -m shell -a <span class="string">&#x27;rpm -q nginx&#x27;</span></span><br><span class="line">ansible internal -m shell -a <span class="string">&#x27;getent passwd nginx&#x27;</span></span><br><span class="line">ansible internal -m shell -a <span class="string">&#x27;getent group nginx&#x27;</span> </span><br><span class="line">ansible internal -m user -a <span class="string">&#x27;name=nginx state=absent&#x27;</span> -b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始</span></span><br><span class="line"><span class="built_in">cd</span> ansible/ <span class="comment"># 根目录</span></span><br><span class="line"><span class="built_in">cd</span> roles/nginx <span class="comment"># 项目文件夹</span></span><br><span class="line"></span><br><span class="line">[ec2-user@master ansible]$ tree</span><br><span class="line">.</span><br><span class="line">├── nginx_role.yml <span class="comment"># 调用文件</span></span><br><span class="line">└── roles</span><br><span class="line">    ├── httpd</span><br><span class="line">    ├── memcached</span><br><span class="line">    ├── mysql</span><br><span class="line">    └── nginx</span><br><span class="line">        ├── tasks <span class="comment"># 在该文件下创建多个任务</span></span><br><span class="line">        │   ├── group.yml</span><br><span class="line">        │   ├── main.yml <span class="comment"># 入口文件</span></span><br><span class="line">        │   ├── restart.yml</span><br><span class="line">        │   ├── start.yml</span><br><span class="line">        │   ├── template.yml</span><br><span class="line">        │   ├── user.yml</span><br><span class="line">        │   └── yum.yml</span><br><span class="line">        └── templates <span class="comment"># 创建配置文件的j2模板</span></span><br><span class="line">            └── nginx.conf.j2</span><br><span class="line"></span><br><span class="line">mkdir tasks templates <span class="comment"># 创建两个常用文件夹</span></span><br><span class="line"><span class="built_in">cd</span> tasks</span><br><span class="line">vi main.yml <span class="comment"># 入口</span></span><br><span class="line">- include: group.yml</span><br><span class="line">- include: user.yml</span><br><span class="line">- include: yum.yml</span><br><span class="line">- include: template.yml</span><br><span class="line">- include: start.yml</span><br><span class="line"></span><br><span class="line">vi group.yml</span><br><span class="line">- name: create group</span><br><span class="line">  group: name=nginx gid=80</span><br><span class="line"></span><br><span class="line">vi user.yml</span><br><span class="line">- name: create user</span><br><span class="line">  user: name=nginx uid=80 group=nginx system=yes shell=/sbin/nologin</span><br><span class="line"></span><br><span class="line">vi yum.yml</span><br><span class="line">- name: install package</span><br><span class="line">  yum: name=nginx</span><br><span class="line"></span><br><span class="line">vi template.yml</span><br><span class="line">- name: copy conf</span><br><span class="line">  template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line">vi start.yml</span><br><span class="line">- name: start service</span><br><span class="line">  service: name=nginx state=started enabled=yes</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ../../../</span><br><span class="line">vi nginx_role.yml</span><br><span class="line">---</span><br><span class="line">- hosts: internal</span><br><span class="line">  remote_user: ec2-user</span><br><span class="line">  become: yes</span><br><span class="line">  roles:</span><br><span class="line">    - role: nginx</span><br><span class="line"></span><br><span class="line">ansible-playbook -C nginx_role.yml <span class="comment"># 检查再执行</span></span><br><span class="line"></span><br><span class="line">rpm -qa nginx <span class="comment"># 查看系统是否有这个安装包</span></span><br><span class="line">ansible internal -m shell -a <span class="string">&#x27;ss -ntlp&#x27;</span> <span class="comment"># 可查看到80端口</span></span><br><span class="line">ansible internal -m shell -a <span class="string">&#x27;ps aux|grep nginx&#x27;</span> <span class="comment"># 查看进程 </span></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## roles目录结构</span></span><br><span class="line">可以互相调用,roles目录结构,每个角色，以特定的层级目录结构进行组织</span><br></pre></td></tr></table></figure><p>playbook.yml  调用角色<br>roles/<br>  project/ (角色名称)<br>    tasks/<br>    files/<br>    vars/<br>    templates/<br>    handlers/<br>    default/ 不常用<br>    meta/    不常用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Roles各目录作用</span><br></pre></td></tr></table></figure><p>/roles/project/ :项目名称,有以下子目录<br>    files/ ：存放由copy或script模块等调用的文件<br>    templates/：template模块查找所需要模板文件的目录<br>    tasks/：定义task,role的基本元素，至少应该包含一个名为main.yml的文件；<br>            其它的文件需要在此文件中通过include进行包含<br>    handlers/：至少应该包含一个名为main.yml的文件；<br>               其它的文件需要在此文件中通过include进行包含<br>    vars/：定义变量，至少应该包含一个名为main.yml的文件；<br>           其它的文件需要在此文件中通过include进行包含<br>    meta/：定义当前角色的特殊设定及其依赖关系,至少应该包含一个名为main.yml的文件，<br>           其它文件需在此文件中通过include进行包含<br>    default/：设定默认变量时使用此目录中的main.yml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roles&#x2F;appname 目录结构</span><br></pre></td></tr></table></figure><pre><code>tasks目录：至少应该包含一个名为main.yml的文件，其定义了此角色的任务列表；           此文件可以使用include包含其它的位于此目录中的task文件files目录：存放由copy或script等模块调用的文件；templates目录：template模块会自动在此目录中寻找Jinja2模板文件handlers目录：此目录中应当包含一个main.yml文件，用于定义此角色用到的各handler；              在handler中使用include包含的其它的handler文件也应该位于此目录中；vars目录：应当包含一个main.yml文件，用于定义此角色用到的变量；meta目录：应当包含一个main.yml文件，用于定义此角色的特殊设定及其依赖关系；          ansible1.3及其以后的版本才支持；default目录：为当前角色设定默认变量时使用此目录；应当包含一个main.yml文件</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">roles&#x2F;example_role&#x2F;files&#x2F;             所有文件，都将可存放在这里</span><br><span class="line">roles&#x2F;example_role&#x2F;templates&#x2F;         所有模板都存放在这里</span><br><span class="line">roles&#x2F;example_role&#x2F;tasks&#x2F;main.yml：   主函数，包括在其中的所有任务将被执行</span><br><span class="line">roles&#x2F;example_role&#x2F;handlers&#x2F;main.yml：所有包括其中的 handlers 将被执行</span><br><span class="line">roles&#x2F;example_role&#x2F;vars&#x2F;main.yml：    所有包括在其中的变量将在roles中生效</span><br><span class="line">roles&#x2F;example_role&#x2F;meta&#x2F;main.yml：    roles所有依赖将被正常登入</span><br></pre></td></tr></table></figure><h2 id="创建role"><a href="#创建role" class="headerlink" title="创建role"></a>创建role</h2><p>创建role的步骤</p><ul><li>创建以roles命名的目录</li><li>在roles目录中分别创建以各角色名称命名的目录，如webservers等</li><li>在每个角色命名的目录中分别创建files、handlers、meta、tasks、templates和vars目录；用不到的目录可以创建为空目录，也可以不创建</li><li>在playbook文件中，调用各角色</li></ul><h2 id="实验-创建httpd角色"><a href="#实验-创建httpd角色" class="headerlink" title="实验: 创建httpd角色"></a>实验: 创建httpd角色</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">1&gt; 创建roles目录</span><br><span class="line">   mkdir roles&#x2F;&#123;httpd,mysql,redis&#125;&#x2F;tasks -pv</span><br><span class="line">   mkdir  roles&#x2F;httpd&#x2F;&#123;handlers,files&#125;</span><br><span class="line"></span><br><span class="line">查看目录结构</span><br><span class="line">tree roles&#x2F;</span><br><span class="line">    roles&#x2F;</span><br><span class="line">    ├── httpd</span><br><span class="line">    │   ├── files</span><br><span class="line">    │   ├── handlers</span><br><span class="line">    │   └── tasks</span><br><span class="line">    ├── mysql</span><br><span class="line">    │   └── tasks</span><br><span class="line">    └── redis</span><br><span class="line">        └── tasks</span><br><span class="line"></span><br><span class="line">2&gt; 创建目标文件</span><br><span class="line">   cd roles&#x2F;httpd&#x2F;tasks&#x2F;</span><br><span class="line">   touch install.yml config.yml service.yml</span><br><span class="line"></span><br><span class="line">3&gt; vim install.yml</span><br><span class="line">   - name: install httpd package</span><br><span class="line">     yum: name&#x3D;httpd</span><br><span class="line">     </span><br><span class="line">   vim config.yml</span><br><span class="line">   - name: config file  </span><br><span class="line">     copy: src&#x3D;httpd.conf dest&#x3D;&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F; backup&#x3D;yes </span><br><span class="line">   </span><br><span class="line">   vim service.yml</span><br><span class="line">   - name: start service </span><br><span class="line">     service: name&#x3D;httpd state&#x3D;started enabled&#x3D;yes</span><br><span class="line">     </span><br><span class="line">4&gt; 创建main.yml主控文件,调用以上单独的yml文件,</span><br><span class="line">   main.yml定义了谁先执行谁后执行的顺序</span><br><span class="line">   vim main.yml</span><br><span class="line">   - include: install.yml</span><br><span class="line">   - include: config.yml</span><br><span class="line">   - include: service.yml</span><br><span class="line">   </span><br><span class="line">5&gt; 准备httpd.conf文件,放到httpd单独的文件目录下</span><br><span class="line">   cp &#x2F;app&#x2F;ansible&#x2F;flies&#x2F;httpd.conf ..&#x2F;files&#x2F;</span><br><span class="line">   </span><br><span class="line">6&gt; 创建一个网页</span><br><span class="line">   vim flies&#x2F;index.html</span><br><span class="line">   &lt;h1&gt; welcome to weixiaodong home &lt;\h1&gt;</span><br><span class="line"></span><br><span class="line">7&gt; 创建网页的yml文件</span><br><span class="line">   vim tasks&#x2F;index.yml</span><br><span class="line">   - name: index.html</span><br><span class="line">     copy: src&#x3D;index.html dest&#x3D;&#x2F;var&#x2F;www&#x2F;html </span><br><span class="line"></span><br><span class="line">8&gt; 将网页的yml文件写进mian.yml文件中</span><br><span class="line">   vim mian.yml</span><br><span class="line">   - include: install.yml</span><br><span class="line">   - include: config.yml</span><br><span class="line">   - include: index.yml</span><br><span class="line">   - include: service.yml</span><br><span class="line"></span><br><span class="line">9&gt; 在handlers目录下创建handler文件mian.yml</span><br><span class="line">   vim handlers&#x2F;main.yml</span><br><span class="line">   - name: restart service httpd</span><br><span class="line">     service: name&#x3D;httpd state&#x3D;restarted</span><br><span class="line"></span><br><span class="line">10&gt; 创建文件调用httpd角色</span><br><span class="line">    cd &#x2F;app&#x2F;ansidle&#x2F;roles</span><br><span class="line">    vim role_httpd.yml</span><br><span class="line">    ---</span><br><span class="line">    # httpd role</span><br><span class="line">    - hosts: appsrvs</span><br><span class="line">      remote_user: root </span><br><span class="line"></span><br><span class="line">      roles:       #调用角色</span><br><span class="line">        - role: httpd  </span><br><span class="line">        </span><br><span class="line">11&gt; 查看目录结构</span><br><span class="line">    tree </span><br><span class="line">    .</span><br><span class="line">    httpd</span><br><span class="line">    ├── files</span><br><span class="line">    │   ├── httpd.conf</span><br><span class="line">    │   └── index.html</span><br><span class="line">    ├── handlers</span><br><span class="line">    │   └── main.yml</span><br><span class="line">    └── tasks</span><br><span class="line">        ├── config.yml</span><br><span class="line">        ├── index.yml</span><br><span class="line">        ├── install.yml</span><br><span class="line">        ├── main.yml</span><br><span class="line">        └── service.yml</span><br><span class="line"></span><br><span class="line">12&gt; ansible-playbook role_httpd.yml</span><br><span class="line">针对大型项目使用Roles进行编排</span><br><span class="line">roles目录结构：</span><br><span class="line">playbook.yml</span><br><span class="line">roles&#x2F;</span><br><span class="line">  project&#x2F;</span><br><span class="line">    tasks&#x2F;</span><br><span class="line">    files&#x2F;</span><br><span class="line">    vars&#x2F;</span><br><span class="line">    templates&#x2F;</span><br><span class="line">    handlers&#x2F;</span><br><span class="line">    default&#x2F; # 不经常用</span><br><span class="line">    meta&#x2F;    # 不经常用</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">nginx-role.yml</span><br><span class="line">roles&#x2F;</span><br><span class="line">└── nginx</span><br><span class="line">    ├── files</span><br><span class="line">    │ └── main.yml</span><br><span class="line">    ├── tasks</span><br><span class="line">    │ ├── groupadd.yml</span><br><span class="line">    │ ├── install.yml</span><br><span class="line">    │ ├── main.yml</span><br><span class="line">    │ ├── restart.yml</span><br><span class="line">    │ └── useradd.yml</span><br><span class="line">    └── vars</span><br><span class="line">        └── main.yml</span><br><span class="line">示例</span><br><span class="line">roles的示例如下所示：</span><br><span class="line">site.yml</span><br><span class="line">webservers.yml</span><br><span class="line">dbservers.yml</span><br><span class="line">roles&#x2F;</span><br><span class="line">  common&#x2F;</span><br><span class="line">    files&#x2F;</span><br><span class="line">    templates&#x2F;</span><br><span class="line">    tasks&#x2F;</span><br><span class="line">    handlers&#x2F;</span><br><span class="line">    vars&#x2F;</span><br><span class="line">    meta&#x2F;</span><br><span class="line">  webservers&#x2F;</span><br><span class="line">    files&#x2F;</span><br><span class="line">    templates&#x2F;</span><br><span class="line">    tasks&#x2F;</span><br><span class="line">  handlers&#x2F;</span><br><span class="line">    vars&#x2F;</span><br><span class="line">    meta&#x2F;</span><br><span class="line">实验： 创建一个nginx角色</span><br><span class="line">建立nginx角色在多台主机上来部署nginx需要安装 创建账号</span><br><span class="line">1&gt; 创建nginx角色目录</span><br><span class="line">     cd &#x2F;app&#x2F;ansible&#x2F;role</span><br><span class="line">     mkdir nginx&#123;tesks,templates,hanslers&#125; -pv</span><br><span class="line"></span><br><span class="line">2&gt; 创建任务目录</span><br><span class="line">     cd tasks&#x2F;</span><br><span class="line">     touch insatll.yml config.yml service.yml file.yml user.yml</span><br><span class="line">   创建main.yml文件定义任务执行顺序</span><br><span class="line">     vim main.yml</span><br><span class="line">     - include: user.yml</span><br><span class="line">     - include: insatll.yml</span><br><span class="line">     - include: config.yml</span><br><span class="line">     - include: file.yml</span><br><span class="line">     - include: service.yml</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">3&gt; 准备配置文件(centos7、8)</span><br><span class="line">   ll &#x2F;app&#x2F;ansible&#x2F;role&#x2F;nginx&#x2F;templates&#x2F;</span><br><span class="line">   nginx7.conf.j2</span><br><span class="line">   nginx8.conf.j2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4&gt; 定义任务</span><br><span class="line">   vim tasks&#x2F;install.yml</span><br><span class="line">   - name: install</span><br><span class="line">     yum: name&#x3D;nginx</span><br><span class="line">     </span><br><span class="line">   vim tasks&#x2F;config.yml</span><br><span class="line">    - name: config file</span><br><span class="line">      template: src&#x3D;nginx7.conf.j2 dest&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">      when: ansible_distribution_major_version&#x3D;&#x3D;&quot;7&quot;</span><br><span class="line">      notify: restrat</span><br><span class="line">      </span><br><span class="line">    - name: config file</span><br><span class="line">      template: src&#x3D;nginx8.conf.j2 dest&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">      when: ansible_distribution_major_version&#x3D;&#x3D;&quot;8&quot;</span><br><span class="line">      notify: restrat</span><br><span class="line">      </span><br><span class="line">    vim tasks&#x2F;file.yml   跨角色调用file.yum文件,实现文件复用</span><br><span class="line">    - name: index.html</span><br><span class="line">      copy: src&#x3D;roles&#x2F;httpd&#x2F;files&#x2F;index.html dest&#x3D;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F; </span><br><span class="line">   </span><br><span class="line">    vim tasks&#x2F;service.yml</span><br><span class="line">    - nmae: start service</span><br><span class="line">      service: name&#x3D;nginx state&#x3D;started enabled&#x3D;yes</span><br><span class="line">      </span><br><span class="line">    vim handlers&#x2F;main.yml</span><br><span class="line">    - name: restrat</span><br><span class="line">      service: name&#x3D;nginx state&#x3D;restarted</span><br><span class="line">      </span><br><span class="line">    vim roles&#x2F;role_nginix.yml</span><br><span class="line">    --- </span><br><span class="line">    #test rcle</span><br><span class="line">    - hosts: appsrvs</span><br><span class="line">    </span><br><span class="line">      roles: </span><br><span class="line">        - role: nginx</span><br><span class="line">        </span><br><span class="line">5&gt; 测试安装</span><br><span class="line">   ansible-playbook role_nginx.yml</span><br></pre></td></tr></table></figure><h2 id="playbook调用角色"><a href="#playbook调用角色" class="headerlink" title="playbook调用角色"></a>playbook调用角色</h2><p>调用角色方法1：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">websrvs</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">memcached</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><p>调用角色方法2：传递变量给角色</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">  <span class="attr">remote_user:</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">role:</span> <span class="string">nginx</span>, <span class="attr">username:</span> <span class="string">nginx</span> &#125;   <span class="comment">#不同的角色调用不同的变量  </span></span><br><span class="line">    <span class="string">键role用于指定角色名称</span></span><br><span class="line">    <span class="string">后续的k/v用于传递变量给角色</span></span><br></pre></td></tr></table></figure><p>调用角色方法3：还可基于条件测试实现角色调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roles:</span><br><span class="line">  - &#123; role: nginx, username: nginx, when: ansible_distribution_major_version &#x3D;&#x3D; &#39;7&#39; &#125;</span><br></pre></td></tr></table></figure><h2 id="通过roles传递变量"><a href="#通过roles传递变量" class="headerlink" title="通过roles传递变量"></a>通过roles传递变量</h2><p>当给一个主机应用角色的时候可以传递变量，然后在角色内使用这些变量</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- hosts: webservers</span><br><span class="line">  roles:</span><br><span class="line">    - common</span><br><span class="line">    - &#123; role: foo_app_instance, dir: &#39;&#x2F;web&#x2F;htdocs&#x2F;a.com&#39;, port: 8080 &#125;</span><br></pre></td></tr></table></figure><h2 id="向roles传递参数"><a href="#向roles传递参数" class="headerlink" title="向roles传递参数"></a>向roles传递参数</h2><p>而在playbook中，可以这样使用roles:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">common</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">webservers</span></span><br></pre></td></tr></table></figure><p>也可以向roles传递参数,示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: webservers</span><br><span class="line">  roles:</span><br><span class="line">    - common</span><br><span class="line">    - &#123; role: foo_app_instance, dir: &#39;&#x2F;opt&#x2F;a&#39;, port: 5000 &#125;</span><br><span class="line">    - &#123; role: foo_app_instance, dir: &#39;&#x2F;opt&#x2F;b&#39;, port: 5001 &#125;</span><br></pre></td></tr></table></figure><h2 id="条件式地使用roles"><a href="#条件式地使用roles" class="headerlink" title="条件式地使用roles"></a>条件式地使用roles</h2><p>示例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">role:</span> <span class="string">some_role</span>, <span class="attr">when:</span> <span class="string">&quot;ansible_os_family == &#x27;RedHat&#x27;&quot;</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="Roles条件及变量等案例"><a href="#Roles条件及变量等案例" class="headerlink" title="Roles条件及变量等案例"></a>Roles条件及变量等案例</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># When条件</span></span><br><span class="line">    <span class="attr">roles:</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">role:</span> <span class="string">nginx</span>, <span class="attr">when:</span> <span class="string">&quot;ansible_distribution_major_version == &#x27;7&#x27; &quot;</span> ,<span class="attr">username:</span> <span class="string">nginx</span> &#125;</span><br><span class="line"><span class="comment"># 变量调用</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">zabbix-proxy</span></span><br><span class="line">  <span class="attr">sudo:</span> <span class="literal">yes</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">role:</span> <span class="string">geerlingguy.php-mysql</span> &#125;</span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">role:</span> <span class="string">dj-wasabi.zabbix-proxy</span>, <span class="attr">zabbix_server_host:</span> <span class="number">192.168</span><span class="number">.37</span><span class="number">.167</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="完整的roles架构"><a href="#完整的roles架构" class="headerlink" title="完整的roles架构"></a>完整的roles架构</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx-role.yml 顶层任务调用yml文件</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">testweb</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">httpd</span> <span class="string">可执行多个role</span></span><br><span class="line"></span><br><span class="line"><span class="string">cat</span> <span class="string">roles/nginx/tasks/main.yml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">include:</span> <span class="string">groupadd.yml</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">include:</span> <span class="string">useradd.yml</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">include:</span> <span class="string">install.yml</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">include:</span> <span class="string">restart.yml</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">include:</span> <span class="string">filecp.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># roles/nginx/tasks/groupadd.yml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">group</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">name=nginx</span> <span class="string">state=present</span></span><br><span class="line"></span><br><span class="line"><span class="string">cat</span> <span class="string">roles/nginx/tasks/filecp.yml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">file</span> <span class="string">copy</span></span><br><span class="line">  <span class="attr">copy:</span> <span class="string">src=tom.conf</span> <span class="string">dest=/tmp/tom.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#以下文件格式类似：</span></span><br><span class="line"><span class="string">useradd.yml,install.yml,restart.yml</span></span><br><span class="line"></span><br><span class="line"><span class="string">ls</span> <span class="string">roles/nginx/files/</span></span><br><span class="line"><span class="string">tom.conf</span></span><br></pre></td></tr></table></figure><h2 id="roles-playbook-tags使用"><a href="#roles-playbook-tags使用" class="headerlink" title="roles playbook tags使用"></a>roles playbook tags使用</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ansible-playbook</span> <span class="string">--tags=&quot;nginx,httpd,mysql&quot;</span> <span class="string">nginx-role.yml</span> <span class="comment">#对标签进行挑选执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  nginx-role.yml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">testweb</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">role:</span> <span class="string">nginx</span> ,<span class="attr">tags:</span> [ <span class="string">&#x27;nginx&#x27;</span>, <span class="string">&#x27;web&#x27;</span> ] ,<span class="attr">when:</span> <span class="string">ansible_distribution_major_version</span> <span class="string">==</span> <span class="string">&quot;6“ &#125;</span></span><br><span class="line"><span class="string">    - &#123; role: httpd ,tags: [ &#x27;httpd&#x27;, &#x27;web&#x27; ] &#125;</span></span><br><span class="line"><span class="string">    - &#123; role: mysql ,tags: [ &#x27;mysql&#x27;, &#x27;db&#x27; ] &#125;</span></span><br><span class="line"><span class="string">    - &#123; role: marridb ,tags: [ &#x27;mysql&#x27;, &#x27;db&#x27; ] &#125;</span></span><br><span class="line"><span class="string">    - &#123; role: php &#125;</span></span><br></pre></td></tr></table></figure><h2 id="实验-创建角色memcached"><a href="#实验-创建角色memcached" class="headerlink" title="实验: 创建角色memcached"></a>实验: 创建角色memcached</h2><p>memcacched 当做缓存用,会在内存中开启一块空间充当缓存</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cat</span> <span class="string">/etc/sysconfig/memcached</span> </span><br><span class="line">    <span class="string">PORT=&quot;11211&quot;</span></span><br><span class="line">    <span class="string">USER=&quot;memcached&quot;</span></span><br><span class="line">    <span class="string">MAXCONN=&quot;1024&quot;</span></span><br><span class="line">    <span class="string">CACHESIZE=&quot;64&quot;</span>    <span class="comment"># 缓存空间默认64M </span></span><br><span class="line">    <span class="string">OPTIONS=&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="string">&gt;</span> <span class="string">创建对用目录</span></span><br><span class="line">   <span class="string">cd</span> <span class="string">/app/ansible</span></span><br><span class="line">   <span class="string">mkdir</span> <span class="string">roles/memcached/&#123;tasks,templates&#125;</span> <span class="string">-pv</span></span><br><span class="line">   </span><br><span class="line"><span class="number">2</span><span class="string">&gt;</span> <span class="string">拷贝memcached配置文件模板</span></span><br><span class="line">   <span class="string">cp</span> <span class="string">/etc/sysconfig/memcached</span>  <span class="string">templates/memcached.j2</span></span><br><span class="line">   <span class="string">vim</span> <span class="string">templates/memcached.j2</span></span><br><span class="line">   <span class="string">CACHESIZE=&quot;&#123;&#123;ansible_memtotal_mb//4&#125;&#125;&quot;</span>   <span class="comment">#物理内存的1/4用做缓存</span></span><br><span class="line">   </span><br><span class="line"><span class="number">3</span><span class="string">&gt;</span> <span class="string">创建对应yml文件,并做相应配置</span></span><br><span class="line">   <span class="string">cd</span> <span class="string">tasks/</span></span><br><span class="line">   <span class="string">touch</span> <span class="string">install.yml</span> <span class="string">config.yml</span> <span class="string">service.yml</span></span><br><span class="line">   <span class="string">创建main.yml文件定义任务执行顺序</span></span><br><span class="line">   <span class="string">vim</span> <span class="string">main.yml</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">include:</span> <span class="string">install.yml</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">include:</span> <span class="string">config.yml</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">include:</span> <span class="string">service.yml</span>  </span><br><span class="line">   </span><br><span class="line">   <span class="string">vim</span> <span class="string">install.yml</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> </span><br><span class="line">     <span class="attr">yum:</span> <span class="string">name=memcached</span></span><br><span class="line">     </span><br><span class="line">   <span class="string">vim</span> <span class="string">config.yml</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span> <span class="string">file</span></span><br><span class="line">     <span class="attr">template:</span> <span class="string">src=memcached.j2</span> <span class="string">dets=/etc/sysconfig/memcached</span></span><br><span class="line"></span><br><span class="line">   <span class="string">vim</span> <span class="string">service.yml</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">service</span></span><br><span class="line">     <span class="attr">service:</span> <span class="string">name=memcached</span> <span class="string">state=started</span> <span class="string">enabled=yes</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span><span class="string">&gt;</span> <span class="string">创建调用角色文件</span></span><br><span class="line">   <span class="string">cd</span> <span class="string">/app/ansible/roles/</span></span><br><span class="line">   <span class="string">vim</span> <span class="string">role_memcached.yml</span></span><br><span class="line">    <span class="string">---</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">appsrvs</span></span><br><span class="line">    </span><br><span class="line">      <span class="attr">roles:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">memcached</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span><span class="string">&gt;</span> <span class="string">安装</span></span><br><span class="line">   <span class="string">ansible-playbook</span>  <span class="string">role_memcached.yml</span> </span><br><span class="line">   <span class="string">memcached端口号11211</span></span><br></pre></td></tr></table></figure><h2 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h2><ul><li>委任（指定某一台机器做某一个task）<ul><li>delegate_to</li><li>local_action (专指针对ansible命令执行的机器做的变更操作)</li></ul></li><li>交互提示<ul><li>prompt</li></ul></li><li>*暂停（java）<ul><li>wait_for</li></ul></li><li>Debug<ul><li>debug: msg=”This always executes.”</li></ul></li><li>Include</li><li>Template 多值合并</li><li>Template 动态变量配置</li></ul><h2 id="Ansible-Roles"><a href="#Ansible-Roles" class="headerlink" title="Ansible Roles"></a>Ansible Roles</h2><ul><li>委任<ul><li>delegate_to</li></ul></li><li>交互提示<ul><li>prompt</li></ul></li><li>暂停<ul><li>wait_for</li></ul></li><li>Debug<ul><li>debug: msg=”This always executes.”</li></ul></li><li>Include</li><li>Template 多值合并</li><li>Template 动态变量配置</li></ul><h2 id="推荐资料"><a href="#推荐资料" class="headerlink" title="推荐资料"></a>推荐资料</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;galaxy.ansible.com</span><br><span class="line">https:&#x2F;&#x2F;galaxy.ansible.com&#x2F;explore#&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;github.com&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;ansible.com.cn&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ansible&#x2F;ansible</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ansible&#x2F;ansible-examples</span><br></pre></td></tr></table></figure><h2 id="实验-实现二进制安装mysql的卸载"><a href="#实验-实现二进制安装mysql的卸载" class="headerlink" title="实验: 实现二进制安装mysql的卸载"></a>实验: 实现二进制安装mysql的卸载</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cat</span> <span class="string">remove_mysql.yml</span> </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># install mariadb server </span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">appsrvs:!192.168.38.108</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">stop</span> <span class="string">service</span> </span><br><span class="line">      <span class="attr">shell:</span> <span class="string">/etc/init.d/mysqld</span> <span class="string">stop</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">delete</span> <span class="string">user</span> </span><br><span class="line">      <span class="attr">user:</span> <span class="string">name=mysql</span> <span class="string">state=absent</span> <span class="string">remove=yes</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">delete</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">path=&#123;&#123;item&#125;&#125;</span> <span class="string">state=absent</span></span><br><span class="line">      <span class="attr">with_items:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">/usr/local/mysql</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/usr/local/mariadb-10.2.27-linux-x86_64</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/etc/init.d/mysqld</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/etc/profile.d/mysql.sh</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/etc/my.cnf</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/data/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="string">ansible-playbook</span>  <span class="string">remove_mysql.yml</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;roles&quot;&gt;&lt;a href=&quot;#roles&quot; class=&quot;headerlink&quot; title=&quot;roles&quot;&gt;&lt;/a&gt;roles&lt;/h2&gt;&lt;p&gt;ansible自1.2版本引入的新特性，用于层次性、结构化地组织playbook。&lt;br&gt;roles能够根据层次型结</summary>
      
    
    
    
    <category term="Ansible" scheme="http://shizhonggan.github.io/categories/Ansible/"/>
    
    
    <category term="运维" scheme="http://shizhonggan.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
</feed>
